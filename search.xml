<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>去努力维护心中的那点正义</title>
      <link href="/3019/11/07/%E5%8E%BB%E5%8A%AA%E5%8A%9B%E7%BB%B4%E6%8A%A4%E5%BF%83%E4%B8%AD%E7%9A%84%E9%82%A3%E7%82%B9%E6%AD%A3%E4%B9%89/"/>
      <url>/3019/11/07/%E5%8E%BB%E5%8A%AA%E5%8A%9B%E7%BB%B4%E6%8A%A4%E5%BF%83%E4%B8%AD%E7%9A%84%E9%82%A3%E7%82%B9%E6%AD%A3%E4%B9%89/</url>
      
        <content type="html"><![CDATA[<p><img src="https://i.loli.net/2019/11/07/kjgSTREJYwLp1da.jpg" alt></p><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>入门数据挖掘3-建模与调参</title>
      <link href="/2020/03/29/%E5%85%A5%E9%97%A8%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%983-%E5%BB%BA%E6%A8%A1%E4%B8%8E%E8%B0%83%E5%8F%82/"/>
      <url>/2020/03/29/%E5%85%A5%E9%97%A8%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%983-%E5%BB%BA%E6%A8%A1%E4%B8%8E%E8%B0%83%E5%8F%82/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h3 id="3-建模与调参"><a href="#3-建模与调参" class="headerlink" title="3. 建模与调参"></a>3. 建模与调参</h3><h4 id="3-1-载入数据"><a href="#3-1-载入数据" class="headerlink" title="3.1 载入数据"></a>3.1 载入数据</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line">warnings.filterwarnings(<span class="string">'ignore'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#    reduce_mem_usage函数通过调整数据类型，帮助我们减少数据在内存中占用的时间</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reduce_mem_usage</span><span class="params">(df)</span>:</span></span><br><span class="line">    </span><br><span class="line">    start_mem = df.memory_usage().sum()</span><br><span class="line">    print(<span class="string">'Memory usage of dataframe is &#123;:.2f&#125; MB'</span>.format(start_mem))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> col <span class="keyword">in</span> df.columns:</span><br><span class="line">        col_type = df[col].dtype</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> col_type != object:</span><br><span class="line">            c_min = df[col].min()</span><br><span class="line">            c_max = df[col].max()</span><br><span class="line">            <span class="keyword">if</span> str(col_type)[:<span class="number">3</span>] == <span class="string">'int'</span>:</span><br><span class="line">                <span class="keyword">if</span> c_min &gt; np.iinfo(np.int8).min <span class="keyword">and</span> c_max &lt; np.iinfo(np.int8).max:</span><br><span class="line">                    df[col] = df[col].astype(np.int8)</span><br><span class="line">                <span class="keyword">elif</span> c_min &gt; np.iinfo(np.int16).min <span class="keyword">and</span> c_max &lt; np.iinfo(np.int16).max:</span><br><span class="line">                    df[col] = df[col].astype(np.int16)</span><br><span class="line">                <span class="keyword">elif</span> c_min &gt; np.iinfo(np.int32).min <span class="keyword">and</span> c_max &lt; np.iinfo(np.int32).max:</span><br><span class="line">                    df[col] = df[col].astype(np.int32)</span><br><span class="line">                <span class="keyword">elif</span> c_min &gt; np.iinfo(np.int64).min <span class="keyword">and</span> c_max &lt; np.iinfo(np.int64).max:</span><br><span class="line">                    df[col] = df[col].astype(np.int64)  </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> c_min &gt; np.finfo(np.float16).min <span class="keyword">and</span> c_max &lt; np.finfo(np.float16).max:</span><br><span class="line">                    df[col] = df[col].astype(np.float16)</span><br><span class="line">                <span class="keyword">elif</span> c_min &gt; np.finfo(np.float32).min <span class="keyword">and</span> c_max &lt; np.finfo(np.float32).max:</span><br><span class="line">                    df[col] = df[col].astype(np.float32)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    df[col] = df[col].astype(np.float64)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            df[col] = df[col].astype(<span class="string">'category'</span>)</span><br><span class="line"></span><br><span class="line">    end_mem = df.memory_usage().sum() </span><br><span class="line">    print(<span class="string">'Memory usage after optimization is: &#123;:.2f&#125; MB'</span>.format(end_mem))</span><br><span class="line">    print(<span class="string">'Decreased by &#123;:.1f&#125;%'</span>.format(<span class="number">100</span> * (start_mem - end_mem) / start_mem))</span><br><span class="line">    <span class="keyword">return</span> df  </span><br><span class="line"></span><br><span class="line">sample_feature = reduce_mem_usage(pd.read_csv(<span class="string">'data_for_tree.csv'</span>))</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/xutianyun1/cloudimage/master/img/20200329122635.png" alt></p><h4 id="3-2-线性回归"><a href="#3-2-线性回归" class="headerlink" title="3.2 线性回归"></a>3.2 线性回归</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">continuous_feature_names = [x <span class="keyword">for</span> x <span class="keyword">in</span> sample_feature.columns <span class="keyword">if</span> x <span class="keyword">not</span> <span class="keyword">in</span> [<span class="string">'price'</span>,<span class="string">'brand'</span>,<span class="string">'model'</span>]]</span><br><span class="line"></span><br><span class="line">sample_feature = sample_feature.dropna().replace(<span class="string">'-'</span>,<span class="number">0</span>).reset_index(drop=<span class="literal">True</span>)</span><br><span class="line">sample_feature</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/xutianyun1/cloudimage/master/img/20200329122914.png" alt></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#    将非数值型类型转换为数字型类型</span></span><br><span class="line">sample_feature[<span class="string">'notRepairedDamage'</span>] = sample_feature[<span class="string">'notRepairedDamage'</span>].astype(np.float32)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#    划分为特征向量和标签向量</span></span><br><span class="line">train = sample_feature[continuous_feature_names + [<span class="string">'price'</span>]]</span><br><span class="line">train_X = train[continuous_feature_names]</span><br><span class="line">train_y = train[<span class="string">'price'</span>]</span><br></pre></td></tr></table></figure><p>使用sklearn简单建模</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LinearRegression</span><br><span class="line">model = LinearRegression(normalize=<span class="literal">True</span>)</span><br><span class="line">model = model.fit(train_X, train_y)</span><br></pre></td></tr></table></figure><p>绘制特征v_9的值与标签的散点图，图片发现模型的预测结果（蓝色点）与真实标签（黑色点）的分布差异较大，且部分预测值出现了<strong>小于0</strong>的情况，说明我们的模型存在一些问题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line">subsample_index = np.random.randint(low=<span class="number">0</span>, high=len(train_y), size=<span class="number">50</span>)</span><br><span class="line">plt.scatter(train_X[<span class="string">'v_9'</span>][subsample_index], train_y[subsample_index], color=<span class="string">'black'</span>)</span><br><span class="line">plt.scatter(train_X[<span class="string">'v_9'</span>][subsample_index], model.predict(train_X.loc[subsample_index]), color=<span class="string">'blue'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'v_9'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'price'</span>)</span><br><span class="line">plt.legend([<span class="string">'True Price'</span>,<span class="string">'Predicted Price'</span>],loc=<span class="string">'upper right'</span>)</span><br><span class="line">print(<span class="string">'The predicted price is obvious different from true price'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/xutianyun1/cloudimage/master/img/20200329123227.png" alt></p><p>这是由于咱们在EDA就发现的情况，即price的分布存在长尾问题，所以我们对price进行log变换后再进行训练。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">train_y_ln = np.log(train_y+<span class="number">1</span>)</span><br><span class="line">model = model.fit(train_X, train_y_ln)</span><br><span class="line">print(<span class="string">'intercept:'</span>+ str(model.intercept_))</span><br><span class="line">sorted(dict(zip(continuous_feature_names, model.coef_)).items(), key=<span class="keyword">lambda</span> x:x[<span class="number">1</span>], reverse=<span class="literal">True</span>)</span><br><span class="line">plt.scatter(train_X[<span class="string">'v_9'</span>][subsample_index], train_y[subsample_index], color=<span class="string">'black'</span>)</span><br><span class="line">plt.scatter(train_X[<span class="string">'v_9'</span>][subsample_index], np.exp(model.predict(train_X.loc[subsample_index])), color=<span class="string">'blue'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'v_9'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'price'</span>)</span><br><span class="line">plt.legend([<span class="string">'True Price'</span>,<span class="string">'Predicted Price'</span>],loc=<span class="string">'upper right'</span>)</span><br><span class="line">print(<span class="string">'The predicted price seems normal after np.log transforming'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/xutianyun1/cloudimage/master/img/20200329123421.png" alt></p><p>看起来，已经比上面那张图要好很多。</p><h4 id="3-3-k折交叉验证"><a href="#3-3-k折交叉验证" class="headerlink" title="3.3 k折交叉验证"></a>3.3 k折交叉验证</h4><p>​        在使用训练集对参数进行训练的时候，经常会发现人们通常会将一整个训练集分为三个部分（比如mnist手写训练集）。一般分为：训练集（train_set），评估集（valid_set），测试集（test_set）这三个部分。这其实是为了保证训练效果而特意设置的。其中测试集很好理解，其实就是完全不参与训练的数据，仅仅用来观测测试效果的数据。而训练集和评估集则牵涉到下面的知识了。</p><pre><code>因为在实际的训练中，训练的结果对于训练集的拟合程度通常还是挺好的（初始条件敏感），但是对于训练集之外的数据的拟合程度通常就不那么令人满意了。因此我们通常并不会把所有的数据集都拿来训练，而是分出一部分来（这一部分不参加训练）对训练集生成的参数进行测试，相对客观的判断这些参数对训练集之外的数据的符合程度。这种思想就称为交叉验证（Cross Validation）</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lightgbm <span class="keyword">as</span> lgb</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> StratifiedKFold</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> metrics</span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line">pd.set_option(<span class="string">'display.max_columns'</span>, <span class="number">100</span>)</span><br><span class="line">warnings.filterwarnings(<span class="string">'ignore'</span>)</span><br><span class="line"><span class="comment">#     载入数据</span></span><br><span class="line">data = reduce_mem_usage(pd.read_csv(<span class="string">'data_for_tree.csv'</span>))</span><br><span class="line"><span class="comment">#    切分训练集与测试集</span></span><br><span class="line">train_data = data[data[<span class="string">'train'</span>]==<span class="number">1</span>]</span><br><span class="line">test_data = data[data[<span class="string">'train'</span>]==<span class="number">0</span>]</span><br><span class="line"><span class="comment">#    特征</span></span><br><span class="line">features = [x <span class="keyword">for</span> x <span class="keyword">in</span> data.columns <span class="keyword">if</span> x <span class="keyword">not</span> <span class="keyword">in</span> [<span class="string">'price'</span>,<span class="string">'SaleID'</span>]]</span><br><span class="line"><span class="comment">#y = np.log(train_data['price']+1)</span></span><br><span class="line"><span class="comment">#    特征向量以及标签</span></span><br><span class="line">X = train_data[features]</span><br><span class="line">y = train_data[<span class="string">'price'</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#    k折交叉验证</span></span><br><span class="line">k = <span class="number">5</span></span><br><span class="line">fold=StratifiedKFold(n_splits=k,shuffle=<span class="literal">True</span>,random_state=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">models = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> train_idx, val_idx <span class="keyword">in</span> fold.split(X, y):</span><br><span class="line"></span><br><span class="line">    model = lgb.LGBMRegressor(objective=<span class="string">'regression'</span>,num_leaves=<span class="number">31</span>,learning_rate=<span class="number">0.05</span>,n_estimators=<span class="number">2000</span>)</span><br><span class="line">    model.fit(X.iloc[train_idx], y.iloc[train_idx],eval_set=[(X.iloc[val_idx], y.iloc[val_idx])],eval_metric=<span class="string">'l1'</span>,early_stopping_rounds=<span class="number">5</span>)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    models.append(model)</span><br><span class="line">    val_pred = model.predict(X.iloc[val_idx])</span><br><span class="line">    </span><br><span class="line">    score = mean_absolute_error(y.iloc[val_idx],val_pred)</span><br><span class="line">    <span class="comment">#scores.append(score)</span></span><br><span class="line">    print( <span class="string">'--------------'</span>)</span><br><span class="line">    print(<span class="string">'val mae:'</span>, np.mean(score))</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/xutianyun1/cloudimage/master/img/20200329200644.png" alt></p><h4 id="3-4-嵌入式特征选择"><a href="#3-4-嵌入式特征选择" class="headerlink" title="3.4 嵌入式特征选择"></a>3.4 嵌入式特征选择</h4><p>嵌入式特征选择是将特征选择过程与学习器训练过程融为一体，两者在同一个优化过程中完成，即在学习器训练过程中自动地进行了特征选择。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> SelectFromModel</span><br><span class="line">clf = lgb.LGBMRegressor()</span><br><span class="line">embeded_lgb_selector = SelectFromModel(clf, max_features=<span class="number">50</span>)</span><br><span class="line">embeded_lgb_selector.fit(X, y)</span><br><span class="line">embeded_lgb_support = embeded_lgb_selector.get_support()</span><br><span class="line">embeded_lgb_feature = X.loc[:,embeded_lgb_support].columns.tolist()</span><br><span class="line">print(str(len(embeded_lgb_feature)), <span class="string">'selected features'</span>) </span><br><span class="line"></span><br><span class="line">embeded_lgb_feature</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/xutianyun1/cloudimage/master/img/20200330124006.png" alt></p><blockquote><p>但是我用筛选出来地这27个特征重新做5折交叉验证，效果却比不做特征筛选地要差。</p></blockquote><h4 id="3-5-GridSearchCV-网格搜索调参"><a href="#3-5-GridSearchCV-网格搜索调参" class="headerlink" title="3.5 GridSearchCV 网格搜索调参"></a>3.5 GridSearchCV 网格搜索调参</h4><p><strong>GridSearchCV</strong>：一种调参的方法，当你算法模型效果不是很好时，可以通过该方法来调整参数，通过循环遍历，尝试每一种参数组合，返回最好的得分值的参数组合。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> GridSearchCV</span><br><span class="line">objective = [<span class="string">'regression'</span>, <span class="string">'regression_l1'</span>, <span class="string">'mape'</span>, <span class="string">'huber'</span>, <span class="string">'fair'</span>]</span><br><span class="line">num_leaves = [<span class="number">3</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">15</span>,<span class="number">20</span>,<span class="number">40</span>, <span class="number">55</span>]</span><br><span class="line">max_depth = [<span class="number">3</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">15</span>,<span class="number">20</span>,<span class="number">40</span>, <span class="number">55</span>]</span><br><span class="line">parameters = &#123;<span class="string">'objective'</span>: objective, <span class="string">'num_leaves'</span>: num_leaves, <span class="string">'max_depth'</span>: max_depth&#125;</span><br><span class="line">model = lgb.LGBMRegressor()</span><br><span class="line">clf = GridSearchCV(model, parameters, cv=<span class="number">5</span>)</span><br><span class="line">clf = clf.fit(X, y)</span><br><span class="line">clf.best_params_</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/xutianyun1/cloudimage/master/img/20200330152636.png" alt></p><h4 id="3-6-贝叶斯调参"><a href="#3-6-贝叶斯调参" class="headerlink" title="3.6 贝叶斯调参"></a>3.6 贝叶斯调参</h4><p><strong>贝叶斯调参</strong>：贝叶斯优化是一种用模型找到函数最小值方法，已经应用于机器学习问题中的超参数搜索，这种方法性能好，同时比随机搜索省时。贝叶斯优化通过基于目标函数的过去评估结果建立替代函数（概率模型），来找到最小化目标函数的值。贝叶斯方法与随机或网格搜索的不同之处在于，它在尝试下一组超参数时，会参考之前的评估结果，因此可以省去很多无用功。</p><p>​    贝叶斯优化问题的四个部分：</p><pre><code>+  **目标函数**：即我们想要最小化的内容。在这里，目标函数是机器学习模型使用该组超参数在验证集上的损失。+  **域空间**：要搜索的超参数的取值范围。+  **优化算法**: 构造替代函数并选择下一个超参数值进行评估的方法。+  **结果历史记录**：来自目标函数评估的存储结果，包括超参数和验证集上的损失。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据挖掘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据挖掘 </tag>
            
            <tag> 建模 </tag>
            
            <tag> 调参 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>入门数据挖掘2-特征工程</title>
      <link href="/2020/03/26/%E5%85%A5%E9%97%A8%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%982-%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B/"/>
      <url>/2020/03/26/%E5%85%A5%E9%97%A8%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%982-%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/xutianyun1/cloudimage/master/img/20200326155723.png" alt></p><a id="more"></a><p>[toc]</p><hr><h3 id="2-特征工程"><a href="#2-特征工程" class="headerlink" title="2.  特征工程"></a>2.  特征工程</h3><p>​        常见的特征工程包括</p><p>​    1. 异常处理：</p><ul><li><p>通过箱线图（或3-Sigma）分析删除异常值</p><blockquote><p>3-Sigma：标准正态分布中99.73%的数据都在（u-3α,u+3α）之间，因此我们可以认为超过这个氛围的数据是异常的。</p><p>如果数据分布并不是正态分布，那么3-Sigma原则就不一定适用，当然如果近似正态分布，还是可以的。</p><p>因此箱线图是一种普适的方法，而3-Sigma的使用是有条件：正态分布或近似正态分布。</p></blockquote></li><li><p>BOX-COX转换（处理有偏分布）</p><blockquote><p>BOX-COX转换定义：线性回归模型满足线性、独立性、方差齐性以及正态性的同时，不丢失信息，此种变换为BOX-COX变换</p><p><img src="https://raw.githubusercontent.com/xutianyun1/cloudimage/master/img/20200326155723.png" alt></p><p>对于<strong>有偏分布</strong>，通过BOX-COX转换为正态分布，再通过箱型图或3-Sigma处理</p></blockquote></li><li><p>长尾截断</p></li></ul><ol start="2"><li>特征归一化/标准化</li></ol><p>优点</p><ul><li><p>标准化（转换为标准正态分布）</p><blockquote><p>数据的标准化是将数据按比例缩放，使之落入一个小的特定的空间</p><p><strong>标准差标准化</strong>：<img src="https://raw.githubusercontent.com/xutianyun1/cloudimage/master/img/20200326165132.png" alt></p><p>该方法适用于样本原始分布近似于高斯分布，归一化结果范围0~1</p></blockquote></li><li><p>归一化（转换到[0,1]区间）</p><blockquote><p><strong>线性归一化</strong>:<img src="https://raw.githubusercontent.com/xutianyun1/cloudimage/master/img/20200326191659.png" alt></p><p>该方法适用于样本分布较为集中的时候，否则归一化结果不够稳定</p></blockquote></li><li><p>针对幂律分布，可以采用公式 <img src="https://raw.githubusercontent.com/xutianyun1/cloudimage/master/img/20200326145523.png" alt></p><blockquote><p>非线性归一化：使用log、tanh等，经常用在数据分化较大的场景，有些数值很大，有些很小，通过一些数学函数，将原始值进行映射。</p></blockquote></li></ul><ol start="3"><li>数据分箱：</li></ol><p>​        数据分箱是一种数据预处理技术，用于减少次要观察误差的影响，是一种将多个连续值分组为较少数量的分箱方法。这种对连续变量离散化后，模型会更稳定，同时也降低了模型过拟合的风险。</p><ul><li><strong>等频分箱</strong>：区间的边界要经过选择，使得每个区间包含大致相等的示例数量。</li><li><strong>等距分箱</strong>：从最小值到最大值之间，均分为N等份，每个区间长度为<code>W=(max-min)/N。</code></li><li><strong>Best-KS分箱</strong>：</li><li><strong>卡方分箱</strong>：自底向上的数据离散化方法。它依赖于卡方检验，将具有最小卡方值的相邻区间合并在一起，知道满足确定的停止准则。</li></ul><ol start="4"><li>缺失值处理：</li></ol><ul><li>不处理，如果使用LGB等树模型</li><li>删除，如果缺失数量太多</li><li>插值补全，包括均值/中位数/众数/建模预测/多重插补/压缩感知补全/矩阵补全等</li><li>利用先验知识填充</li><li>分箱，将缺失值单独分为一个箱</li></ul><ol start="5"><li>特征构造：</li></ol><ul><li><p>构造<strong>统计量</strong>特征，包括<strong>计数</strong>，<strong>求和</strong>，<strong>比例</strong>，<strong>标准差</strong>等一些统计量</p></li><li><p><strong>时间</strong>特征，包括相对时间和绝对是件，节假日，双休日等</p></li><li><p><strong>地理信息</strong>，包括分箱，分布编码等方法，</p></li><li><p><strong>非线性变换</strong>，包括log/平发/根号等</p></li><li><p><strong>特征组合</strong>，<strong>特征交叉</strong></p><blockquote><p>特征组合也叫做特征交叉，但是<strong>合成特征</strong>和特征组合不太一样，特称交叉可以理解为特征组合的一个子集。</p><p><strong>合成特征</strong>：一种特征，不在输入特征之列，而是从一个或多个输入特征衍生而来。通过标准化或缩放单独创建的特征不属于合成特征。</p><p>​    包括以下几种类型：</p><pre><code>1. 将一个特征与其本身或其他特征相乘   2. 两个特征相除      3. 对连续特征进行分箱。</code></pre><p><strong>特称组合</strong>：通过将单独的特征进行组合（相乘或求笛卡尔积）而形成的合成特征。特征组合有助于表示非线性关系。</p></blockquote></li></ul><ol start="6"><li>特征筛选：</li></ol><ul><li><p><strong>过滤式</strong>（filter）：按照发散性或相关性对各个特征进行评分，设定阈值或者待选择特征的个数进行筛选</p><blockquote><p>基本想法： 分别对每个特征xi，计算xi相对于类别标签y的信息量S(i)，得到n个结果。然后将n个S(i)按照从大到小排序，输出前k个特征。我们的目标是选取与y关联最密切的一些特征xi，那么使用什么样的方法来度量S(i)是一个关键问题。</p><p>主要有一下几种方法：</p><ol><li>Pearson相关系数</li><li>卡方验证</li><li>互信息和最大信息系数</li><li>距离相关系数</li><li>方差选择法</li></ol></blockquote></li><li><p><strong>包裹式</strong>（wrapper）: 根据目标函数（往往是预测效果评分），每次选择若干特征，或者排除若干特征</p><blockquote><p>基本思想：基于hold-out方法，对于每一个待选的特征子集，都在训练集上训练一遍模型，然后在测试集上根据误差大小选择出特征子集。</p><p>贪婪搜索算法：是局部最优算法。与之对应的是穷举算法，穷举算法是遍历所有可能的组合达到全局最优，但是不太实际</p><ol><li><strong>前向搜索</strong>：每次增量的从剩余未选中的特征选出一个加入到特征集中，待达到阈值或者n时，从所有F中选出得分最高的特征集。</li><li><strong>后向搜索</strong>：先将F设置为包含全部特征的特征集，然后每次增量的减去特征，直到达到阈值或者为空是，选择最佳的特征集。</li><li><strong>递归特征消除法</strong>：使用一个<strong>基模型</strong>进行多轮训练，每轮训练后通过学习器返回的coef_或者feature_importances_消除哪些权重较底的特征，再基于新的特征集进行下一轮训练。</li></ol></blockquote></li><li><p><strong>嵌入式</strong>（embedding）：先使用某些机器学习的模型进行训练，得到各个特征的权值系数，根据系数从大到小选择特征（类似于Filter，只不过系数是通过训练得来的）</p><blockquote><ul><li>基于惩罚项的特征选择法   通过L1正则项来选择特征：L1正则方法具有稀疏解的特性，因此天然具备特征选择的特性。值得注意的是，L1没有选到的特征不代表不重要，原因是两个具有高相关性的特征可能只保留了一个，如果要确定哪个特征重要需要再通过L2正则方法交叉检验。</li><li>基于学习模型的特征排序   这种方法的思路是直接使用你要用的机器学习算法，针对每个单独的特征和响应变量建立预测模型。假如某个特征和响应变量之间的关系是非线性的，可以用基于树的方法（决策树、随机森林）、或者扩展的线性模型等。基于树的方法比较易于使用，因为他们对非线性关系的建模比较好，并且不需要太多的调试。但要注意过拟合问题，因此树的深度最好不要太大，再就是运用交叉验证。通过这种训练对特征进行打分获得相关性后再训练最终模型。</li></ul></blockquote></li></ul><ol start="7"><li><p>降维</p><p>如果你最后特征工程走一遍下来，特征很多的话，最后进行以下降维.</p></li></ol><ul><li><p>PCA/LDA/ICA</p></li><li><p>特征选择也是一种降维</p></li></ul><h4 id="2-1-前期准备"><a href="#2-1-前期准备" class="headerlink" title="2.1 前期准备"></a>2.1 前期准备</h4><p>导入相关的第三方包</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> itemgetter</span><br><span class="line"></span><br><span class="line">%matplotlib inline</span><br></pre></td></tr></table></figure><p>载入数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">train_data = pd.read_csv(<span class="string">'../data/used_car_train_20200313.csv'</span>, sep=<span class="string">' '</span>)</span><br><span class="line">test_data = pd.read_csv(<span class="string">'../data/user_car_testA_20200313.csv'</span>, sep=<span class="string">' '</span>)</span><br></pre></td></tr></table></figure><p>将训练数据与测试数据放在一起，方便处理</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">train_data[<span class="string">'train'</span>] = <span class="number">1</span></span><br><span class="line">test_data[<span class="string">'train'</span>] = <span class="number">0</span></span><br><span class="line">data=pd.concat([train_data, test_data], ignore_index=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h4 id="2-2-异常值处理"><a href="#2-2-异常值处理" class="headerlink" title="2.2 异常值处理"></a>2.2 异常值处理</h4><p>异常值处理更多是发生在数字特征上，而类别特征最多会出现倾斜的现象，一般这种情况是直接将该特征删除掉。所以，我们通过EDA直到可能会出现异常值的有power、kilemoter以及匿名特征。以<code>power</code>为例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#    观察power的箱型图和柱形图</span></span><br><span class="line">fig, ax = plt.subplots(<span class="number">1</span>, <span class="number">2</span>, figsize=(<span class="number">10</span>, <span class="number">7</span>))</span><br><span class="line">sns.boxplot(y=data[<span class="string">'power'</span>], data = data, ax=ax[<span class="number">0</span>])</span><br><span class="line">sns.distplot(data[<span class="string">'power'</span>], kde=<span class="literal">False</span>, ax=ax[<span class="number">1</span>])</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/xutianyun1/cloudimage/master/img/20200327101454.png" alt></p><blockquote><p>从箱型图可以看到缺失存在很多可以认为异常值的值，可以选择将其进行删除，但是现在我们是将训练数据和测试数据一起处理的，如果选择删除不免会将测试数据删除。因此这里我们可以采用用上限值替换异常值。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">box_plot_outliers</span><span class="params">(data_ser, box_scale)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    利用箱型图的上限值替换异常值</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    iqr = box_scale * (data_ser.quantile(<span class="number">0.75</span>) - data_ser.quantile(<span class="number">0.25</span>))</span><br><span class="line">    val_low = data_ser.quantile(<span class="number">0.25</span>) - iqr</span><br><span class="line">    val_up = data_ser.quantile(<span class="number">0.75</span>) + iqr</span><br><span class="line"></span><br><span class="line">    rule_low = (data_ser &lt; val_low)</span><br><span class="line">    rule_up = (data_ser &gt; val_up)</span><br><span class="line">    index_low = np.arange(data_ser.shape[<span class="number">0</span>])[rule_low]</span><br><span class="line">    index_up = np.arange(data_ser.shape[<span class="number">0</span>])[rule_up]</span><br><span class="line">    <span class="comment">#print(len(index_up))</span></span><br><span class="line">    data.iloc[index_low] = val_low</span><br><span class="line">    data.iloc[index_up] = val_up</span><br><span class="line">    </span><br><span class="line">box_plot_outliers(data[<span class="string">'power'</span>], <span class="number">3</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment">#    重新观察</span></span><br><span class="line">fig, ax = plt.subplots(<span class="number">1</span>, <span class="number">2</span>, figsize=(<span class="number">10</span>, <span class="number">7</span>))</span><br><span class="line">sns.boxplot(y=data[<span class="string">'power'</span>], data = data, ax=ax[<span class="number">0</span>])</span><br><span class="line">sns.distplot(data[<span class="string">'power'</span>], kde=<span class="literal">False</span>, ax=ax[<span class="number">1</span>])</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/xutianyun1/cloudimage/master/img/20200327101558.png" alt></p><p>经过异常值处理后，好了很多。</p><p>本批数据也出现了数据倾斜的现象。直接将其删除，EDA里有记录的。</p><h4 id="2-3-缺失值处理"><a href="#2-3-缺失值处理" class="headerlink" title="2.3 缺失值处理"></a>2.3 缺失值处理</h4><p>我们通过EDA知道缺失值不算多，我们后期使用树模型，所以这里不做处理。</p><h4 id="2-4-数据分箱"><a href="#2-4-数据分箱" class="headerlink" title="2.4 数据分箱"></a>2.4 数据分箱</h4><p><strong>对车辆使用时间分箱</strong></p><blockquote><p>新车使用10年视为报废，把15%作为不折旧的固定部分为残值，其余85%为浮动折旧值。可分三个阶段：3年<del>4年</del>3年来折旧，折旧率分别为11%、10%和9%，前三年每年折11%。</p><p>计算公式为：评估价=市场现行新车售价×[15%（不动残值）+85%（浮动值）×（分阶段折旧率）]+评估值。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用时间：data['creatDate'] - data['regDate']，反应汽车使用时间，一般来说价格与使用时间成反比</span></span><br><span class="line"><span class="comment"># 不过要注意，数据里有时间出错的格式，所以我们需要 errors='coerce'</span></span><br><span class="line">data[<span class="string">'used_time'</span>] = (pd.to_datetime(data[<span class="string">'creatDate'</span>],format=<span class="string">'%Y%m%d'</span>, errors=<span class="string">'coerce'</span>) - </span><br><span class="line">                    pd.to_datetime(data[<span class="string">'regDate'</span>], format=<span class="string">'%Y%m%d'</span>, errors=<span class="string">'coerce'</span>)).dt.days</span><br><span class="line">data[<span class="string">'used_time'</span>]</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/xutianyun1/cloudimage/master/img/20200327111633.png" alt></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">used_time_bin = [<span class="number">0</span>, <span class="number">1068</span>, <span class="number">2492</span>, <span class="number">3560</span>, <span class="number">5340</span>, <span class="number">100000</span>,np.nan]</span><br><span class="line">data[<span class="string">'used_time_bin'</span>] = pd.cut(data[<span class="string">'used_time'</span>], used_time_bin, labels=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>])</span><br><span class="line">data[[<span class="string">'used_time_bin'</span>,<span class="string">'used_time'</span>]].head()</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/xutianyun1/cloudimage/master/img/20200327111712.png" alt></p><p><strong>对车辆形势公里数分箱</strong></p><blockquote><p>具体为：一部车有效寿命30万公里，将其分为5段，每段6万公里，每段价值依序为新车价的5/15、4/15、3/15、2/15、1/15。假设新车价12万元，已行驶7.5万公里（5年左右），那么该车估值为12万元×（3+3+2+1）÷15=7.2万元。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kilometer_bin = [<span class="number">0</span>, <span class="number">6</span>, <span class="number">12</span>, <span class="number">18</span>, <span class="number">24</span>]</span><br><span class="line">data[<span class="string">'kilometer_bin'</span>] = pd.cut(data[<span class="string">'kilometer'</span>], kilometer_bin, labels=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line">data[[<span class="string">'kilometer_bin'</span>, <span class="string">'kilometer'</span>]].head()</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/xutianyun1/cloudimage/master/img/20200327111925.png" alt></p><p><strong>对发动机功率分箱</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bin = [i*<span class="number">10</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">31</span>)]</span><br><span class="line">data[<span class="string">'power_bin'</span>] = pd.cut(data[<span class="string">'power'</span>], bin, labels=<span class="literal">False</span>)</span><br><span class="line">data[[<span class="string">'power_bin'</span>, <span class="string">'power'</span>]].head()</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/xutianyun1/cloudimage/master/img/20200327112004.png" alt> </p><h4 id="2-5-构造特征"><a href="#2-5-构造特征" class="headerlink" title="2.5 构造特征"></a>2.5 构造特征</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从邮编中提取城市信息，相当于加入了先验知识</span></span><br><span class="line">data[<span class="string">'city'</span>] = data[<span class="string">'regionCode'</span>].apply(<span class="keyword">lambda</span> x: str(x)[:<span class="number">-3</span>])</span><br><span class="line"></span><br><span class="line">data = data</span><br></pre></td></tr></table></figure><p>城市的消费水平不同，必然，二手车的价格也就不同。</p><p>我们还可以通过计算训练集中<strong>品牌</strong>、<strong>车型</strong>的<strong>价格</strong>的统计量特征，将其作为特征加入到训练集和测试集中，这相当于加入了先验知识，让模型更好地拟合。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#    品牌</span></span><br><span class="line">train_gb = train_data.groupby(<span class="string">'brand'</span>)</span><br><span class="line">all_info = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> kind, kind_data <span class="keyword">in</span> train_gb:</span><br><span class="line">    info = &#123;&#125;</span><br><span class="line">    kind_data = kind_data[kind_data[<span class="string">'price'</span>]&gt;<span class="number">0</span>]</span><br><span class="line">    info[<span class="string">'brand_amount'</span>] = len(kind_data)</span><br><span class="line">    info[<span class="string">'brand_price_max'</span>] = kind_data.price.max()</span><br><span class="line">    info[<span class="string">'brand_price_median'</span>] = kind_data.price.median()</span><br><span class="line">    info[<span class="string">'brand_price_min'</span>] = kind_data.price.min()</span><br><span class="line">    info[<span class="string">'brand_price_sum'</span>] = kind_data.price.sum()</span><br><span class="line">    info[<span class="string">'brand_price_std'</span>] = kind_data.price.std()</span><br><span class="line">    info[<span class="string">'brand_price_average'</span>] = round(kind_data.price.sum()/(len(kind_data) + <span class="number">1</span>), <span class="number">2</span>)</span><br><span class="line">    all_info[kind] = info</span><br><span class="line"></span><br><span class="line">brand_fe = pd.DataFrame(all_info).T.reset_index().rename(columns=&#123;<span class="string">'index'</span>:<span class="string">'brand'</span>&#125;)</span><br><span class="line">data = data.merge(brand_fe, how=<span class="string">'left'</span>, on=<span class="string">'brand'</span>)</span><br><span class="line">data</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#    车身类型</span></span><br><span class="line">train_gb = train_data.groupby(<span class="string">'bodyType'</span>)</span><br><span class="line">all_info = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> kind, kind_data <span class="keyword">in</span> train_gb:</span><br><span class="line">    info = &#123;&#125;</span><br><span class="line">    kind_data = kind_data[kind_data[<span class="string">'price'</span>]&gt;<span class="number">0</span>]</span><br><span class="line">    info[<span class="string">'bodyType_amount'</span>] = len(kind_data)</span><br><span class="line">    info[<span class="string">'bodyType_price_max'</span>] = kind_data.price.max()</span><br><span class="line">    info[<span class="string">'bodyType_price_median'</span>] = kind_data.price.median()</span><br><span class="line">    info[<span class="string">'bodyType_price_min'</span>] = kind_data.price.min()</span><br><span class="line">    info[<span class="string">'bodyType_price_sum'</span>] = kind_data.price.sum()</span><br><span class="line">    info[<span class="string">'bodyType_price_std'</span>] = kind_data.price.std()</span><br><span class="line">    info[<span class="string">'bodyType_price_average'</span>] = round(kind_data.price.sum() / (len(kind_data) + <span class="number">1</span>), <span class="number">2</span>)</span><br><span class="line">    all_info[kind] = info</span><br><span class="line"></span><br><span class="line">bodyType_fe = pd.DataFrame(all_info).T.reset_index().rename(columns=&#123;<span class="string">'index'</span>: <span class="string">'bodyType'</span>&#125;)</span><br><span class="line">data = data.merge(bodyType_fe, how=<span class="string">'left'</span>, on=<span class="string">'bodyType'</span>)</span><br></pre></td></tr></table></figure><p><strong>匿名特征</strong>：有些比赛的特征是匿名特征，这导致我们并不清楚特征相互直接的关联性，这时我们就只有单纯基于特征进行处理，比如装箱，groupby，agg 等这样一些操作进行一些特征统计，此外还可以对特征进行进一步的 log，exp 等变换，或者对多个特征进行四则变换</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">15</span>):</span><br><span class="line">    targe = <span class="string">'v_'</span> + str(i)</span><br><span class="line">    data[targe+<span class="string">'_log'</span>] = np.log(data[targe]+<span class="number">1</span>)</span><br><span class="line">    data[targe+<span class="string">'_exp'</span>] = np.exp(data[targe])</span><br></pre></td></tr></table></figure><p>目前的数据已经可以给树模型使用了，所以先导出一下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除不需要的数据</span></span><br><span class="line">data = data.drop([<span class="string">'creatDate'</span>,<span class="string">'regDate'</span>,<span class="string">'regionCode'</span>], axis=<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 导出数据</span></span><br><span class="line">data.to_csv(<span class="string">'data_for_tree.csv'</span>, index=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h4 id="2-7-特征筛选"><a href="#2-7-特征筛选" class="headerlink" title="2.7 特征筛选"></a>2.7 特征筛选</h4><p>特征选择有三种方法，我选择了耗时最短也较为简单的过滤式。因为就如吴恩达老师说的，第一步是应该用短时间撸一个baseline出来。所以，另外两种形式，我撸完baseline再补充。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#    过滤式</span></span><br><span class="line">columns = list(data.columns)</span><br><span class="line">columns.pop(columns.index(<span class="string">'train'</span>))</span><br><span class="line"></span><br><span class="line">corr_dict = &#123;&#125; </span><br><span class="line">corr_list = []</span><br><span class="line"><span class="keyword">for</span> feature <span class="keyword">in</span> columns:</span><br><span class="line">    corr_dict[feature] = np.abs(data[feature].corr(data[<span class="string">'price'</span>], method=<span class="string">'spearman'</span>))</span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> sorted(corr_dict, key=corr_dict.__getitem__, reverse=<span class="literal">True</span>):</span><br><span class="line">    corr_list.append([k, corr_dict[k]])</span><br><span class="line">  </span><br><span class="line">corr_list[:<span class="number">10</span>]</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/xutianyun1/cloudimage/master/img/20200328202046.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 数据挖掘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据挖掘 </tag>
            
            <tag> 特征工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>入门数据挖掘1-数据探索EDA</title>
      <link href="/2020/03/24/%E5%85%A5%E9%97%A8%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%981-%E6%95%B0%E6%8D%AE%E6%8E%A2%E7%B4%A2EDA/"/>
      <url>/2020/03/24/%E5%85%A5%E9%97%A8%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%981-%E6%95%B0%E6%8D%AE%E6%8E%A2%E7%B4%A2EDA/</url>
      
        <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/xutianyun1/cloudimage/master/img/20200324152822.png" alt></p><a id="more"></a><p>[toc]</p><hr><h3 id="1-EDA-数据探索"><a href="#1-EDA-数据探索" class="headerlink" title="1. EDA-数据探索"></a>1. EDA-数据探索</h3><p>​        对数据进行EDA主要做的是对数据集的<strong>宏观</strong>分析， 我们要了解数据集的<strong>规模</strong>，查看数据的<strong>统计分布</strong>,了解特征之间的<strong>相关性</strong>等。</p><p>​        我们为什么要做EDA，是为了能够理解数据，所以在开始地时候，我们不能抱有某种偏见，要完全正直，或者把自己当作小白去看数据，一开始，如果你什么都不知道，是对的状态。</p><p>​        在数据可视化中，我们要尽量让简洁图呈现出重要的信息。</p><p>​        描述<strong>趋势</strong>使用<strong>折线图</strong>；</p><p>​        描述<strong>数量</strong>使用<strong>柱状图</strong>；</p><p>​        描述<strong>关系</strong>使用<strong>散点图</strong>；</p><p>​        描述<strong>比例</strong>使用<strong>饼状图</strong>；</p><p>​        本次学习使用天池数据挖掘入门级竞赛，二手车交易价格预测<a href="https://tianchi.aliyun.com/competition/entrance/231784/information" target="_blank" rel="noopener">https://tianchi.aliyun.com/competition/entrance/231784/information</a></p><h4 id="1-1-相关第三方包导入"><a href="#1-1-相关第三方包导入" class="headerlink" title="1.1 相关第三方包导入"></a>1.1 相关第三方包导入</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#    导入warnings包，利用过滤器实现忽略警告语句</span></span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line">warnings.filterwarnings(<span class="string">'ignore'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">import</span> missingno <span class="keyword">as</span> msno</span><br></pre></td></tr></table></figure><p>​        pandas，numpy，matplotlib对于数据分析是非常常见的。本次任务中用到了两个新的库，<strong>seaborn</strong>，<strong>missingno</strong>，</p><p>​        <strong>seaborn</strong>：是基于matplotlib的一个可视化库，相当于对底层matplotlib做了一层封装，可以用它画出更加直观、吸引人的统计图形。</p><p>​        <strong>missingno</strong>：是一个用于<strong>缺失数据</strong>可视化和实用程序的小工具集，我们可以通过它直观的总结数据集的完整性。</p><h4 id="1-2-载入数据"><a href="#1-2-载入数据" class="headerlink" title="1.2 载入数据"></a>1.2 载入数据</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#    载入数据</span></span><br><span class="line">train_data = pd.read_csv(<span class="string">'../data/used_car_train_20200313.csv'</span>,sep=<span class="string">' '</span>)</span><br><span class="line">test_data = pd.read_csv(<span class="string">'../data/used_car_testA_20200313.csv'</span>,sep=<span class="string">' '</span>)</span><br></pre></td></tr></table></figure><p><strong>导入其他格式文件</strong></p><table><thead><tr><th align="right">文件格式</th><th align="right">对应函数</th></tr></thead><tbody><tr><td align="right">CSV文件</td><td align="right">pd.read_csv(filename)</td></tr><tr><td align="right">Excel文件</td><td align="right">pd.read_excel(filename)</td></tr><tr><td align="right">Mysql文件</td><td align="right">pd.read_sql(query, connection_object)+</td></tr><tr><td align="right">文本文件</td><td align="right">pd.read_table(filename)</td></tr></tbody></table><p><code>read_csv()</code>读文件默认是以<strong>逗号</strong>为分隔符，若是以其他分隔符，比如制表符<code>/t</code>，则需要在指定参数<code>sep</code>后加上指定的分隔符，本次数据集使用空格为分隔符。</p><h4 id="1-3-观察数据"><a href="#1-3-观察数据" class="headerlink" title="1.3 观察数据"></a>1.3 观察数据</h4><h5 id="1-3-1-大体观察数据"><a href="#1-3-1-大体观察数据" class="headerlink" title="1.3.1 大体观察数据"></a>1.3.1 大体观察数据</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#    观察数据的前部分，默认是5个，可以加参数</span></span><br><span class="line"><span class="comment">#    train_data.head(10)</span></span><br><span class="line">train_data.head()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#    观察数据的后部分，默认是5个，可以加参数</span></span><br><span class="line"><span class="comment">#    train_data.tail(10)</span></span><br><span class="line">train_data.tail()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#    还可以将二者综合起来一起观察</span></span><br><span class="line">train_data.head().append(train_data.tail())</span><br></pre></td></tr></table></figure><h5 id="1-3-2-观察数据维度"><a href="#1-3-2-观察数据维度" class="headerlink" title="1.3.2 观察数据维度"></a>1.3.2 观察数据<strong>维度</strong></h5><p>这一点十分重要，不然后面模型训练很麻烦。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#    管擦数据的维度</span></span><br><span class="line">train_data.shape</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#    观察数据的列数</span></span><br><span class="line">train_data.shape[<span class="number">1</span>]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#    观察数据的行数</span></span><br><span class="line">train_data.shape[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>测试数据同样要观察，这里不再赘述，下面的笔记也都是值对train做处理，记得test数据做同杨处理即可。</p><h5 id="1-3-3-观察数据的一些相关统计量"><a href="#1-3-3-观察数据的一些相关统计量" class="headerlink" title="1.3.3 观察数据的一些相关统计量"></a>1.3.3 观察数据的一些相关统计量</h5><p>例如总数，平均值，标准差，最小值，25%、50%、75%分数，最大值等。我们可以通过观察某些值提前选定某些异常值或缺失值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#    通过describe()来熟悉数据的相关统计量</span></span><br><span class="line">train_data.describe()</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/xutianyun1/cloudimage/master/img/1585015351116.png" alt></p><h5 id="1-3-4-通过info-来熟悉数据类型"><a href="#1-3-4-通过info-来熟悉数据类型" class="headerlink" title="1.3.4 通过info()来熟悉数据类型"></a>1.3.4 通过<code>info()</code>来熟悉数据类型</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">train_data.info()</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/xutianyun1/cloudimage/master/img/20200324183645.png" alt></p><p>像本此数据，我们可以知道更多的都是数字类型，又可以细分为整型和浮点型，但是值得注意的是有一个数据类型是<code>object</code>。那这个<code>object</code>到底是个啥呢，看下表</p><table><thead><tr><th>:pandas dtype</th><th>:-python类型</th><th>:-numpy类型</th><th>:-用途</th></tr></thead><tbody><tr><td>object</td><td>str</td><td>string, unicode</td><td>文本</td></tr><tr><td>int64</td><td>int</td><td>int, int8, int16, int32, int64, uint8, uint16, uint32, uint64</td><td>整数</td></tr><tr><td>float64</td><td>float</td><td>float，float16，float32，float64</td><td>浮点数</td></tr><tr><td>bool</td><td>bool</td><td>bool</td><td>布尔值</td></tr><tr><td>datetime64</td><td>NA</td><td>NA</td><td>日期时间</td></tr><tr><td>timedelta[ns]</td><td>NA</td><td>NA</td><td>时间差</td></tr><tr><td>category</td><td>NA</td><td>NA</td><td>有限长度的文本值列表</td></tr></tbody></table><h5 id="1-3-5-查看每列的存在的nan情况"><a href="#1-3-5-查看每列的存在的nan情况" class="headerlink" title="1.3.5 查看每列的存在的nan情况"></a>1.3.5 查看每列的存在的nan情况</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#    查看每列的存在nan情况</span></span><br><span class="line">train_data.isnull().sum()</span><br></pre></td></tr></table></figure><p>从这里我们可以知道数据集的某些特征有多少缺失值，对于缺失值的处理也十分重要。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#    对缺失值可视化</span></span><br><span class="line"></span><br><span class="line">missing= train_data.isnull().sum()</span><br><span class="line">missing = missing[missing &gt; <span class="number">0</span>]</span><br><span class="line">missing.sort_values(inplace=<span class="literal">True</span>)</span><br><span class="line">missing.plot.bar()</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/xutianyun1/cloudimage/master/img/20200324102210.png" alt></p><ol><li>如果缺失值的数量很小，一般选择进行填充，当然如果你使用<code>lgb</code>等树模型，可以不做处理，模型会自动优化</li><li>如果缺失值的数量很大，过多，那么我们一般考虑将其删掉，观察模型的得分情况如何。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#    可视化看下缺省值</span></span><br><span class="line">msno.matrix(train_data.sample(<span class="number">250</span>))</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/xutianyun1/cloudimage/master/img/20200324104328.png" alt></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msno.bar(train_data.sample(<span class="number">1000</span>))</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/xutianyun1/cloudimage/master/img/20200324104401.png" alt></p><h5 id="1-3-6-异常值检测"><a href="#1-3-6-异常值检测" class="headerlink" title="1.3.6 异常值检测"></a>1.3.6 异常值检测</h5><p>从上面我们可以知道<code>notRepairedDamage</code>的数据类型不是数字，因此我们先来分析此特征。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">train_data[<span class="string">'notRepairedDamage'</span>].value_counts()</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/xutianyun1/cloudimage/master/img/20200324183809.png" alt></p><p>可以看到该特征有个取值是’-‘，我们可以将其认为为缺失值，替换为<code>nan</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#    将-替换为nan</span></span><br><span class="line">train_data[<span class="string">'notRepairedDamage'</span>].replace(<span class="string">'-'</span>, np.nan, inplace=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>对于<code>seller</code>和<code>offerType</code>这两个特征严重倾斜，对预测结果的意义不大，因此我们可以直接将其删除掉。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">del</span> train_data[<span class="string">'seller'</span>]</span><br><span class="line"><span class="keyword">del</span> train_data[<span class="string">'offerType'</span>]</span><br></pre></td></tr></table></figure><h5 id="1-3-7-了解预测值分布"><a href="#1-3-7-了解预测值分布" class="headerlink" title="1.3.7 了解预测值分布"></a>1.3.7 了解预测值分布</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">train_data[<span class="string">'price'</span>]</span><br></pre></td></tr></table></figure><p>我们通过观察预测值，可以知道这是一个分类任务还是回归任务，本此数据集，显然是一个回归任务。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">train_data[<span class="string">'price'</span>].value_counts()</span><br></pre></td></tr></table></figure><p>预测值的总体分布概况</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#    总体分布概况</span></span><br><span class="line"><span class="keyword">import</span> scipy.stats <span class="keyword">as</span> st</span><br><span class="line">y = train_data[<span class="string">'price'</span>]</span><br><span class="line">plt.figure(<span class="number">1</span>);plt.title(<span class="string">'Johnson SU'</span>)</span><br><span class="line">sns.distplot(y, kde=<span class="literal">False</span>, fit=st.johnsonsu)</span><br><span class="line">plt.figure(<span class="number">2</span>);plt.title(<span class="string">'Normal'</span>)</span><br><span class="line">sns.distplot(y, kde=<span class="literal">False</span>, fit=st.norm)</span><br><span class="line">plt.figure(<span class="number">3</span>);plt.title(<span class="string">'Log Normal'</span>)</span><br><span class="line">sns.distplot(y, kde=<span class="literal">False</span>, fit=st.lognorm)</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/xutianyun1/cloudimage/master/img/20200324105351.png" alt></p><p><img src="https://raw.githubusercontent.com/xutianyun1/cloudimage/master/img/20200324105429.png" alt></p><p><img src="https://raw.githubusercontent.com/xutianyun1/cloudimage/master/img/20200324183902.png" alt></p><p>​        <strong>约翰逊分布</strong>是经过约翰变换后服从正态分布的随机变量的概率分布<br>​        <code>displot()</code>集合了<code>matplotlib</code>的<code>hist()</code>与核函数估计<code>kdeplot</code>的功能，增加了<code>rugplot</code>分布观测条显示与利用<code>scipy</code>库<code>fit</code>拟合参数分布的新颖功能  </p><p>​        从图可以知道，价格很明显是不符合正态分布的，所在在进行回归之前，必须进行转换。最佳拟合无界约翰逊分布。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#    查看预测值的具体频数</span><br><span class="line">plt.hist(train_data[&apos;price&apos;], orientation=&apos;vertical&apos;,histtype=&apos;bar&apos;)</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/xutianyun1/cloudimage/master/img/20200324183941.png" alt></p><p>从图中可以看出0到20000的取值占了绝大部分。因此，我们在做模型训练的时候，可以将其视作一条<strong>规则</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#    对数变换后观察分布、</span></span><br><span class="line">plt.hist(np.log(train_data[<span class="string">'price'</span>]), orientation=<span class="string">'vertical'</span>, histtype=<span class="string">'bar'</span>)</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/xutianyun1/cloudimage/master/img/20200324145602.png" alt></p><p>值得注意的是，经过对数变换后，分布较为均匀，有点<strong>正态</strong>分布的意思了。</p><h5 id="1-3-7查看峰度和偏度"><a href="#1-3-7查看峰度和偏度" class="headerlink" title="1.3.7查看峰度和偏度"></a>1.3.7查看峰度和偏度</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#    查看偏度和峰度</span></span><br><span class="line">sns.distplot(train_data[<span class="string">'price'</span>]);</span><br><span class="line">print(<span class="string">'Skewness: %f'</span> % train_data[<span class="string">'price'</span>].skew())</span><br><span class="line">print(<span class="string">'Kurtness: %f'</span> % train_data[<span class="string">'price'</span>].kurt())</span><br></pre></td></tr></table></figure><p><strong>偏度</strong>：偏度（skewness）也称为偏态、偏态系数，是统计数据分布<strong>偏斜</strong>方向和程度的度量，是统计数据分布<strong>非对称</strong>程度的数字特征  </p><p><strong>峰度</strong>：峰度（Kurtosis）与偏度类似，是描述总体中所有取值分布形态陡缓程度的统计量。这个统计量需要与正态分布相比较，峰度为0表示该总体数据分布与正态分布的陡缓程度相同；峰度大于0表示该总体数据分布与正态分布相比较为陡峭，为尖顶峰；峰度小于0表示该总体数据分布与正态分布相比较为平坦，为平顶峰。峰度的绝对值数值越大表示其分布形态的陡缓程度与正态分布的差异程度越大</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#    查看所有特征的峰度和偏度</span></span><br><span class="line">train_data.skew(), train_data.kurt()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#    可视化偏度</span></span><br><span class="line">sns.distplot(train_data.skew(), color=<span class="string">'blue'</span>, axlabel=<span class="string">'Skewness'</span>)</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/xutianyun1/cloudimage/master/img/20200324142743.png" alt></p><p>横坐标是偏度，纵坐标是该偏度值在总体 样本中占的百分比，从图中可以看出，-10~10的偏度更多一些，尤其是0附近的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#    可视化峰度</span></span><br><span class="line">sns.distplot(train_data.kurt(), color=<span class="string">'orange'</span>, axlabel=<span class="string">'Kurtness'</span>)</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/xutianyun1/cloudimage/master/img/20200324143930.png" alt></p><h4 id="1-4-对特征分类观察分析"><a href="#1-4-对特征分类观察分析" class="headerlink" title="1.4 对特征分类观察分析"></a>1.4 对特征分类观察分析</h4><p>特征可以分类为<strong>数字</strong>特征和<strong>类别</strong>特征，这两者既有联系也有区别，我们需要将其分类观察分析。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#    将特征进行分类</span></span><br><span class="line">numeric_features = [<span class="string">'power'</span>, <span class="string">'kilometer'</span>, <span class="string">'v_0'</span>,<span class="string">'v_1'</span>,<span class="string">'v_2'</span>,<span class="string">'v_3'</span>,<span class="string">'v_4'</span>,<span class="string">'v_5'</span>,<span class="string">'v_6'</span>,<span class="string">'v_7'</span>,<span class="string">'v_8'</span>,<span class="string">'v_9'</span>,<span class="string">'v_10'</span>,<span class="string">'v_11'</span>,<span class="string">'v_12'</span>,<span class="string">'v_13'</span>,<span class="string">'v_14'</span>]</span><br><span class="line"></span><br><span class="line">categorical_features = [ n <span class="keyword">for</span> n <span class="keyword">in</span> list(train_data.columns.values) <span class="keyword">if</span> n <span class="keyword">not</span> <span class="keyword">in</span> numeric_features ]</span><br></pre></td></tr></table></figure><h5 id="1-4-1-数字特征分析"><a href="#1-4-1-数字特征分析" class="headerlink" title="1.4.1 数字特征分析"></a>1.4.1 数字特征分析</h5><h6 id="1-4-1-1-相关性分析"><a href="#1-4-1-1-相关性分析" class="headerlink" title="1.4.1.1 相关性分析"></a>1.4.1.1 相关性分析</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#    观察数字特征和预测值的相关性</span></span><br><span class="line">price_numeric = train_data[numeric_features]</span><br><span class="line">correlation = price_numeric.corr()</span><br><span class="line">print(correlation[<span class="string">'price'</span>].sort_values(ascending=<span class="literal">False</span>),<span class="string">'\n'</span>)</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/xutianyun1/cloudimage/master/img/20200324150402.png" alt></p><p>​        相关性分析是量化不同因素间变动状况一致程度的重要指标。相关程度高的特征是我们希望要的，因为相关程度越高，越说明该特征对预测结果更有帮助。<br>​        相关系数corr，取值在<strong>[-1,1]</strong>。corr值越大，不用因素之间的相关程度越高，<strong>负值表示负相关</strong>，<strong>正值表示正相关</strong><br>​        算法有很多，最常用是Pearson相关系数，还有Spearman相关系数和Kendall相关系数</p><ol><li><strong>Pearson相关系数</strong></li></ol><p>计算公式:<img src="https://raw.githubusercontent.com/xutianyun1/cloudimage/master/img/20200324184024.png" alt></p><p>Numpy和Pandas都提供了Pearson相关系数的计算函数分别是<code>np.corrcoef()</code>和<code>Pandas.corr()</code>。</p><ol start="2"><li><strong>向量夹角余弦</strong></li></ol><p>把两组数据作为两个一维向量，通过计算两个向量的夹角余弦值，同样可以衡量数据的相关程度，取值范围在[-1，1]之间，</p><p>计算公式：<img src="https://raw.githubusercontent.com/xutianyun1/cloudimage/master/img/20200324184047.png" alt></p><ol start="3"><li><p><strong>Spearman相关系数</strong></p><p>Spearman相关系数又称秩相关系数，是利用两变量的<strong>秩次大小</strong>做相关性分析，对原始变量的分布不做要求，也没有线性要求。</p><p>Scipy的<code>spearmanr()</code>函数可以计算Spearman相关系数</p><p>Spearman相关系数有如下特点:</p><ul><li>属于非参数统计方法，适用范围更广。</li><li>对于服从Pearson相关系数的数据亦可计算Spearman相关系数，但统计效能要低一些。</li><li>秩次：样本数据正向排序后的序号（从1开始）</li></ul></li><li><p><strong>kendall相关系数</strong></p><p>肯德尔秩相关系数也是一种秩相关系数，但是他所计算的对象是<strong>分类有序/等级</strong>变量，比如考试名次等。</p><p>特点：</p><ul><li>如果两组排名是相同的，系数为1 ，两个属性正相关。</li><li>如果两组排名完全相反，系数为-1 ，两个属性负相关。</li><li>如果两组排名是完全独立的，系数为0。</li></ul></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#    两两特征间的相关性分析</span></span><br><span class="line">f, ax = plt.subplots(figsize=(<span class="number">7</span>,<span class="number">7</span>))</span><br><span class="line">plt.title(<span class="string">'Correlation of Numeric Features with Price'</span>,y=<span class="number">1</span>,size=<span class="number">16</span>)</span><br><span class="line">sns.heatmap(correlation,square=<span class="literal">True</span>,vmax=<span class="number">0.8</span>)</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/xutianyun1/cloudimage/master/img/20200324152822.png" alt></p><h6 id="1-4-1-2-数字特征分布可视化"><a href="#1-4-1-2-数字特征分布可视化" class="headerlink" title="1.4.1.2 数字特征分布可视化"></a>1.4.1.2 数字特征分布可视化</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">del</span> price_numeric[<span class="string">'price'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#    查看几个特征的偏度和峰度</span></span><br><span class="line"><span class="keyword">for</span> col <span class="keyword">in</span> numeric_features:</span><br><span class="line">    print(<span class="string">'&#123;:15&#125;'</span>.format(col),</span><br><span class="line">          <span class="string">'Skewness: &#123;:05.2f&#125;'</span>.format(train_data[col].skew()),</span><br><span class="line">          <span class="string">' '</span>,</span><br><span class="line">          <span class="string">'Kurtosis: &#123;:06.2f&#125;'</span>.format(train_data[col].kurt())</span><br><span class="line">         )</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#    每个数字特征的分布可视化</span></span><br><span class="line">f = pd.melt(train_data, value_vars=numeric_features)</span><br><span class="line">g = sns.FacetGrid(f, col=<span class="string">'variable'</span>, col_wrap=<span class="number">2</span>, sharex=<span class="literal">False</span>, sharey=<span class="literal">False</span>)</span><br><span class="line">g = g.map(sns.distplot, <span class="string">'value'</span>)</span><br></pre></td></tr></table></figure><p>（图太长了，略略略）</p><p>我们可以从图得出一些结论，例如他在那几个主要的值分布的较多，后期，我们可以尝试做分箱处理。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#    数字特征相互之间的关系可视化</span></span><br><span class="line">sns.set()</span><br><span class="line">columns = [<span class="string">'price'</span>, <span class="string">'v_12'</span>,<span class="string">'v_8'</span>,<span class="string">'power'</span>,<span class="string">'v_5'</span>,<span class="string">'v_2'</span>,<span class="string">'v_6'</span>,<span class="string">'v_1'</span>,<span class="string">'v_14'</span>]</span><br><span class="line">sns.pairplot(train_data[columns], size=<span class="number">2</span>, kind=<span class="string">'scatter'</span>, diag_kind=<span class="string">'kde'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/xutianyun1/cloudimage/master/img/20200324153237.png" alt></p><p>我们可以根据特征之间的相关行，进行特征的筛选，如果两个特征呈现正相关，我们就应该删去一个特征以简化模型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#    多变量互相回归关系可视化</span></span><br><span class="line">fig, ((ax1, ax2), (ax3, ax4), (ax5, ax6), (ax7, ax8), (ax9, ax10)) = plt.subplots(nrows=<span class="number">5</span>, ncols=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">v_12_sactter_plot = pd.concat([Y_train, train_data[<span class="string">'v_12'</span>]], axis=<span class="number">1</span>)</span><br><span class="line">sns.regplot(x=<span class="string">'v_12'</span>,y=<span class="string">'price'</span>,data=v_12_sactter_plot, scatter=<span class="literal">True</span>, fit_reg=<span class="literal">True</span>, ax=ax1)</span><br><span class="line"></span><br><span class="line">v_8_sactter_plot = pd.concat([Y_train, train_data[<span class="string">'v_8'</span>]], axis=<span class="number">1</span>)</span><br><span class="line">sns.regplot(x=<span class="string">'v_8'</span>,y=<span class="string">'price'</span>,data=v_8_sactter_plot, scatter=<span class="literal">True</span>, fit_reg=<span class="literal">True</span>, ax=ax2)</span><br><span class="line"></span><br><span class="line">v_0_sactter_plot = pd.concat([Y_train, train_data[<span class="string">'v_0'</span>]], axis=<span class="number">1</span>)</span><br><span class="line">sns.regplot(x=<span class="string">'v_0'</span>,y=<span class="string">'price'</span>,data=v_0_sactter_plot, scatter=<span class="literal">True</span>, fit_reg=<span class="literal">True</span>, ax=ax3)</span><br><span class="line"></span><br><span class="line">power_sactter_plot = pd.concat([Y_train, train_data[<span class="string">'power'</span>]], axis=<span class="number">1</span>)</span><br><span class="line">sns.regplot(x=<span class="string">'power'</span>,y=<span class="string">'price'</span>,data=power_sactter_plot, scatter=<span class="literal">True</span>, fit_reg=<span class="literal">True</span>, ax=ax4)</span><br><span class="line"></span><br><span class="line">v_5_sactter_plot = pd.concat([Y_train, train_data[<span class="string">'v_5'</span>]], axis=<span class="number">1</span>)</span><br><span class="line">sns.regplot(x=<span class="string">'v_5'</span>,y=<span class="string">'price'</span>,data=v_5_sactter_plot, scatter=<span class="literal">True</span>, fit_reg=<span class="literal">True</span>, ax=ax5)</span><br><span class="line"></span><br><span class="line">v_2_sactter_plot = pd.concat([Y_train, train_data[<span class="string">'v_2'</span>]], axis=<span class="number">1</span>)</span><br><span class="line">sns.regplot(x=<span class="string">'v_2'</span>,y=<span class="string">'price'</span>,data=v_2_sactter_plot, scatter=<span class="literal">True</span>, fit_reg=<span class="literal">True</span>, ax=ax6)</span><br><span class="line"></span><br><span class="line">v_6_sactter_plot = pd.concat([Y_train, train_data[<span class="string">'v_6'</span>]], axis=<span class="number">1</span>)</span><br><span class="line">sns.regplot(x=<span class="string">'v_6'</span>,y=<span class="string">'price'</span>,data=v_6_sactter_plot, scatter=<span class="literal">True</span>, fit_reg=<span class="literal">True</span>, ax=ax7)</span><br><span class="line"></span><br><span class="line">v_1_sactter_plot = pd.concat([Y_train, train_data[<span class="string">'v_1'</span>]], axis=<span class="number">1</span>)</span><br><span class="line">sns.regplot(x=<span class="string">'v_1'</span>,y=<span class="string">'price'</span>,data=v_1_sactter_plot, scatter=<span class="literal">True</span>, fit_reg=<span class="literal">True</span>, ax=ax8)</span><br><span class="line"></span><br><span class="line">v_14_sactter_plot = pd.concat([Y_train, train_data[<span class="string">'v_14'</span>]], axis=<span class="number">1</span>)</span><br><span class="line">sns.regplot(x=<span class="string">'v_14'</span>,y=<span class="string">'price'</span>,data=v_14_sactter_plot, scatter=<span class="literal">True</span>, fit_reg=<span class="literal">True</span>, ax=ax9)</span><br><span class="line"></span><br><span class="line">v_13_sactter_plot = pd.concat([Y_train, train_data[<span class="string">'v_13'</span>]], axis=<span class="number">1</span>)</span><br><span class="line">sns.regplot(x=<span class="string">'v_13'</span>,y=<span class="string">'price'</span>,data=v_13_sactter_plot, scatter=<span class="literal">True</span>, fit_reg=<span class="literal">True</span>, ax=ax10)</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/xutianyun1/cloudimage/master/img/20200324153547.png" alt></p><h5 id="1-4-2-类别特征分析"><a href="#1-4-2-类别特征分析" class="headerlink" title="1.4.2 类别特征分析"></a>1.4.2 类别特征分析</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 2) 类别特征箱形图可视化</span></span><br><span class="line"><span class="comment"># 因为 name和 regionCode的类别太稀疏了，这里我们把不稀疏的几类画一下</span></span><br><span class="line">categorical_features = [<span class="string">'model'</span>, <span class="string">'brand'</span>, <span class="string">'bodyType'</span>, <span class="string">'fuelType'</span>, <span class="string">'gearbox'</span>, <span class="string">'notRepairedDamage'</span>] </span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> categorical_features:    </span><br><span class="line">    train_data[c] = train_data[c].astype(<span class="string">'category'</span>)    </span><br><span class="line">    <span class="keyword">if</span> train_data[c].isnull().any():        </span><br><span class="line">        train_data[c] = train_data[c].cat.add_categories([<span class="string">'MISSING'</span>])        </span><br><span class="line">        train_data[c] = train_data[c].fillna(<span class="string">'MISSING'</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">boxplot</span><span class="params">(x, y, **kwargs)</span>:</span>    </span><br><span class="line">    sns.boxplot(x=x, y=y)    </span><br><span class="line">    x=plt.xticks(rotation=<span class="number">90</span>)</span><br><span class="line">    </span><br><span class="line">f = pd.melt(train_data, id_vars=[<span class="string">'price'</span>], value_vars=categorical_features) </span><br><span class="line">g = sns.FacetGrid(f, col=<span class="string">"variable"</span>,  col_wrap=<span class="number">2</span>, sharex=<span class="literal">False</span>, sharey=<span class="literal">False</span>, size=<span class="number">5</span>) </span><br><span class="line">g = g.map(boxplot, <span class="string">"value"</span>, <span class="string">"price"</span>)</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/xutianyun1/cloudimage/master/img/20200324153957.png" alt></p><p><strong>箱型图</strong>最大的优点就是不受异常值的影响，可以以一种相对稳定的方式藐视数据的离散分布情况，也利于数据的清洗。</p><p><img src="https://raw.githubusercontent.com/xutianyun1/cloudimage/master/img/20200324165722.png" alt></p><p>下四分位数Q1、中位数Q2、上四分位数Q3计算方法：Qi所在的位置=i*(n+1)/4</p><p>上限是<strong>非异常范围</strong>的最大值，四分位距IQR=Q3-Q1,那么上限=Q3 + 1.5IQR</p><p>下限是<strong>非异常范围</strong>的最小值，下限=Q1-1.5IQR</p><ol><li><p>直观明了地识别数据批中的<strong>异常值</strong></p><p>​    箱线图判断异常值的标准以四分位数和四分位距为基础，四分位数具有一定的<strong>耐抗性</strong>，就是多大25%的数据可以变的任意元而不会很大地扰动四分位数，所以异常值不会影响箱型图地数据形状。</p></li><li><p>利用箱线图判断数据集地<strong>偏态</strong>和<strong>尾重</strong></p><p>​    异常值越多说明尾部越重，自由度越小。</p><p>​    偏态表示偏离程度，异常值集中在较小值一侧，则分布呈左偏态；异常值集中在较大值一侧，则分布 呈👉偏态。</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#    类别特征的小提琴图可视化</span></span><br><span class="line">catg_list = categorical_features</span><br><span class="line">target = <span class="string">'price'</span></span><br><span class="line"><span class="keyword">for</span> catg <span class="keyword">in</span> catg_list:</span><br><span class="line">    sns.violinplot(x=catg, y=target, data=train_data)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/xutianyun1/cloudimage/master/img/20200324154057.png" alt></p><p><strong>小提琴图</strong>用来展示类别变量地值地分布情况，宽的地方数据分布多。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#    类别特征的柱形图可视化</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar_plot</span><span class="params">(x,y,**kwargs)</span>:</span></span><br><span class="line">    sns.barplot(x=x,y=y)</span><br><span class="line">    x=plt.xticks(rotation=<span class="number">90</span>)</span><br><span class="line">    </span><br><span class="line">f = pd.melt(train_data, id_vars=[<span class="string">'price'</span>], value_vars=categorical_features)</span><br><span class="line">g = sns.FacetGrid(f, col=<span class="string">'variable'</span>, col_wrap=<span class="number">2</span>, sharex=<span class="literal">False</span>, sharey=<span class="literal">False</span>, size=<span class="number">5</span>)</span><br><span class="line">g = g.map(bar_plot, <span class="string">'value'</span>, <span class="string">'price'</span>)</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/xutianyun1/cloudimage/master/img/20200324171735.png" alt></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#    类别特征的每个类别频数可视化</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count_plot</span><span class="params">(x, **kwargs)</span>:</span></span><br><span class="line">    sns.countplot(x=x)</span><br><span class="line">    x=plt.xticks(rotation=<span class="number">90</span>)</span><br><span class="line">    </span><br><span class="line">f = pd.melt(train_data, value_vars=categorical_features)</span><br><span class="line">g = sns.FacetGrid(f, col=<span class="string">'variable'</span>, col_wrap=<span class="number">2</span>, sharex=<span class="literal">False</span>, sharey=<span class="literal">False</span>, size=<span class="number">5</span>)</span><br><span class="line">g = g.map(count_plot, <span class="string">'value'</span>)</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/xutianyun1/cloudimage/master/img/20200324171808.png" alt></p><hr>]]></content>
      
      
      <categories>
          
          <category> 数据挖掘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据挖掘 </tag>
            
            <tag> 数据探索 </tag>
            
            <tag> EDA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>远程登录Oracle数据库报ORA12368:身份证明检索失败</title>
      <link href="/2019/10/31/%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95Oracle%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%A5ORA12368-%E8%BA%AB%E4%BB%BD%E8%AF%81%E6%98%8E%E6%A3%80%E7%B4%A2%E5%A4%B1%E8%B4%A5/"/>
      <url>/2019/10/31/%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95Oracle%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%A5ORA12368-%E8%BA%AB%E4%BB%BD%E8%AF%81%E6%98%8E%E6%A3%80%E7%B4%A2%E5%A4%B1%E8%B4%A5/</url>
      
        <content type="html"><![CDATA[<p><img src="https://i.loli.net/2019/10/31/SKHNp6LaMGIE2oB.jpg" alt></p><a id="more"></a><p>​    之前都是连接的本地的oracle数据库，全部数据测试完毕后，打算连接服务器上的数据库时出现报错<strong>ORA12368：身份证明检索失败</strong>。</p><p>​    <strong>解决方法：</strong></p><p>​        找到<strong>本地</strong>安装的oracle的客户端数据的安装目录，例如我的是<strong>H:\oracleDatabase\oracleRoot\product\11.2.0\dbhome_1\NETWORK\ADMIN</strong>打开文件<strong>sqlnet.ora</strong>。</p><pre><code>1. 将`SQLNET.AUTHENTICATION_SERVICES= (NTS)`注释掉`#SQLNET.AUTHENTICATION_SERVICES= (NTS)`。  2. 将`SQLNET.AUTHENTICATION_SERVICES= (NTS)`修改为`SQLNET.AUTHENTICATION_SERVICES= (BEQ,NONE)`。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
            <tag> 服务器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>局域网时钟同步PTP协议简介</title>
      <link href="/2019/10/28/%E5%B1%80%E5%9F%9F%E7%BD%91%E6%97%B6%E9%92%9F%E5%90%8C%E6%AD%A5PTP%E5%8D%8F%E8%AE%AE%E7%AE%80%E4%BB%8B/"/>
      <url>/2019/10/28/%E5%B1%80%E5%9F%9F%E7%BD%91%E6%97%B6%E9%92%9F%E5%90%8C%E6%AD%A5PTP%E5%8D%8F%E8%AE%AE%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/xutianyun1/cloudimage/master/img/5b2c772f345ce21897fe5ec9ae348267_hd.jpg" alt></p><a id="more"></a><h3 id="IEEE1588-PTP-协议简介"><a href="#IEEE1588-PTP-协议简介" class="headerlink" title="IEEE1588(PTP)协议简介"></a>IEEE1588(PTP)协议简介</h3><p>​    IEEE1588协议，称作PTP(precise time protocol,  精确时间协议)，2002年发布version1，2008年发布version2。即可以用<strong>硬件</strong>实现，也可以用<strong>软件</strong>实现。当采用硬件实现时可以达到ns级的精度，采用软件实现时通常可以达到ms级精度。当在网络中采用软件实现<em>亚毫秒</em>的精度时，存在多种因素的 影响会造成时间同步的不可靠。例如：<strong>网络的不平稳性</strong>、<strong>网卡对信息包的缓存效应</strong>、<strong>操作系统进程调度的影响</strong>。</p><p>​    IEEE1588v2协议提出的同步原理<strong>Delay Request-Response Mechanism（延时响应机制）</strong>如图1所示。</p><p><img src="https://raw.githubusercontent.com/xutianyun1/cloudimage/master/img/PTP%E5%8D%8F%E8%AE%AE%E5%BB%B6%E8%BF%9F%E5%93%8D%E5%BA%94%E6%9C%BA%E5%88%B6.png" alt="图1 PTP协议延迟响应机制"></p><p>​                                        <strong>图1 PTP协议延迟响应机制</strong></p><p>图中所描述的PTP报文为一下几种：</p><ul><li><strong>sync 同步报文</strong></li><li><strong>Follow_up 跟随报文</strong></li><li><strong>Delay_req 延迟请求报文</strong></li><li><strong>Delay_resp 延迟请求响应报文</strong></li></ul><p><strong>延迟相应同步机制</strong>的报文收发流程：</p><ol><li><p>主时钟<strong>周期性</strong>的发出<strong>sync</strong>报文，并记录下<strong>sync</strong>报文离开主时钟的精确发送时间<strong>t1</strong>。</p><p>（如果sync在此时携带发送时间，这个发送时间并不是精确的，是预估的，在不要求精度的情况下允许这么做，称为单步同步）</p></li><li><p>主时钟将精确发送时间<strong>t1</strong>封装到<strong>Follow_up</strong>报文中，发送给从时钟。</p></li><li><p>从时钟记录<strong>sync</strong>报文到达从时钟的时间<strong>t2</strong>。</p></li><li><p>从时钟发出<strong>Delay_req</strong>报文并且记录下发出的时间<strong>t3</strong>。</p></li><li><p>主时钟记录下<strong>Delay_req</strong>报文到达主时钟的精确时间<strong>t4</strong>。</p></li><li><p>主时钟将<strong>t4</strong>封装到<strong>Delay_resp</strong>报文给从时钟。</p></li></ol><p>主从时钟的差异主要是由时钟偏差和数据包在网络中传输的延迟构成。</p><p><strong>时钟偏差&amp;网络延时</strong></p><p>​    <strong>offset</strong>：主从时钟的时间偏差；<strong>delay</strong>：网络延时（报文在网络中传输的延时）</p><p>​    经过延迟响应同步机制后，从时钟获得<strong>t1,t2,t3,t4</strong>四个精确的时间戳，可以据此计算<strong>offset</strong>和<strong>delay</strong>：</p><p><img src="https://raw.githubusercontent.com/xutianyun1/cloudimage/master/img/%E6%97%B6%E9%92%9F%E5%81%8F%E5%B7%AE%E5%92%8C%E7%BD%91%E7%BB%9C%E5%BB%B6%E6%97%B6%E7%9A%84%E8%AE%A1%E7%AE%97%E5%85%AC%E5%BC%8F.png" alt></p><p>​    在从时钟中计算得到<strong>offset</strong>和<strong>delay</strong>，用<strong>current_time</strong>表示从时钟的当前时间，那么同步公式为：</p><p>​    <strong>current_time = current_time - offset - delay</strong></p><hr><p><strong>参考</strong>：<a href="https://www.cnblogs.com/AdaminXie/p/6754644.html" target="_blank" rel="noopener">https://www.cnblogs.com/AdaminXie/p/6754644.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 车联网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 时钟同步 </tag>
            
            <tag> IEEE1588v2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最长回文子串（马拉车算法）</title>
      <link href="/2019/08/27/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
      <url>/2019/08/27/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<p>﻿最长回文子串，即正反读起来都一样，例如“ababa”。Manacher Algorithm算法利用了回文的重复特性，让时间复杂度降为了O(n)。</p><a id="more"></a><p>马拉车算法详解：</p><ol><li>改造字符串，在中心扩展法中，要求区分字符串长度为奇数或偶数的情况，我们这里对字符串进行简单的改造，让字符串变成奇数便于处理。例：“ababad” —-&gt;“a#b#a#b#a#d”。为了在检测回文子串的时候避免判断越界，我们可以在开头和结束添加两个不同的字符—-&gt;”$a#b#a#b#a#d^”（也不可不做这一步，如果不在开头和结束添加两个不同的字符的话，就需要在检测回文子串的时候检测开头和结尾） </li><li>为了能够充分利用回文子串的重复性质，我们可以将字符串中每个字符的回文半径存如一个数组P中</li><li>这样就将问题转换为了求数组P中的最大值所在的下标和值。但在实际操作中我们并不这样做，是动态的寻着数组P的最大值，即一边写入一边检测，而不是等数组P填充完毕后再去寻找数组P的最大值。因为字符串”a#a”和”#a#”虽然第一个字符串的”#”和第二个字符串的”a”的回文半径是相同的，但是，显而易见，在去掉”#”后 一个是”aa”，一个是”a”。</li><li>关于如何填充数组P<pre><code>先设置两个变量，马拉车算法就是在动态的更新这两个变量。center：是最大回文子串的中心位置mx_right：是最大回文子串所能覆盖的最右端的位置。共分为两种情况：当 i &lt; mx_right时：即i位于目前的最大回文子串max_str中。那么我们根据回文的重复特性，取检查j = 2 * center - i(j为i以center为中心的对称点)。如果P[j] &lt; mx_right - i 说明以j为中心的回文子串依然位于目前的最大回文子串max_str，很具重复特性可以知道此时P[i] == p[j]。如果P[j] &gt;= mx_right - i,此时只能保证到i的回文子串到mx_right这位置是依然满足的，这里别无他法，只能暴力取匹配mx_right外面的，直到失配，然后在根据大小判断是否更新最大回文子串max_str当i &gt;= mx_right时：此时不能充分利用回文子串的重复特性，只能暴力匹配。</code></pre></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestPainromedon</span><span class="params">(s:str)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> len(s) &lt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line">    new_str = <span class="string">'$'</span> + <span class="string">'#'</span>.join(s) + <span class="string">'^'</span><span class="comment">#避免判断越界</span></span><br><span class="line">    center = <span class="number">1</span><span class="comment">#最长回文子串中心位置</span></span><br><span class="line">    mx_right = <span class="number">1</span><span class="comment">#最长回文子串最右面覆盖的位置</span></span><br><span class="line">    max_str = new_str[<span class="number">1</span>]<span class="comment">#最长回文子串</span></span><br><span class="line">    p = [<span class="number">0</span>]*len(new_str)<span class="comment">#回文子串半径表列</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(new_str)<span class="number">-1</span>):</span><br><span class="line"></span><br><span class="line">        j = <span class="number">2</span>*center - i</span><br><span class="line">        <span class="keyword">if</span> i &lt; mx_right:</span><br><span class="line">            <span class="keyword">if</span> p[j] &lt; mx_right - i:</span><br><span class="line">                p[i] = p[j]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                k = mx_right+<span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> new_str[k] == new_str[<span class="number">2</span>*i - k]:</span><br><span class="line">                    k += <span class="number">1</span></span><br><span class="line">                k -= <span class="number">1</span></span><br><span class="line">                p[i] =  k - i</span><br><span class="line">                cur_str = new_str[i - p[i]:i + p[i] + <span class="number">1</span>].replace(<span class="string">'#'</span>, <span class="string">''</span>)</span><br><span class="line">                <span class="keyword">if</span> len(cur_str) &gt; len(max_str):</span><br><span class="line">                    max_str = cur_str</span><br><span class="line">                    center, mx_right = i, k</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            k = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> new_str[i - k - <span class="number">1</span>] == new_str[i + k + <span class="number">1</span>]:</span><br><span class="line">                k += <span class="number">1</span></span><br><span class="line">            p[i] = k</span><br><span class="line">            cur_str = new_str[i - p[i]:i+p[i] + <span class="number">1</span>].replace(<span class="string">'#'</span>, <span class="string">''</span>)</span><br><span class="line">            <span class="keyword">if</span> len(cur_str) &gt; len(max_str):</span><br><span class="line">                max_str = cur_str</span><br><span class="line">                center, mx_right = i, k + i</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max_str</span><br></pre></td></tr></table></figure><p>代码如上，此代码时完全照算法来的，其他的博客的代码我想应该是有所优化，导致我一开始有点懵。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法、字符串、回文子串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python比较时间</title>
      <link href="/2019/08/11/python%E6%AF%94%E8%BE%83%E6%97%B6%E9%97%B4%20(1)/"/>
      <url>/2019/08/11/python%E6%AF%94%E8%BE%83%E6%97%B6%E9%97%B4%20(1)/</url>
      
        <content type="html"><![CDATA[<p>今天在写爬虫的时候，遇到了需要把从网页上爬取下来的时间进行比较，所以遇到了这个问题，如何比较时间，我一开始是打算把它转换为字符串，然后自己撸一个算法进行诸位比较。后来知道可以将其转为datetime格式，就可以进行比较了，而且还可以做减法求两个时间点的时间间隔，无敌！！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line">st = <span class="string">'13:10'</span></span><br><span class="line">time = datetime.datetime.strptime(st, <span class="string">"%Y-%m-%d %H:%M:%S"</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 比较时间 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>独热编码--One-Hot Encoding</title>
      <link href="/2019/06/01/%E7%8B%AC%E7%83%AD%E7%BC%96%E7%A0%81%E2%80%94%E2%80%94One-Hot%20Encoding%20(2)/"/>
      <url>/2019/06/01/%E7%8B%AC%E7%83%AD%E7%BC%96%E7%A0%81%E2%80%94%E2%80%94One-Hot%20Encoding%20(2)/</url>
      
        <content type="html"><![CDATA[<p>﻿ - One-Hot Encoding介绍<br>         又称为一位有效编码，用N位状态寄存器来对N个状态进行编码，每个状态都由独立的寄存器表示，其中只有一位有效。<br>         对于1， 2， 3，经过独热编码后为001，010，100</p><ul><li>应用<br> 对于有些特征变量可能是属性变量，<br> 如color：[‘red’,’blue’,’green’]<br>我们就要把这个color特征变量编码为数字。我们可编码为[1,2,3]。但是这样的编码并不能直接应用于我们的分类器中，因为分类器往往默认特征变量数据是连续的（可以计算距离的）、有序的（3&gt;2&gt;1）。但是按照我们的常识，如果像这样编码显然是不合理的，因为为‘red’、‘blue’、‘green’并没有什么联系，是相互独立的。<br> 因此我们就要使用独热编码来避免出现这种情况。</li></ul>]]></content>
      
      
      <categories>
          
          <category> ML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 编码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>吴恩达《机器学习》——第七次作业：k-means算法</title>
      <link href="/2019/06/01/%E5%90%B4%E6%81%A9%E8%BE%BE%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E2%80%94%E2%80%94%E7%AC%AC%E4%B8%83%E6%AC%A1%E4%BD%9C%E4%B8%9A%EF%BC%9Ak-means%E7%AE%97%E6%B3%95/"/>
      <url>/2019/06/01/%E5%90%B4%E6%81%A9%E8%BE%BE%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E2%80%94%E2%80%94%E7%AC%AC%E4%B8%83%E6%AC%A1%E4%BD%9C%E4%B8%9A%EF%BC%9Ak-means%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<ol><li><p>2D-kmeans算法</p><a id="more"></a></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sb</span><br><span class="line"><span class="keyword">from</span> scipy.io <span class="keyword">import</span> loadmat</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_closet_centroids</span><span class="params">(X, centroids)</span>:</span></span><br><span class="line">    <span class="string">'''将每个特征计算属于那个特征'''</span></span><br><span class="line">    m = X.shape[<span class="number">0</span>]</span><br><span class="line">    k = centroids.shape[<span class="number">0</span>]</span><br><span class="line">    idx = np.zeros(m)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line"></span><br><span class="line">        min_dist = <span class="number">1000000</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(k):</span><br><span class="line"></span><br><span class="line">            dist = np.sum((X[i, :] - centroids[j, :]) ** <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">if</span> dist &lt; min_dist:</span><br><span class="line">                min_dist = dist</span><br><span class="line">                idx[i] = j</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> idx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compute_centroids</span><span class="params">(X, idx, k)</span>:</span></span><br><span class="line">    <span class="string">'''更新聚类中心'''</span></span><br><span class="line">    m, n = X.shape</span><br><span class="line">    centroids = np.zeros((k, n))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line"></span><br><span class="line">        indices = np.where(idx == i)</span><br><span class="line">        centroids[i, :] = (np.sum(X[indices, :], axis=<span class="number">1</span>) / len(indices[<span class="number">0</span>])).ravel()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> centroids</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_one_kmeans</span><span class="params">(X, initial_centroids, max_iters)</span>:</span></span><br><span class="line">    <span class="string">'''运行k-means均值算法进行聚类'''</span></span><br><span class="line">    m, n = X.shape</span><br><span class="line">    k = initial_centroids.shape[<span class="number">0</span>]</span><br><span class="line">    idx = np.zeros(m)</span><br><span class="line">    centroids = initial_centroids</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(max_iters):</span><br><span class="line">        idx = find_closet_centroids(X, centroids)</span><br><span class="line">        centroids = compute_centroids(X, idx, k)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> idx, centroids</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init_centroids</span><span class="params">(X, k)</span>:</span></span><br><span class="line">    <span class="string">'''随机初始化聚类中心'''</span></span><br><span class="line">    m, n = X.shape</span><br><span class="line">    centroids = np.zeros((k, n))</span><br><span class="line">    idx = np.random.randint(<span class="number">0</span>, m, k)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">        centroids[i, :] = X[idx[i], :]</span><br><span class="line">    <span class="keyword">return</span> centroids</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_all_kmeans</span><span class="params">(X, k, n_init, max_iter)</span>:</span></span><br><span class="line">    <span class="string">'''kmeans算法'''</span></span><br><span class="line">    min_dist = <span class="number">1000000</span></span><br><span class="line">    m, n = X.shape</span><br><span class="line">    result_centroids = np.zeros((k, n))</span><br><span class="line">    result_idx = np.zeros(m)</span><br><span class="line">    cnt = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n_init):</span><br><span class="line">        initial_centroids = init_centroids(X, k)        <span class="comment">#</span></span><br><span class="line">        <span class="comment">#print(initial_centroids)</span></span><br><span class="line">        idx, centroids = run_one_kmeans(X, initial_centroids, max_iter)</span><br><span class="line">        dist = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(m):</span><br><span class="line">            dist += np.sum((X[j, :] - centroids[int(idx[j]), :]) ** <span class="number">2</span>) / len(X)</span><br><span class="line">        <span class="keyword">if</span> dist &lt; min_dist:</span><br><span class="line">            min_dist = dist</span><br><span class="line">            result_idx = idx</span><br><span class="line">            result_centroids = centroids</span><br><span class="line">            cnt = i</span><br><span class="line">    <span class="comment">#print(cnt)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result_idx, result_centroids</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">data = loadmat(<span class="string">'data/ex7data2.mat'</span>)</span><br><span class="line">X = data[<span class="string">'X'</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">idx, centroids = run_all_kmeans(X, <span class="number">3</span>, <span class="number">30</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">cluster1 = X[np.where(idx == <span class="number">0</span>)[<span class="number">0</span>], :]</span><br><span class="line">cluster2 = X[np.where(idx == <span class="number">1</span>)[<span class="number">0</span>], :]</span><br><span class="line">cluster3 = X[np.where(idx == <span class="number">2</span>)[<span class="number">0</span>], :]</span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">12</span>, <span class="number">8</span>))</span><br><span class="line">ax.scatter(cluster1[:, <span class="number">0</span>], cluster1[:, <span class="number">1</span>], s=<span class="number">30</span>, color=<span class="string">'r'</span>, label=<span class="string">'Cluster 1'</span>)</span><br><span class="line">ax.scatter(cluster2[:, <span class="number">0</span>], cluster2[:, <span class="number">1</span>], s=<span class="number">30</span>, color=<span class="string">'g'</span>, label=<span class="string">'Cluster 2'</span>)</span><br><span class="line">ax.scatter(cluster3[:, <span class="number">0</span>], cluster3[:, <span class="number">1</span>], s=<span class="number">30</span>, color=<span class="string">'b'</span>, label=<span class="string">'Cluster 3'</span>)</span><br><span class="line">ax.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20190525172655371.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NoZXJpc2hfeA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ol start="2"><li>k-means应用：图像压缩<br>图像压缩前：<br><img src="https://img-blog.csdnimg.cn/20190525180102555.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NoZXJpc2hfeA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython.display <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sb</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> k_means_and_PCA.kmeans_2D <span class="keyword">import</span> run_all_kmeans</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> scipy.io <span class="keyword">import</span> loadmat</span><br><span class="line"></span><br><span class="line">Image(filename=<span class="string">'data/bird_small.png'</span>)</span><br><span class="line"></span><br><span class="line">image_data = loadmat(<span class="string">'data/bird_small.mat'</span>)</span><br><span class="line"></span><br><span class="line">A = image_data[<span class="string">'A'</span>] / <span class="number">255</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">X = np.reshape(A, (A.shape[<span class="number">0</span>] * A.shape[<span class="number">1</span>], A.shape[<span class="number">2</span>]))</span><br><span class="line"></span><br><span class="line">idx, centroids = run_all_kmeans(X, <span class="number">16</span>, <span class="number">10</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">X_recovered = centroids[idx.astype(int), :]</span><br><span class="line">X_recovered = np.reshape(X_recovered, (A.shape[<span class="number">0</span>], A.shape[<span class="number">1</span>], A.shape[<span class="number">2</span>]))</span><br><span class="line">X_recovered *= <span class="number">255</span></span><br><span class="line">plt.imshow(X_recovered.astype(int))</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>图像压缩处理后 ：<br><img src="https://img-blog.csdnimg.cn/20190525182212232.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NoZXJpc2hfeA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> ML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python编译报错TypeError_ &#39;builtin_function_or_method&#39; object is not subscriptable</title>
      <link href="/2019/05/30/python%E7%BC%96%E8%AF%91%E6%8A%A5%E9%94%99TypeError_%20&#39;builtin_function_or_method&#39;%20object%20is%20not%20subscriptable/"/>
      <url>/2019/05/30/python%E7%BC%96%E8%AF%91%E6%8A%A5%E9%94%99TypeError_%20&#39;builtin_function_or_method&#39;%20object%20is%20not%20subscriptable/</url>
      
        <content type="html"><![CDATA[<p>﻿报错代码片段：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">embacked_dict = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> embacked:</span><br><span class="line">    <span class="keyword">if</span> embacked_dict.get[i]:<span class="comment">#此处报错</span></span><br><span class="line">        embacked_dict[i] += <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        embacked_dict[i] = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>此类型错误一般是把函数参数用[ ]传入了，改为()即可</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 编译报错 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>吴恩达《机器学习》——第七次作业：主要成分分析(PCA)</title>
      <link href="/2019/05/25/%E5%90%B4%E6%81%A9%E8%BE%BE%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E2%80%94%E2%80%94%E7%AC%AC%E4%B8%83%E6%AC%A1%E4%BD%9C%E4%B8%9A%EF%BC%9A%E4%B8%BB%E8%A6%81%E6%88%90%E5%88%86%E5%88%86%E6%9E%90(PCA)/"/>
      <url>/2019/05/25/%E5%90%B4%E6%81%A9%E8%BE%BE%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E2%80%94%E2%80%94%E7%AC%AC%E4%B8%83%E6%AC%A1%E4%BD%9C%E4%B8%9A%EF%BC%9A%E4%B8%BB%E8%A6%81%E6%88%90%E5%88%86%E5%88%86%E6%9E%90(PCA)/</url>
      
        <content type="html"><![CDATA[<p>主要成分分析</p><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> scipy.io <span class="keyword">import</span> loadmat</span><br><span class="line"></span><br><span class="line">data = loadmat(<span class="string">'data/ex7data1.mat'</span>)</span><br><span class="line">X = data[<span class="string">'X'</span>]</span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">12</span>, <span class="number">8</span>))</span><br><span class="line">ax.scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>])</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pca</span><span class="params">(X)</span>:</span></span><br><span class="line">    X = (X - X.mean()) / X.std()        <span class="comment">#特征缩放</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">X = np.matrix(X)</span><br><span class="line"></span><br><span class="line">cov = (X.T * X) / X.shape[<span class="number">0</span>]        <span class="comment">#协方差</span></span><br><span class="line"></span><br><span class="line">U, S, V = np.linalg.svd(cov)        <span class="comment">#奇异值分解</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> U, S, V</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">project_data</span><span class="params">(X, U, k)</span>:</span></span><br><span class="line">    U_reduced = U[:, :k]</span><br><span class="line">    <span class="keyword">return</span> np.dot(X, U_reduced)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recover_data</span><span class="params">(Z, U, k)</span>:</span></span><br><span class="line">    U_reduced = U[:, :k]</span><br><span class="line">    <span class="keyword">return</span> np.dot(Z, U_reduced.T)</span><br><span class="line"></span><br><span class="line">U, S, V = pca(X)</span><br><span class="line"></span><br><span class="line">Z = project_data(X, U, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>吴恩达《机器学习》——第四次作业：BP神经网络</title>
      <link href="/2019/05/18/%E5%90%B4%E6%81%A9%E8%BE%BE%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E2%80%94%E2%80%94%E7%AC%AC%E5%9B%9B%E6%AC%A1%E4%BD%9C%E4%B8%9A%EF%BC%9ABP%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
      <url>/2019/05/18/%E5%90%B4%E6%81%A9%E8%BE%BE%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E2%80%94%E2%80%94%E7%AC%AC%E5%9B%9B%E6%AC%A1%E4%BD%9C%E4%B8%9A%EF%BC%9ABP%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<p>本此作业和上次作业的目标一样，属于多元分类任务。不过这次是使用BP神经网络。准确度比没有使用神经网络的第三次作业要高，但是训练的时间也长了很多。<br>参考：<a href="https://github.com/fengdu78/Coursera-ML-AndrewNg-Notes/tree/master/code" target="_blank" rel="noopener">https://github.com/fengdu78/Coursera-ML-AndrewNg-Notes/tree/master/code</a></p><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> scipy.io <span class="keyword">as</span> sio</span><br><span class="line"><span class="keyword">import</span> matplotlib</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> scipy.optimize <span class="keyword">as</span> opt</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> classification_report</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> OneHotEncoder</span><br><span class="line"></span><br><span class="line">data = sio.loadmat(<span class="string">'ex4data1.mat'</span>)</span><br><span class="line">X = data[<span class="string">'X'</span>]</span><br><span class="line">y = data[<span class="string">'y'</span>]</span><br><span class="line"></span><br><span class="line">encoder = OneHotEncoder(sparse=<span class="literal">False</span>)</span><br><span class="line">y_onehot = encoder.fit_transform(y)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sigmoid</span><span class="params">(z)</span>:</span></span><br><span class="line">    <span class="string">'''激活函数'''</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> / (<span class="number">1</span> + np.exp(-z))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">forward_propagate</span><span class="params">(X, theta1, theta2)</span>:</span></span><br><span class="line">    <span class="string">'''前向传播算法'''</span></span><br><span class="line">    m = X.shape[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    a1 = np.insert(X, <span class="number">0</span>, values=np.ones(m), axis=<span class="number">1</span>)</span><br><span class="line">    z2 = a1 * theta1.T</span><br><span class="line">    a2 = sigmoid(z2)</span><br><span class="line">    a2 = np.insert(a2, <span class="number">0</span>, values=np.ones(m), axis=<span class="number">1</span>)</span><br><span class="line">    z3 = a2 * theta2.T</span><br><span class="line">    h = sigmoid(z3)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a1, z2, a2, z3, h</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cost</span><span class="params">(params, input_size, hidden_size, num_labels, X, y, learning_rate)</span>:</span></span><br><span class="line">    <span class="string">'''代价函数'''</span></span><br><span class="line">    m = X.shape[<span class="number">0</span>]</span><br><span class="line">    X = np.matrix(X)</span><br><span class="line">    y = np.matrix(y)</span><br><span class="line"></span><br><span class="line">    theta1 = np.matrix(np.reshape(params[:hidden_size * (input_size + <span class="number">1</span>)], (hidden_size, (input_size + <span class="number">1</span>))))</span><br><span class="line">    theta2 = np.matrix(np.reshape(params[hidden_size * (input_size + <span class="number">1</span>):], (num_labels, (hidden_size + <span class="number">1</span>))))</span><br><span class="line"></span><br><span class="line">    a1, z2, a2, z3, h = forward_propagate(X, theta1, theta2)</span><br><span class="line"></span><br><span class="line">    J = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">        first_term = np.multiply(-y[i, :], np.log(h[i, :]))</span><br><span class="line">        second_term = np.multiply(<span class="number">1</span> - y[i, :], np.log(<span class="number">1</span> - h[i, :]))</span><br><span class="line">        J += np.sum(first_term - second_term)</span><br><span class="line"></span><br><span class="line">    J = J/m</span><br><span class="line"></span><br><span class="line">    J += (float(learning_rate) / (<span class="number">2</span> * m)) * (np.sum(np.power(theta1[:, <span class="number">1</span>:], <span class="number">2</span>)) + np.sum(np.power(theta2[:, <span class="number">1</span>:], <span class="number">2</span>)))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> J</span><br><span class="line">input_size = <span class="number">400</span></span><br><span class="line">hidden_size = <span class="number">25</span></span><br><span class="line">num_labels = <span class="number">10</span></span><br><span class="line">learning_rate = <span class="number">1</span></span><br><span class="line">params = (np.random.random(size=hidden_size * (input_size + <span class="number">1</span>) + num_labels * (hidden_size + <span class="number">1</span>)) - <span class="number">0.5</span>) * <span class="number">0.25</span></span><br><span class="line"><span class="comment">#print(cost(params, input_size, hidden_size, num_labels, X, y_onehot, learning_rate))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sigmoid_gradient</span><span class="params">(z)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> np.multiply(sigmoid(z), (<span class="number">1</span> - sigmoid(z)))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">back_prop</span><span class="params">(params, input_size, hidden_size, num_labels, X, y, learning_rate)</span>:</span></span><br><span class="line">    <span class="string">'''反向传播算法'''</span></span><br><span class="line">    m = X.shape[<span class="number">0</span>]</span><br><span class="line">    X = np.matrix(X)</span><br><span class="line">    y = np.matrix(y)</span><br><span class="line"></span><br><span class="line">    theta1 = np.matrix(np.reshape(params[:hidden_size * (input_size + <span class="number">1</span>)], (hidden_size, (input_size + <span class="number">1</span>))))</span><br><span class="line">    theta2 = np.matrix(np.reshape(params[hidden_size * (input_size + <span class="number">1</span>):], (num_labels, (hidden_size + <span class="number">1</span>))))</span><br><span class="line"></span><br><span class="line">    a1, z2, a2, z3, h = forward_propagate(X, theta1, theta2)</span><br><span class="line"></span><br><span class="line">    J = <span class="number">0</span></span><br><span class="line">    delta1 = np.zeros(theta1.shape)</span><br><span class="line">    delta2 = np.zeros(theta2.shape)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">        first_term = np.multiply(-y[i, :], np.log(h[i, :]))</span><br><span class="line">        second_term = np.multiply(<span class="number">1</span> - y[i, :], np.log(<span class="number">1</span> - h[i, :]))</span><br><span class="line">        J += np.sum(first_term - second_term)</span><br><span class="line"></span><br><span class="line">    J = J / m</span><br><span class="line"></span><br><span class="line">    J += (float(learning_rate) / (<span class="number">2</span> * m)) * (np.sum(np.power(theta1[:, <span class="number">1</span>:], <span class="number">2</span>)) + np.sum(np.power(theta2[:, <span class="number">1</span>:], <span class="number">2</span>)))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> range(m):</span><br><span class="line">        a1t = a1[t, :]</span><br><span class="line">        z2t = z2[t, :]</span><br><span class="line">        a2t = a2[t, :]</span><br><span class="line">        ht = h[t, :]</span><br><span class="line">        yt = y[t, :]</span><br><span class="line"></span><br><span class="line">        d3t = ht - yt</span><br><span class="line">        z2t = np.insert(z2t, <span class="number">0</span>, values=np.ones(<span class="number">1</span>))</span><br><span class="line">        d2t = np.multiply((theta2.T * d3t.T).T, sigmoid_gradient(z2t))</span><br><span class="line"></span><br><span class="line">        delta1 = delta1 + (d2t[:, <span class="number">1</span>:]).T * a1t</span><br><span class="line">        delta2 = delta2 + d3t.T * a2t</span><br><span class="line"></span><br><span class="line">    delta1 /= m</span><br><span class="line">    delta2 /= m</span><br><span class="line"></span><br><span class="line">    delta1[:, <span class="number">1</span>:] = delta1[:, <span class="number">1</span>:] + (theta1[:, <span class="number">1</span>:] * learning_rate) / m</span><br><span class="line">    delta2[:, <span class="number">1</span>:] = delta2[:, <span class="number">1</span>:] + (theta2[:, <span class="number">1</span>:] * learning_rate) / m</span><br><span class="line"></span><br><span class="line">    grad = np.concatenate((np.ravel(delta1), np.ravel(delta2)))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> J, grad</span><br><span class="line"></span><br><span class="line">fmin = opt.minimize(fun=back_prop, x0=params, args=(input_size, hidden_size, num_labels, X, y_onehot, learning_rate),</span><br><span class="line">                    method=<span class="string">'TNC'</span>, jac=<span class="literal">True</span>, options=&#123;<span class="string">'maxiter'</span>: <span class="number">250</span>&#125;)</span><br><span class="line"></span><br><span class="line">X = np.matrix(X)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">X = np.matrix(X)</span><br><span class="line">theta1 = np.matrix(np.reshape(fmin.x[:hidden_size * (input_size + <span class="number">1</span>)], (hidden_size, (input_size + <span class="number">1</span>))))</span><br><span class="line">theta2 = np.matrix(np.reshape(fmin.x[hidden_size * (input_size + <span class="number">1</span>):], (num_labels, (hidden_size + <span class="number">1</span>))))</span><br><span class="line"></span><br><span class="line">a1, z2, a2, z3, h = forward_propagate(X, theta1, theta2)</span><br><span class="line">y_pred = np.array(np.argmax(h, axis=<span class="number">1</span>) + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#准确度</span></span><br><span class="line">print(classification_report(y, y_pred))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>吴恩达《机器学习》——第三次作业：多元分类</title>
      <link href="/2019/05/18/%E5%90%B4%E6%81%A9%E8%BE%BE%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E2%80%94%E2%80%94%E7%AC%AC%E4%B8%89%E6%AC%A1%E4%BD%9C%E4%B8%9A%EF%BC%9A%E5%A4%9A%E5%85%83%E5%88%86%E7%B1%BB/"/>
      <url>/2019/05/18/%E5%90%B4%E6%81%A9%E8%BE%BE%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E2%80%94%E2%80%94%E7%AC%AC%E4%B8%89%E6%AC%A1%E4%BD%9C%E4%B8%9A%EF%BC%9A%E5%A4%9A%E5%85%83%E5%88%86%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<p>写了好长时间的驼峰命名，最近有点恶心了，决定python用下划线，C++用驼峰。<br>这次作业是对手写数字的数据集进行训练。多元分类的一个任务。</p><p>参考：<a href="https://github.com/fengdu78/Coursera-ML-AndrewNg-Notes/tree/master/code" target="_blank" rel="noopener">https://github.com/fengdu78/Coursera-ML-AndrewNg-Notes/tree/master/code</a></p><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> scipy.io <span class="keyword">as</span> sio</span><br><span class="line"><span class="keyword">import</span> matplotlib</span><br><span class="line"><span class="keyword">import</span> scipy.optimize <span class="keyword">as</span> opt</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> classification_report</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_data</span><span class="params">(path, transpose=True)</span>:</span></span><br><span class="line">    <span class="string">'''载入数据'''</span></span><br><span class="line">    data = sio.loadmat(path)</span><br><span class="line">    y = data.get(<span class="string">'y'</span>)</span><br><span class="line"></span><br><span class="line">    y = y.reshape(y.shape[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    X = data.get(<span class="string">'X'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> transpose:</span><br><span class="line">        X = np.array([im.reshape((<span class="number">20</span>, <span class="number">20</span>)).T <span class="keyword">for</span> im <span class="keyword">in</span> X])</span><br><span class="line"></span><br><span class="line">        X = np.array([im.reshape(<span class="number">400</span>) <span class="keyword">for</span> im <span class="keyword">in</span> X])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> X, y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">raw_X, raw_y = load_data(<span class="string">'ex3data1.mat'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#def plot_image(image):</span></span><br><span class="line"><span class="comment">#    '''随机显示一张图片'''</span></span><br><span class="line"><span class="comment">#    fig, ax = plt.subplots(figsize=(1, 1))</span></span><br><span class="line"><span class="comment">#    ax.matshow(image.reshape((20, 20)), cmap=matplotlib.cm.binary)</span></span><br><span class="line"><span class="comment">#    plt.xticks(np.array([]))</span></span><br><span class="line"><span class="comment">#    plt.yticks(np.array([]))</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#pick_one = np.random.randint(0, 5000)              #在(0,5000)氛围内随机取一个数</span></span><br><span class="line"><span class="comment">#plot_image(X[pick_one, :])</span></span><br><span class="line"><span class="comment">#plt.show()</span></span><br><span class="line"><span class="comment">#print("this should be &#123;&#125;".format(y[pick_one]))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#def plot_100_image(X):</span></span><br><span class="line"><span class="comment">#    '''显示100张图片'''</span></span><br><span class="line"><span class="comment">#    size = int(np.sqrt(X.shape[1]))</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#    sample_idx = np.random.choice(np.arange(X.shape[0]), 100)</span></span><br><span class="line"><span class="comment">#    sample_images = X[sample_idx, :]</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#    fig, ax_array = plt.subplots(nrows=10, ncols=10, sharey=True, sharex=True, figsize=(8, 8))</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#    for r in range(10):</span></span><br><span class="line"><span class="comment">#        for c in range(10):</span></span><br><span class="line"><span class="comment">#            ax_array[r, c].matshow(sample_images[10 * r + c].reshape((size, size)),</span></span><br><span class="line"><span class="comment">#                                   cmap=matplotlib.cm.binary)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#            plt.xticks(np.array([]))</span></span><br><span class="line"><span class="comment">#            plt.yticks(np.array([]))</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#准备数据</span></span><br><span class="line">X = np.insert(raw_X, <span class="number">0</span>, values=np.ones(raw_X.shape[<span class="number">0</span>]), axis=<span class="number">1</span>)     <span class="comment">#插入第一列，全部为1</span></span><br><span class="line"></span><br><span class="line">y_matrix = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>):</span><br><span class="line">    y_matrix.append((raw_y == k).astype(int))</span><br><span class="line"></span><br><span class="line">y_matrix = [y_matrix[<span class="number">-1</span>]] + y_matrix[:<span class="number">-1</span>]</span><br><span class="line">y = np.array(y_matrix)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#print(y.shape)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#训练一维模型</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sigmoid</span><span class="params">(z)</span>:</span></span><br><span class="line">    <span class="string">'''激活函数'''</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> / (<span class="number">1</span> + np.exp(-z))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gradient</span><span class="params">(theta, X, y)</span>:</span></span><br><span class="line">    <span class="string">'''一次梯度下降'''</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1</span> / len(X)) * X.T @ (sigmoid(X@theta) - y)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cost</span><span class="params">(theta, X, y)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="string">'''代价函数'''</span></span><br><span class="line">    h = sigmoid(X@theta)</span><br><span class="line">    inner = y.T * np.log(h) + (<span class="number">1</span>-y).T*np.log(<span class="number">1</span>-h)</span><br><span class="line">    <span class="keyword">return</span> - (np.sum(inner)/len(X))</span><br><span class="line">    <span class="comment">#return np.mean(-y * np.log(sigmoid(X*theta.T)) - (1-y)*np.log(1-sigmoid(X*theta.T)))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">regularized_cost</span><span class="params">(theta, X, y, l=<span class="number">1</span>)</span>:</span></span><br><span class="line">    <span class="string">'''正则化'''</span></span><br><span class="line">    theta_j1_to_n = theta[<span class="number">1</span>:]</span><br><span class="line">    regularized_term = (<span class="number">1</span> / (<span class="number">2</span> * len(X))) * np.power(theta_j1_to_n, <span class="number">2</span>).sum()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cost(theta, X, y) + regularized_term</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">regularized_gradient</span><span class="params">(theta, X, y, l=<span class="number">1</span>)</span>:</span></span><br><span class="line"></span><br><span class="line">    theta_j1_to_n = theta[:<span class="number">-1</span>]</span><br><span class="line">    regularized_theta = (l / len(X)) * theta_j1_to_n</span><br><span class="line"></span><br><span class="line">    regularized_term = np.concatenate([np.array([<span class="number">0</span>]), regularized_theta])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> gradient(theta, X, y) + regularized_term</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logistic_regression</span><span class="params">(X, y, l=<span class="number">1</span>)</span>:</span></span><br><span class="line"></span><br><span class="line">    theta = np.zeros(X.shape[<span class="number">1</span>])</span><br><span class="line">    res = opt.minimize(fun=regularized_cost,</span><br><span class="line">                       x0=theta,</span><br><span class="line">                       args=(X, y, l),</span><br><span class="line">                       method=<span class="string">'TNC'</span>,</span><br><span class="line">                       jac=regularized_gradient,</span><br><span class="line">                       options=&#123;<span class="string">'disp'</span>: <span class="literal">True</span>&#125;)</span><br><span class="line"></span><br><span class="line">    final_theta = res.x</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> final_theta</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(x, theta)</span>:</span></span><br><span class="line">    <span class="string">'''预测函数'''</span></span><br><span class="line">    prob = sigmoid(X @ theta)</span><br><span class="line">    <span class="keyword">return</span> (prob &gt;= <span class="number">0.5</span>).astype(int)</span><br><span class="line"></span><br><span class="line">t0 = logistic_regression(X, y[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#print(t0.shape)</span></span><br><span class="line"><span class="comment">#y_pred = predict(X, t0)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#print('Accuracy = &#123;&#125;'.format(np.mean(y[0] == y_pred)))</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#训练k维模型</span></span><br><span class="line"></span><br><span class="line">k_theta = np.array([logistic_regression(X, y[k]) <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">10</span>)])</span><br><span class="line"><span class="comment">#print(k_theta.shape)</span></span><br><span class="line"></span><br><span class="line">prob_matrix = sigmoid(X@k_theta.T)</span><br><span class="line">np.set_printoptions(suppress=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">y_pred = np.argmax(prob_matrix, axis=<span class="number">1</span>)</span><br><span class="line"><span class="comment">#返回沿轴axis最大值的索引，axis=1代表行</span></span><br><span class="line"></span><br><span class="line">y_answer = raw_y.copy()</span><br><span class="line">y_answer[y_answer == <span class="number">10</span>] = <span class="number">0</span></span><br><span class="line">print(classification_report(y_answer, y_pred))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用神经网络实现异或运算</title>
      <link href="/2019/05/14/%E7%94%A8%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97/"/>
      <url>/2019/05/14/%E7%94%A8%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<p><img src="https://img-blog.csdnimg.cn/20190514155909150.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NoZXJpc2hfeA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logistic</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sigmoid</span><span class="params">(self, z)</span>:</span></span><br><span class="line">        <span class="string">'''激活函数'''</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> / (<span class="number">1</span> + np.exp(-z))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">logistic</span><span class="params">(self, X, theta)</span>:</span></span><br><span class="line">        <span class="string">'''一层神经网络进行简单的逻辑运算'''</span></span><br><span class="line">        h = self.sigmoid(X*theta.T)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(int(h.shape[<span class="number">1</span>])):</span><br><span class="line">            h[<span class="number">0</span>, i] = <span class="number">1</span> <span class="keyword">if</span> h[<span class="number">0</span>, i] &gt;= <span class="number">0.5</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> h</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">X = np.matrix(np.array([<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]))</span><br><span class="line">theta1 = np.matrix([[<span class="number">-30</span>, <span class="number">20</span>, <span class="number">20</span>], [<span class="number">10</span>, <span class="number">-20</span>, <span class="number">-20</span>]])     <span class="comment">#第一层网络的权重</span></span><br><span class="line">theta2 = np.matrix([<span class="number">-10</span>, <span class="number">20</span>, <span class="number">-20</span>])                      <span class="comment">#第二层网络的权重</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">log = Logistic()       <span class="comment">#实例化</span></span><br><span class="line"></span><br><span class="line">a1 = log.logistic(X, theta1)         <span class="comment">#第一层</span></span><br><span class="line">a1 = np.c_[<span class="number">1</span>, a1]                    <span class="comment">#添加偏置单元</span></span><br><span class="line">a2 = log.logistic(a1, theta2)        <span class="comment">#第二层</span></span><br><span class="line">print(a2)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ML </tag>
            
            <tag> 神经网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识动态规划</title>
      <link href="/2019/05/14/%E5%88%9D%E8%AF%86%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>/2019/05/14/%E5%88%9D%E8%AF%86%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<p>﻿<a href="https://mp.weixin.qq.com/s/3h9iqU4rdH3EIy5m6AzXsg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/3h9iqU4rdH3EIy5m6AzXsg</a><br>很可爱的漫画。讲的不错，通俗易懂。mark以下，这里就只记一些概念性问题。<br>动态规划的英文名Dynamic Programming，是一种分阶段求解决问题的数学思想。它不止应用于编程领域，也应用于管理学、经济学、生物学。</p><a id="more"></a><p>它的思想是：<strong>大事化小，小事化了</strong><br>动态规划当中包含三个重要的概念：<strong>最优子结构</strong>，<strong>边界</strong>，<strong>状态转移公式</strong><br>通过下面漫画提到的题目对三个概念阐述。<br><img src="https://img-blog.csdnimg.cn/20190514100652421.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NoZXJpc2hfeA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">    在最后一级台阶，由2种走法，第一种：从第九级台阶跨一步到达第十级台阶；第二种：从第八级台阶跨2步到达第十级台阶。那是不是说，到达第十级台阶的走法有多少种，是由到达第八级台阶和到底第九级台阶的走法之和决定的呢？<br>当然是的。<br>因此，可以以此类推，直到第一级台阶或者第二级台阶。<br>用公式简化过程：<br>f(n)表示到达第n级台阶的走法，由上面分析，有<br>f(10) = f(9) + f(8)<br>f(9) = f(8) + f(7)<br>。。。<br>f(3) = f(2) + f(1)<br>归纳：<br>f(1) = 1<br>f(2) = 2<br>f(n) = f(n-1) + f(n-2)  (n&gt;=3)<br>刚才分析出f(10) = f(9) + f(8)，因此f(9)和f(8)是f(10)的<strong>最优子结构</strong><br>当只用一级台阶或2级台阶的时候，我们可以直接得出结果，无需继续简化。我们成f(1)和f(2)为问题<strong>边界</strong>。如果一个问题没有边界，将永远无法得到有限的结果。<br>f(n) = f(n-1) + f(n-2)是阶段与阶段之间的<strong>状态转移方程</strong>。这是动态规划的核心，决定了问题的每一个阶段和下一个阶段的关系。<br>其实分析到这里后，和漫画里的小灰一样，我的第一反应也是用递归做，毕竟递归方程和边界都给出了。<br>下面给出递归的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dp</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">elif</span> n == <span class="number">1</span> <span class="keyword">or</span> n == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> dp(n<span class="number">-1</span>) + dp(n<span class="number">-2</span>)</span><br></pre></td></tr></table></figure><p>但是递归的时间复杂度有点高。<img src="https://img-blog.csdnimg.cn/20190514103043450.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NoZXJpc2hfeA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>差不多应该是O(2^n)。<br>从上图可以看出有些数据被重复计算了，那么我们可将这些数据缓存下来。<br>下面用<strong>备忘录算法</strong>优化一下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">hashMap = &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dp</span><span class="params">(n, hashMap)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span> <span class="keyword">or</span> n == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    <span class="keyword">elif</span> n <span class="keyword">in</span> hashMap:</span><br><span class="line">        <span class="keyword">return</span> hashMap[n]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        hashMap[n] = dp(n<span class="number">-1</span>, hashMap) + dp(n<span class="number">-2</span>, hashMap)</span><br><span class="line">        <span class="keyword">return</span> hashMap[n]</span><br></pre></td></tr></table></figure><p>这样时间复杂度就降到了O(n)，但是空间复杂度也就变成了O(n)。<br>上面的两种实现方法都是自顶向下递归实现的，因此也就无法利用之前计算的结果。因为本题归纳的公式，我们可以看出如果自低向上迭代运算，在下一次运算可以用到上次运算的结果。每一次迭代过程中，只要保留之前的两个状态，就可以推导出新的状态。这就是动态规划。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dp</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">elif</span> n == <span class="number">1</span> <span class="keyword">or</span> n == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    f1, f2 = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>, n+<span class="number">1</span>):</span><br><span class="line">        f1, f2 = f2, f1 + f2</span><br><span class="line">    <span class="keyword">return</span> f2</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>吴恩达《机器学习》第二次作业——逻辑回归</title>
      <link href="/2019/05/10/%E5%90%B4%E6%81%A9%E8%BE%BE%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E7%AC%AC%E4%BA%8C%E6%AC%A1%E4%BD%9C%E4%B8%9A%E2%80%94%E2%80%94%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/"/>
      <url>/2019/05/10/%E5%90%B4%E6%81%A9%E8%BE%BE%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E7%AC%AC%E4%BA%8C%E6%AC%A1%E4%BD%9C%E4%B8%9A%E2%80%94%E2%80%94%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/</url>
      
        <content type="html"><![CDATA[<p>  ﻿ 1. 逻辑回归<br>       给的数据集有两个特征变量。<br>            设想你是大学相关部分的管理者，想通过申请学生两次测试的评分，来决定他们是否被录取。现在你拥有之前申请学生的可以用于训练逻辑回归的训练样本集。对于每一个训练样本，你有他们两次测试的评分和最后是被录取的结果。由此建立逻辑回归分类器。</p><p>注： <a href="https://github.com/fengdu78/Coursera-ML-AndrewNg-Notes/tree/master/code" target="_blank" rel="noopener">https://github.com/fengdu78/Coursera-ML-AndrewNg-Notes/tree/master/code</a><br>github上并没有使用梯度下降来优化参数，应该是使用的是其他的优化算法（SciPy’s truncated newton（TNC））。</p><a id="more"></a><p>用梯度下降法优化参数，并不能很好的降低代价函数，相比于其他优化算法。可能是对于这个数据集来说，需要迭代相当多的次数。<br><img src="https://img-blog.csdnimg.cn/20190510104710116.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NoZXJpc2hfeA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> scipy.optimize <span class="keyword">as</span> opt</span><br><span class="line"></span><br><span class="line">path = <span class="string">'ex2data1.txt'</span>   <span class="comment">#相对路径</span></span><br><span class="line">data = pd.read_csv(path, header=<span class="literal">None</span>, names=[<span class="string">'First'</span>, <span class="string">'Second'</span>, <span class="string">'Admission'</span>])</span><br><span class="line"></span><br><span class="line"><span class="string">'''观察数据'''</span></span><br><span class="line"><span class="comment">#positive = data[data['Admission'].isin([1])]</span></span><br><span class="line"><span class="comment">#negative = data[data['Admission'].isin([0])]</span></span><br><span class="line"><span class="comment">#fig, ax = plt.subplots(figsize=(12, 8))</span></span><br><span class="line"><span class="comment">#ax.scatter(positive['First'], positive['Second'], s=50, c='b', marker='o', label='Admission')</span></span><br><span class="line"><span class="comment">#ax.scatter(negative['First'], negative['Second'], s=50, c='r', marker='x', label='Not Admission')</span></span><br><span class="line"><span class="comment">#ax.legend()</span></span><br><span class="line"><span class="comment">#ax.set_xlabel('First Score')</span></span><br><span class="line"><span class="comment">#ax.set_ylabel('Second Score')</span></span><br><span class="line"><span class="comment">#plt.show()</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">'''操作数据，以便后续处理'''</span></span><br><span class="line"><span class="comment">#data['First'] = (data['First'] - data['First'].mean())/data['First'].std()</span></span><br><span class="line"><span class="comment">#data['Second'] = (data['Second'] - data['Second'.mean()])/data['Second'].std()  #特征缩放，</span></span><br><span class="line"></span><br><span class="line">data.insert(<span class="number">0</span>, <span class="string">'Ones'</span>, <span class="number">1</span>)</span><br><span class="line">cols = data.shape[<span class="number">1</span>]                <span class="comment">#data的列数</span></span><br><span class="line">X = data.iloc[:, <span class="number">0</span>:cols<span class="number">-1</span>]          <span class="comment">#特征变量</span></span><br><span class="line">y = data.iloc[:, cols<span class="number">-1</span>:cols]       <span class="comment">#目标变量</span></span><br><span class="line">X = np.matrix(X.values)             <span class="comment">#转为矩阵</span></span><br><span class="line">y = np.matrix(y.values)</span><br><span class="line">theta = np.matrix(np.array([<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(X.shape[<span class="number">1</span>])]))         <span class="comment">#初始化θ的值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sigmoid</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="string">'''sigmoid函数'''</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> / (<span class="number">1</span> + np.exp(-x))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">computeCost</span><span class="params">(X, y, theta)</span>:</span></span><br><span class="line">    <span class="string">'''代价函数'''</span></span><br><span class="line">    h = sigmoid(X * theta.T)</span><br><span class="line">    inner = y.T*np.log(h) + (<span class="number">1</span>-y).T*np.log(<span class="number">1</span>-h)</span><br><span class="line">    <span class="keyword">return</span> -(np.sum(inner)/X.shape[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">alpha = <span class="number">0.001</span></span><br><span class="line">iters = <span class="number">150000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gradienDescent</span><span class="params">(X, y, theta, alpha, iters)</span>:</span></span><br><span class="line">    cost = np.zeros(iters)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(iters):</span><br><span class="line">        h = sigmoid(X * theta.T) - y</span><br><span class="line">        innre = X.T * h</span><br><span class="line">        theta = theta - (alpha/len(X)) * innre.T</span><br><span class="line">        cost[i] = computeCost(X, y, theta)</span><br><span class="line">    <span class="keyword">return</span> theta, cost</span><br><span class="line"></span><br><span class="line">theta, cost = gradienDescent(X, y, theta, alpha, iters)</span><br><span class="line"><span class="comment">#print(cost[-1])</span></span><br><span class="line"></span><br><span class="line"><span class="string">'''观察代价函数的迭代'''</span></span><br><span class="line"><span class="comment">#fig, ax = plt.subplots(figsize=(12, 8))</span></span><br><span class="line"><span class="comment">#ax.plot(np.arange(iters), cost, 'r')</span></span><br><span class="line"><span class="comment">#ax.set_xlabel('Iterations')</span></span><br><span class="line"><span class="comment">#ax.set_ylabel('Cost')</span></span><br><span class="line"><span class="comment">#ax.set_title('Error vs. Ttainging Epoch')</span></span><br><span class="line"><span class="comment">#plt.show()</span></span><br><span class="line"></span><br><span class="line"><span class="string">'''检测逻辑回归分类器的精度'''</span></span><br><span class="line">probability = sigmoid(X * theta.T)</span><br><span class="line">predictions = [<span class="number">1</span> <span class="keyword">if</span> x &gt;= <span class="number">0.5</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">for</span> x <span class="keyword">in</span> probability]</span><br><span class="line">correct = [<span class="number">1</span> <span class="keyword">if</span> ((a == <span class="number">1</span> <span class="keyword">and</span> b == <span class="number">1</span>) <span class="keyword">or</span> (a == <span class="number">0</span> <span class="keyword">and</span> b == <span class="number">0</span>)) <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">for</span> (a, b) <span class="keyword">in</span> zip(predictions, y)]</span><br><span class="line">accuracy = (sum(map(int, correct)) % len(correct))</span><br><span class="line">print(<span class="string">'accuracy = &#123;0&#125;%'</span>.format(accuracy))</span><br></pre></td></tr></table></figure><ul><li>逻辑回归的正则化</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> scipy.optimize <span class="keyword">as</span> opt</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">path = <span class="string">'ex2data2.txt'</span></span><br><span class="line"></span><br><span class="line">data2 = pd.read_csv(path, header=<span class="literal">None</span>, names=[<span class="string">'Test1'</span>, <span class="string">'Test2'</span>, <span class="string">'Accepted'</span>])</span><br><span class="line"></span><br><span class="line">degree = <span class="number">5</span></span><br><span class="line">x1 = data2[<span class="string">'Test1'</span>]</span><br><span class="line">x2 = data2[<span class="string">'Test2'</span>]</span><br><span class="line"></span><br><span class="line">data2.insert(<span class="number">3</span>, <span class="string">'Ones'</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, degree):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(i):</span><br><span class="line">        data2[<span class="string">'F'</span> + str(i) + str(j)] = np.power(x1, i- j) * np.power(x2, j)</span><br><span class="line"></span><br><span class="line">data2.drop(<span class="string">'Test1'</span>, axis=<span class="number">1</span>, inplace=<span class="literal">True</span>)</span><br><span class="line">data2.drop(<span class="string">'Test2'</span>, axis=<span class="number">1</span>, inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sigmoid</span><span class="params">(z)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> / (<span class="number">1</span> + np.exp(-z))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cost</span><span class="params">(theta, X, y, learningRate)</span>:</span></span><br><span class="line">    theta = np.matrix(theta)</span><br><span class="line">    X = np.matrix(X)</span><br><span class="line">    y = np.matrix(y)</span><br><span class="line">    first = np.multiply(-y, np.log(sigmoid(X * theta.T)))</span><br><span class="line">    second = np.multiply((<span class="number">1</span> - y), np.log(<span class="number">1</span> - sigmoid(X * theta.T)))</span><br><span class="line">    reg = (learningRate / (<span class="number">2</span> * len(X))) * np.sum(np.power(theta[:,<span class="number">1</span>:theta.shape[<span class="number">1</span>]], <span class="number">2</span>))</span><br><span class="line">    <span class="keyword">return</span> np.sum(first - second) / len(X) + reg</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gradientReg</span><span class="params">(theta, X, y, learningRate)</span>:</span></span><br><span class="line">    theta = np.matrix(theta)</span><br><span class="line">    X = np.matrix(X)</span><br><span class="line">    y = np.matrix(y)</span><br><span class="line"></span><br><span class="line">    parameters = int(theta.ravel().shape[<span class="number">1</span>])</span><br><span class="line">    grad = np.zeros(parameters)</span><br><span class="line"></span><br><span class="line">    error = sigmoid(X * theta.T) - y</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(parameters):</span><br><span class="line">        term = np.multiply(error, X[:, i])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>):</span><br><span class="line">            grad[i] = np.sum(term) / len(X)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            grad[i] = (np.sum(term) / len(X)) + ((learningRate / len(X)) * theta[:, i])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> grad</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># set X and y (remember from above that we moved the label to column 0)</span></span><br><span class="line">cols = data2.shape[<span class="number">1</span>]</span><br><span class="line">X2 = data2.iloc[:,<span class="number">1</span>:cols]</span><br><span class="line">y2 = data2.iloc[:,<span class="number">0</span>:<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># convert to numpy arrays and initalize the parameter array theta</span></span><br><span class="line">X2 = np.array(X2.values)</span><br><span class="line">y2 = np.array(y2.values)</span><br><span class="line">theta2 = np.zeros(<span class="number">11</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">learningRate = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">result2 = opt.fmin_tnc(func=cost, x0=theta2, fprime=gradientReg, args=(X2, y2, learningRate))</span><br><span class="line"></span><br><span class="line">theta = np.matrix(result2[<span class="number">0</span>])</span><br><span class="line">probability = sigmoid(X2 * theta.T)</span><br><span class="line">predictions = [<span class="number">1</span> <span class="keyword">if</span> x &gt;= <span class="number">0.5</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">for</span> x <span class="keyword">in</span> probability]</span><br><span class="line">correct = [<span class="number">1</span> <span class="keyword">if</span> ((a == <span class="number">1</span> <span class="keyword">and</span> b == <span class="number">1</span>) <span class="keyword">or</span> (a == <span class="number">0</span> <span class="keyword">and</span> b == <span class="number">0</span>)) <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">for</span> (a, b) <span class="keyword">in</span> zip(predictions, y2)]</span><br><span class="line">accuracy = (sum(map(int, correct)) % len(correct))</span><br><span class="line">print(<span class="string">'accuracy = &#123;0&#125;%'</span>.format(accuracy))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VS2017生成的.exe文件无法在其他电脑上运行的解决方法</title>
      <link href="/2019/05/02/VS2017%E7%94%9F%E6%88%90%E7%9A%84.exe%E6%96%87%E4%BB%B6%E6%97%A0%E6%B3%95%E5%9C%A8%E5%85%B6%E5%AE%83%E7%94%B5%E8%84%91%E4%B8%8A%E8%BF%90%E8%A1%8C%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
      <url>/2019/05/02/VS2017%E7%94%9F%E6%88%90%E7%9A%84.exe%E6%96%87%E4%BB%B6%E6%97%A0%E6%B3%95%E5%9C%A8%E5%85%B6%E5%AE%83%E7%94%B5%E8%84%91%E4%B8%8A%E8%BF%90%E8%A1%8C%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<ol><li><p>项目-&gt;属性–&gt;配置属性–&gt;常规–&gt;MFC的使用。<br>  将其改为在静态库中使用MFC。然后重新编译。</p><ol start="2"><li><p>具体过程如下图</p><a id="more"></a></li></ol></li></ol><p>以本工程为例。<br>在<strong>项目</strong>里面选择<strong>test521属性</strong>。<br><img src="https://img-blog.csdnimg.cn/20190502210356274.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NoZXJpc2hfeA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">将<strong>常规</strong>里的<strong>MFC的使用</strong>更改为<strong>在静态库中使用MFC</strong><br><img src="https://img-blog.csdnimg.cn/20190502210714214.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NoZXJpc2hfeA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>最后重新编译生成即可。</p>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vs2017 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>各种排序算法的python实现</title>
      <link href="/2019/04/28/%E5%90%84%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84python%E5%AE%9E%E7%8E%B0/"/>
      <url>/2019/04/28/%E5%90%84%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84python%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>﻿ - 冒泡排序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sortBubble</span><span class="params">(array)</span>:</span></span><br><span class="line">    <span class="string">'''冒泡排序'''</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(len(array)):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(array)<span class="number">-1</span>-j):</span><br><span class="line">            <span class="keyword">if</span> array[i] &gt; array[i+<span class="number">1</span>]:</span><br><span class="line">                array[i], array[i+<span class="number">1</span>] = array[i+<span class="number">1</span>], array[i]</span><br><span class="line"></span><br><span class="line">A = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">23</span>,<span class="number">12</span>,<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">sortBubble(A)</span><br><span class="line">print(A)</span><br></pre></td></tr></table></figure><a id="more"></a><p>结果：<br><img src="https://img-blog.csdnimg.cn/2019042820195042.png" alt="冒泡排序"></p><ul><li>选择排序</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sortSelection</span><span class="params">(array)</span>:</span></span><br><span class="line">    <span class="string">'''冒泡排序'''</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(len(array)):</span><br><span class="line">        min = array[j]</span><br><span class="line">        k = j</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(j, len(array)):</span><br><span class="line">            <span class="keyword">if</span> array[i] &lt; min:</span><br><span class="line">                min = array[i]</span><br><span class="line">                k = i</span><br><span class="line">        array[k], array[j] = array[j], array[k]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">list = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">32</span>, <span class="number">1</span>]</span><br><span class="line">sortSelection(list)</span><br><span class="line">print(list)</span><br></pre></td></tr></table></figure><p>结果<br><img src="https://img-blog.csdnimg.cn/20190506161309466.png" alt="选择排序"></p><ul><li>快速排序</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">qsort</span><span class="params">(list)</span>:</span></span><br><span class="line">    <span class="string">'''快速排序'''</span></span><br><span class="line">    <span class="keyword">if</span> len(list) &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> list</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        mid = list[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">del</span> list[<span class="number">0</span>]</span><br><span class="line">        right, left = [], []</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> list:</span><br><span class="line">            <span class="keyword">if</span> x &gt;= mid:</span><br><span class="line">                right.append(x)</span><br><span class="line">            <span class="keyword">elif</span> x &lt; mid:</span><br><span class="line">                left.append(x)</span><br><span class="line">        <span class="keyword">return</span> qsort(left) + [mid] + qsort(right)</span><br><span class="line"></span><br><span class="line">num = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>]</span><br><span class="line">print(qsort(num))</span><br></pre></td></tr></table></figure><p>结果<br><img src="https://img-blog.csdnimg.cn/20190507211305725.png" alt="快速排序"></p><ul><li>直接插入排序</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_sort</span><span class="params">(array)</span>:</span></span><br><span class="line">    <span class="string">'''直接插入排序'''</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(array)):</span><br><span class="line">        temp = array[i]</span><br><span class="line">        j = i - <span class="number">1</span></span><br><span class="line">        print(array)</span><br><span class="line">        <span class="keyword">while</span> j &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> temp &lt; array[j]:</span><br><span class="line">                array[j+<span class="number">1</span>] = array[j]</span><br><span class="line">                j = j - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                array[j+<span class="number">1</span>] = temp</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        array[j + <span class="number">1</span>] = temp</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">array = [<span class="number">2</span>, <span class="number">1</span>,<span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>,<span class="number">5</span>]</span><br><span class="line">insert_sort(array)</span><br></pre></td></tr></table></figure><p>结果<br><img src="https://img-blog.csdnimg.cn/20190520202814260.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NoZXJpc2hfeA==,size_16,color_FFFFFF,t_70" alt="直接插入排序"></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>吴恩达《机器学习》第一次作业——多变量线性回归</title>
      <link href="/2019/04/27/%E5%90%B4%E6%81%A9%E8%BE%BE%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BD%9C%E4%B8%9A%E2%80%94%E2%80%94%E5%A4%9A%E5%8F%98%E9%87%8F%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"/>
      <url>/2019/04/27/%E5%90%B4%E6%81%A9%E8%BE%BE%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BD%9C%E4%B8%9A%E2%80%94%E2%80%94%E5%A4%9A%E5%8F%98%E9%87%8F%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/</url>
      
        <content type="html"><![CDATA[<p>﻿看这里 <a href="https://github.com/fengdu78/Coursera-ML-AndrewNg-Notes/tree/master/code" target="_blank" rel="noopener">https://github.com/fengdu78/Coursera-ML-AndrewNg-Notes/tree/master/code</a><br>这是一位大神整理的作业代码。我也就是照葫芦画瓢，慢慢来吧。</p><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">path = <span class="string">'ex1data2.txt'</span>   <span class="comment">#相对路径</span></span><br><span class="line">data = pd.read_csv(path, header=<span class="literal">None</span>, names=[<span class="string">'Size'</span>, <span class="string">'Bedrooms'</span>, <span class="string">'Price'</span>])</span><br><span class="line"></span><br><span class="line"><span class="string">'''记录目标变量的均值和和差值'''</span></span><br><span class="line">meanPrice = data[<span class="string">'Price'</span>].mean()</span><br><span class="line">stdPrice = data[<span class="string">'Price'</span>].std()</span><br><span class="line"></span><br><span class="line"><span class="string">'''操作数据，以便后续处理'''</span></span><br><span class="line">data = (data-data.mean())/data.std()        <span class="comment">#特征缩放</span></span><br><span class="line">data.insert(<span class="number">0</span>, <span class="string">'Ones'</span>, <span class="number">1</span>)</span><br><span class="line">cols = data.shape[<span class="number">1</span>]</span><br><span class="line">X = data.iloc[:, <span class="number">0</span>:cols<span class="number">-1</span>]</span><br><span class="line">y = data.iloc[:, cols<span class="number">-1</span>:cols]</span><br><span class="line">X = np.matrix(X.values)     <span class="comment">#特征变量</span></span><br><span class="line">y = np.matrix(y.values)     <span class="comment">#目标变量</span></span><br><span class="line">theta = np.matrix(np.array([<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]))</span><br><span class="line"><span class="comment">#————————————————————————————————————————————————————</span></span><br><span class="line"><span class="comment">#cost function</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">computeCost</span><span class="params">(X, y, theta)</span>:</span></span><br><span class="line">    <span class="string">'''损失函数'''</span></span><br><span class="line">    inner = np.power((X*theta.T - y), <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> np.sum(inner) / (<span class="number">2</span> * len(X))</span><br><span class="line"></span><br><span class="line">alpha = <span class="number">0.01</span></span><br><span class="line">iters = <span class="number">1000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gradientDescent</span><span class="params">(X, y, theta, alpha, iters)</span>:</span></span><br><span class="line">    <span class="string">'''梯度下降算法'''</span></span><br><span class="line">    temp = np.matrix(np.zeros(theta.shape))</span><br><span class="line">    cost = np.zeros(iters)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(iters):</span><br><span class="line">        inner = X * theta.T - y</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(temp.shape[<span class="number">1</span>]):</span><br><span class="line">            term = np.multiply(inner, X[:, j])</span><br><span class="line">            temp[<span class="number">0</span>, j] = theta[<span class="number">0</span>, j] - (alpha/len(X))*np.sum(term)</span><br><span class="line">        theta = temp    <span class="comment">#更新theta</span></span><br><span class="line">        cost[i] = computeCost(X, y, theta)</span><br><span class="line">    <span class="keyword">return</span> theta, cost</span><br><span class="line"></span><br><span class="line"><span class="string">'''梯度下降'''</span></span><br><span class="line">theta, cost = gradientDescent(X, y, theta, alpha, iters)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">'''测试集'''</span></span><br><span class="line">testpath = <span class="string">'testdata2.txt'</span></span><br><span class="line">testdata = pd.read_csv(testpath, header=<span class="literal">None</span>, names=[<span class="string">'Size'</span>, <span class="string">'Bedrooms'</span>])</span><br><span class="line">testdata = (testdata-testdata.mean())/testdata.std()        <span class="comment">#特征缩放</span></span><br><span class="line">testdata.insert(<span class="number">0</span>, <span class="string">'Ones'</span>, <span class="number">1</span>)</span><br><span class="line">Td = np.matrix(testdata)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">h_theta_x</span><span class="params">(theta, Td)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> Td*theta.T</span><br><span class="line">d1 = h_theta_x(theta, X)*stdPrice + meanPrice    <span class="comment">#逆特征缩放</span></span><br><span class="line">d1 = d1.astype(np.int32)      <span class="comment">#将矩阵元素类型转换为整数</span></span><br><span class="line">print(<span class="string">'通过梯度下降'</span>)</span><br><span class="line">print(d1)</span><br><span class="line"></span><br><span class="line"><span class="string">'''绘图-cost function的收敛'''</span></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">12</span>,<span class="number">8</span>))</span><br><span class="line">ax.plot(np.arange(iters), cost, <span class="string">'r'</span>)</span><br><span class="line">ax.set_xlabel(<span class="string">'Iterations'</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">'Cost'</span>)</span><br><span class="line">ax.set_title(<span class="string">'Error vs. Training Epoch'</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#—————————————————————————————————————————————</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">normalEqn</span><span class="params">(X, y)</span>:</span></span><br><span class="line">    <span class="string">'''正规方程'''</span></span><br><span class="line">    theta = np.linalg.inv(X.T@X)@X.T@y</span><br><span class="line">    <span class="keyword">return</span> theta</span><br><span class="line"></span><br><span class="line">nEtheta = normalEqn(X, y)</span><br><span class="line"></span><br><span class="line"><span class="string">'''测试集'''</span></span><br><span class="line">testpath = <span class="string">'testdata2.txt'</span></span><br><span class="line">testdata = pd.read_csv(testpath, header=<span class="literal">None</span>, names=[<span class="string">'Size'</span>, <span class="string">'Bedrooms'</span>])</span><br><span class="line">testdata = (testdata-testdata.mean())/testdata.std()        <span class="comment">#特征均一化</span></span><br><span class="line">testdata.insert(<span class="number">0</span>, <span class="string">'Ones'</span>, <span class="number">1</span>)</span><br><span class="line">Td = np.matrix(testdata)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">h_theta_x</span><span class="params">(theta, Td)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> Td*theta.T</span><br><span class="line">d2 = h_theta_x(theta, X)*stdPrice + meanPrice    <span class="comment">#逆特征缩放</span></span><br><span class="line">d2 = d2.astype(np.int32)      <span class="comment">#将矩阵元素类型转换为整数</span></span><br><span class="line">print(<span class="string">'通过正规方程'</span>)</span><br><span class="line">print(d2)</span><br><span class="line"></span><br><span class="line">print(theta - nEtheta)<span class="comment">#用梯度下降和正规方程求得的参数是不同的</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>队列的python实现</title>
      <link href="/2019/04/26/%E9%98%9F%E5%88%97%E7%9A%84python%E5%AE%9E%E7%8E%B0/"/>
      <url>/2019/04/26/%E9%98%9F%E5%88%97%E7%9A%84python%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>﻿队列（queue)，是一种<strong>操作受限的线性表</strong>。只允许在队列的一端添加元素，在队列的另一端删除元素。能添加元素的一端称为<strong>队尾</strong>，能删除元素的一端称为<strong>队头</strong>。</p><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    队列</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.__space = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isempty</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        判断队列是否为空</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="keyword">return</span> self.__space == []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">enqueue</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        添加元素到对头</span></span><br><span class="line"><span class="string">        :param item:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        self.__space.append(item)</span><br><span class="line">        <span class="comment">#self.__space.insert(0, item)</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dequeue</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        弹出元素从队尾</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        self.__space.pop(<span class="number">0</span>)</span><br><span class="line">        <span class="comment">#self.__space.pop()</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">access</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        返回队列中的全部元素</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="keyword">return</span> self.__space</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        队列元素个数</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="keyword">return</span> len(self.__space)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    qu = Queue()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈的python实现</title>
      <link href="/2019/04/26/%E6%A0%88%E7%9A%84python%E5%AE%9E%E7%8E%B0/"/>
      <url>/2019/04/26/%E6%A0%88%E7%9A%84python%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>﻿栈（stack),是一种<strong>操作受限的线性表</strong>。它的特点是只能在线性表的一端添加元素、删除元素，能进行添加、删除的元素的一端称为栈顶（top），另外一端称为栈底。按照先进后出（LIFO）的原则进行元素操作。</p><a id="more"></a><p><img src="https://img-blog.csdnimg.cn/2019042619572083.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NoZXJpc2hfeA==,size_16,color_FFFFFF,t_70" alt="栈"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    堆栈</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.__space = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isempty</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        判断栈是否为空</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="keyword">return</span> self.__space == []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        添加一个元素到栈顶</span></span><br><span class="line"><span class="string">        :param item:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        self.__space.append(item)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        弹出栈顶元素</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        self.__space.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">access</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        访问栈内所有元素</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="keyword">if</span> self.__space:</span><br><span class="line">            <span class="keyword">return</span> self.__space</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        返回栈的元素个数</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="keyword">return</span> len(self.__space)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    s = Stack()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python链表操作</title>
      <link href="/2019/04/19/Python%E9%93%BE%E8%A1%A8%E6%93%8D%E4%BD%9C/"/>
      <url>/2019/04/19/Python%E9%93%BE%E8%A1%A8%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p>python的链表操作</p><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value=None, next=None)</span>:</span></span><br><span class="line">        self.__value = value</span><br><span class="line">        self.__next = next</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getValue</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self.__value</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getNext</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self.__next</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">setValue</span><span class="params">(self, newValue)</span>:</span></span><br><span class="line">    self.__value = newValue</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">setNext</span><span class="params">(self, nexNext)</span>:</span></span><br><span class="line">    self.__next = nexNext</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Link</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.__head = Node()             <span class="comment">#头结点，不存放元素，哨兵节点</span></span><br><span class="line">        self.__tail = <span class="literal">None</span></span><br><span class="line">        self.__length = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    判断链表是否为空</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="keyword">return</span> self.__head.getNext() == <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, value)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    头插法插入元素</span></span><br><span class="line"><span class="string">    :param value:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    newnode = Node(value, <span class="literal">None</span>)</span><br><span class="line">    newnode.setNext(self.__head.getNext())</span><br><span class="line">    self.__head.setNext(newnode)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">append</span><span class="params">(self, value)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    尾插法插入元素</span></span><br><span class="line"><span class="string">    :param value:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    newnode = Node(value)</span><br><span class="line">    <span class="keyword">if</span> self.isEmpty():</span><br><span class="line">        self.__head.setNext(newnode)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        current = self.__head.getNext()</span><br><span class="line">        <span class="keyword">while</span> current.getNext() != <span class="literal">None</span>:</span><br><span class="line">            current = current.getNext()</span><br><span class="line">        current.setNext(newnode)</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, value)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    查找链表中是否含有该元素</span></span><br><span class="line"><span class="string">    :param value:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    current = self.__head</span><br><span class="line">    foundvalue = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">while</span> current != <span class="literal">None</span> <span class="keyword">and</span> <span class="keyword">not</span> foundvalue:</span><br><span class="line">        <span class="keyword">if</span> current.getValue() == value:</span><br><span class="line">            foundvalue = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            current = current.getNext()</span><br><span class="line">    <span class="keyword">return</span> foundvalue</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(self, value)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    查找该元素在链表中的下标位置，</span></span><br><span class="line"><span class="string">    若没有则返回None</span></span><br><span class="line"><span class="string">    :param value:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    current = self._head</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    found = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">while</span> current != <span class="literal">None</span> <span class="keyword">and</span> <span class="keyword">not</span> found:</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> current.getValue() == value:</span><br><span class="line">            <span class="keyword">return</span> count</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    打印链表元素</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    current = self.__head.getNext()</span><br><span class="line">    <span class="keyword">while</span> current != <span class="literal">None</span>:</span><br><span class="line">        print(current.getValue())</span><br><span class="line">        current = current.getNext()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(self, value)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    删除指定元素</span></span><br><span class="line"><span class="string">    :param value:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    current = self._head</span><br><span class="line">    <span class="keyword">while</span> current.getNext() != <span class="literal">None</span> <span class="keyword">and</span> current.getNext().getValue() != value:</span><br><span class="line">        current = current.getNext()</span><br><span class="line">    <span class="keyword">if</span> current.getNext() == <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>                    <span class="comment">#链表中无此元素，删除失败</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        r = current.getNext()</span><br><span class="line">        current.setNext(r.getNext())</span><br><span class="line">        <span class="keyword">del</span> r</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python删除列表元素的3种方法</title>
      <link href="/2019/04/01/python%E5%88%A0%E9%99%A4%E5%88%97%E8%A1%A8%E5%85%83%E7%B4%A0%E7%9A%843%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
      <url>/2019/04/01/python%E5%88%A0%E9%99%A4%E5%88%97%E8%A1%A8%E5%85%83%E7%B4%A0%E7%9A%843%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>​    1. remove:删除单个元素，<strong>按值删除</strong> </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">str = [<span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>]</span><br><span class="line">str.remove(<span class="number">2</span>)</span><br><span class="line">print(str)</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure><ol start="2"><li><p>pop:删除单个或多个元素，<strong>按位删除</strong></p><a id="more"></a></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">str = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">str.pop(<span class="number">2</span>)<span class="comment">#会返回被删除的元素的值</span></span><br><span class="line">print(str)</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure><ol start="3"><li>del:<strong>按位删除（根据元素在列表中的位置）</strong></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">str = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">del</span> str[<span class="number">0</span>]</span><br><span class="line">print(str)</span><br><span class="line"></span><br><span class="line">[<span class="number">2</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">str = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">del</span> str[<span class="number">0</span>:<span class="number">2</span>]<span class="comment">#利用切片删除多个元素</span></span><br><span class="line">print(str)</span><br><span class="line"></span><br><span class="line">[<span class="number">3</span>]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">del</span> str<span class="comment">#删除整个列表</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 列表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十六进制转十进制的C语言实现</title>
      <link href="/2018/09/05/%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E8%BD%AC%E5%8D%81%E8%BF%9B%E5%88%B6%E7%9A%84C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/"/>
      <url>/2018/09/05/%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E8%BD%AC%E5%8D%81%E8%BF%9B%E5%88%B6%E7%9A%84C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>嘻嘻，用到了前几天学到的循环队列，认识到了数据结构的魅力。<br>将输入的数据入队后，再挨个出队，首先检查队列的前两个数据是否为‘0x’<br>若是，再将其他数据出队，并且完成一系列操作。</p><a id="more"></a><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//————————————————————————</span></span><br><span class="line"><span class="comment">//十六进制转十进制（队列）</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxSize 10</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">product2</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">word2num</span><span class="params">(<span class="keyword">char</span> w)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hTod</span><span class="params">(<span class="keyword">char</span> a[])</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xQueue</span> &#123;</span></span><br><span class="line"><span class="keyword">char</span> data[maxSize];</span><br><span class="line"><span class="keyword">int</span> front, rear;</span><br><span class="line"><span class="keyword">int</span> length;<span class="comment">//表示队列长度</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> a[<span class="number">50</span>];</span><br><span class="line">gets(a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,hTod(a));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hTod</span><span class="params">(<span class="keyword">char</span> a[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> c, b, d;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>, numDem = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xQueue</span> <span class="title">que</span>;</span></span><br><span class="line">que.front = <span class="number">0</span>; que.rear = <span class="number">0</span>;</span><br><span class="line">que.length = <span class="number">0</span>;<span class="comment">//初始化循环队列</span></span><br><span class="line"><span class="keyword">char</span> *p = a;</span><br><span class="line"><span class="keyword">while</span> (*p != <span class="string">'\0'</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (que.front == (que.rear + <span class="number">1</span>) % maxSize)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//队列满</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">que.rear = (que.rear + <span class="number">1</span>) % maxSize;</span><br><span class="line">que.data[que.rear] = *p++;</span><br><span class="line">que.length++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">que.front = (que.front + <span class="number">1</span>) % maxSize;</span><br><span class="line">c = que.data[que.front];</span><br><span class="line">que.length--;</span><br><span class="line"><span class="keyword">if</span> (c == <span class="string">'0'</span>) &#123;</span><br><span class="line">que.front = (que.front + <span class="number">1</span>) % maxSize;</span><br><span class="line">b = que.data[que.front];</span><br><span class="line">que.length--;</span><br><span class="line"><span class="keyword">if</span> (b != <span class="string">'x'</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-2</span>;<span class="comment">//表示输入不是十六进制</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line"><span class="keyword">while</span> (que.front != que.rear) &#123;</span><br><span class="line">que.front = (que.front + <span class="number">1</span>) % maxSize;</span><br><span class="line">d = que.data[que.front];</span><br><span class="line"><span class="keyword">if</span> (d &gt;= <span class="string">'A'</span> &amp;&amp; d &lt;= <span class="string">'F'</span>)</span><br><span class="line">num = word2num(d);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (d &gt;= <span class="string">'0'</span> &amp;&amp; d &lt;= <span class="string">'9'</span>)</span><br><span class="line">num = d - <span class="string">'0'</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-3</span>;<span class="comment">//表示不符合十六进制的格式</span></span><br><span class="line">que.length--;</span><br><span class="line">numDem = numDem + num*product2(que.length);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> numDem;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">word2num</span><span class="params">(<span class="keyword">char</span> w)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line"><span class="keyword">switch</span>(w) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'A'</span>: num = <span class="number">10</span>; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'B'</span>: num = <span class="number">11</span>; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'C'</span>: num = <span class="number">12</span>; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'D'</span>: num = <span class="number">13</span>; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'E'</span>: num = <span class="number">14</span>; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'F'</span>: num = <span class="number">15</span>; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:num = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">product2</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">16</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">16</span> * product2(n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 循环队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用FFT频谱分析测量频率与幅值</title>
      <link href="/2018/08/31/%E5%88%A9%E7%94%A8FFT%E9%A2%91%E8%B0%B1%E5%88%86%E6%9E%90%E6%B5%8B%E9%87%8F%E9%A2%91%E7%8E%87%E4%B8%8E%E5%B9%85%E5%80%BC/"/>
      <url>/2018/08/31/%E5%88%A9%E7%94%A8FFT%E9%A2%91%E8%B0%B1%E5%88%86%E6%9E%90%E6%B5%8B%E9%87%8F%E9%A2%91%E7%8E%87%E4%B8%8E%E5%B9%85%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<p>之前做比赛的时候，发现这篇博客的访问量激增，意识到一丝不妙的感觉，就赶紧删除了，今天补一下。</p><p>之前幅值的问题也解决了。是我没把输入信号转成有符号信号送到FFT，而是直接将外部信号送入至FFT，虽然频率是对的，但是幅值就出现了很大的问题。<br>将信号转为有符号信号后，经FFT后得到最大值，然后根据AD的位宽，再转成响应的幅值。<br>——————————————————————————————————</p><a id="more"></a><p>先放几张仿真图，频谱分辨率分别是1 10 100 1000，输入信号频率是450Hz。我们可以从这几张图中，再次认识到用FFT做频谱分析出现误差的栅栏效应（在我上一篇博客中有详细讲解，当然大多是摘自高西全老师的《数字信号处理》一书） </p><p> <img src="https://img-blog.csdn.net/20180831172751335?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NoZXJpc2hfeA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br> <img src="https://img-blog.csdn.net/20180831172806767?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NoZXJpc2hfeA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br> <img src="https://img-blog.csdn.net/20180831172823100?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NoZXJpc2hfeA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br> <img src="https://img-blog.csdn.net/20180831172833689?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NoZXJpc2hfeA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>   利用FFT测频的思路是寻找最大幅值，确定最大幅值的RAM地址，再根据公式和频谱分辨率相称即可。用FFT测量幅值，我虽然没有做出来，可能是太废，但原理还是比较简单的。寻找到最大值后根据缩放因子进行左移或后移，再除于（N/2）。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span>  Mre_Fre(</span><br><span class="line">    <span class="keyword">input</span>                               clk,</span><br><span class="line">    <span class="keyword">input</span>                               rst_n,</span><br><span class="line">    <span class="keyword">input</span>               [<span class="number">1</span>:<span class="number">0</span>]           NumKey1,</span><br><span class="line">    <span class="keyword">input</span>               [<span class="number">9</span>:<span class="number">0</span>]           Data_In,</span><br><span class="line">    <span class="keyword">input</span>               [<span class="number">9</span>:<span class="number">0</span>]           WrAddr,</span><br><span class="line">    <span class="keyword">output</span>              [<span class="number">19</span>:<span class="number">0</span>]      Assignment,<span class="comment">//幅值</span></span><br><span class="line">    <span class="keyword">output</span>              [<span class="number">31</span>:<span class="number">0</span>]      Fre<span class="comment">//频率</span></span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span>     [<span class="number">9</span>:<span class="number">0</span>]       Fre_reso;<span class="comment">//频率分辨率</span></span><br><span class="line"><span class="keyword">always</span> @  (<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line">    <span class="keyword">if</span>(!rst_n)</span><br><span class="line">        Fre_reso &lt;= <span class="number">1'b1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">case</span>(NumKey1)</span><br><span class="line">            <span class="number">2'd0</span> :</span><br><span class="line">                Fre_reso &lt;= <span class="number">1'b1</span>;</span><br><span class="line">            <span class="number">2'd1</span> :</span><br><span class="line">                Fre_reso &lt;= <span class="number">4'd10</span>;</span><br><span class="line">            <span class="number">2'd2</span> :</span><br><span class="line">                Fre_reso &lt;= <span class="number">7'd100</span>;</span><br><span class="line">            <span class="number">2'd3</span> :</span><br><span class="line">                Fre_reso &lt;= <span class="number">10'd1000</span>;</span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//状态锁存      </span></span><br><span class="line"><span class="keyword">reg</span>     [<span class="number">9</span>:<span class="number">0</span>]       temp1,temp2,temp3;<span class="comment">//寄存器</span></span><br><span class="line"><span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line">    <span class="keyword">if</span>(!rst_n)</span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            temp1 &lt;= <span class="number">'d0</span>;</span><br><span class="line">            temp2 &lt;= <span class="number">'d0</span>;</span><br><span class="line">            temp3 &lt;= <span class="number">'d0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            temp1 &lt;= Data_In;</span><br><span class="line">            temp2 &lt;= temp1;</span><br><span class="line">            temp3 &lt;= temp2;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span>     [<span class="number">1</span>:<span class="number">0</span>]           status;<span class="comment">//状态</span></span><br><span class="line"><span class="keyword">reg</span>     [<span class="number">9</span>:<span class="number">0</span>]           A;<span class="comment">//幅值</span></span><br><span class="line"><span class="keyword">reg</span>     [<span class="number">31</span>:<span class="number">0</span>]      F;<span class="comment">//频率</span></span><br><span class="line"><span class="keyword">reg</span>                     Flag;<span class="comment">//峰值标志位</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line">    <span class="keyword">if</span>(!rst_n)</span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            status &lt;= <span class="number">'d0</span>;</span><br><span class="line">            A &lt;= <span class="number">'d0</span>;</span><br><span class="line">            F &lt;= <span class="number">'d0</span>;</span><br><span class="line">            Flag &lt;= <span class="number">'d0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">case</span>(status)</span><br><span class="line">            <span class="number">2'd0</span> :</span><br><span class="line">                <span class="keyword">if</span>(WrAddr == <span class="number">10'd1</span>)</span><br><span class="line">                    <span class="keyword">begin</span></span><br><span class="line">                        status &lt;= <span class="number">1'd1</span>;</span><br><span class="line">                        A &lt;= <span class="number">'d0</span>;</span><br><span class="line">                        F &lt;= <span class="number">'d0</span>;</span><br><span class="line">                        Flag &lt;= <span class="number">'d0</span>;</span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">begin</span></span><br><span class="line">                        Flag &lt;= <span class="number">'d0</span>;</span><br><span class="line">                        status &lt;= <span class="number">'d0</span>;</span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">            <span class="number">2'd1</span> :</span><br><span class="line">                <span class="keyword">if</span>(WrAddr &lt;= <span class="number">10'd512</span>)</span><br><span class="line">                    <span class="keyword">begin</span></span><br><span class="line">                        status &lt;= <span class="number">1'd1</span>;</span><br><span class="line">                        <span class="keyword">if</span>(temp2 - temp1 &gt; <span class="number">3'd5</span> &amp;&amp; temp2 &gt; temp3)</span><br><span class="line">                            <span class="keyword">begin</span></span><br><span class="line">                                <span class="keyword">if</span>(temp2 &gt;= A)</span><br><span class="line">                                    <span class="keyword">begin</span></span><br><span class="line">                                        F &lt;= WrAddr - <span class="number">2</span>;<span class="comment">//Ram的特性，会有两个地址的延迟。</span></span><br><span class="line">                                        A &lt;= temp2;</span><br><span class="line">                                    <span class="keyword">end</span></span><br><span class="line">                            <span class="keyword">end</span></span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">begin</span></span><br><span class="line">                        Flag &lt;= <span class="number">1'b1</span>;</span><br><span class="line">                        status &lt;= <span class="number">'d2</span>;                      </span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">            <span class="number">2'd2</span> :</span><br><span class="line">                status &lt;= <span class="number">'d0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span>  Fre = Flag ? F*Fre_reso : Fre;</span><br><span class="line"><span class="keyword">assign</span>  Assignment = Flag ? A * <span class="number">2</span> : Assignment;</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"><span class="meta">`</span></span><br></pre></td></tr></table></figure><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> FPGA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 电赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>筛选法求100以内的素数</title>
      <link href="/2018/08/31/%E7%AD%9B%E9%80%89%E6%B3%95%E6%B1%82100%E4%BB%A5%E5%86%85%E7%9A%84%E7%B4%A0%E6%95%B0/"/>
      <url>/2018/08/31/%E7%AD%9B%E9%80%89%E6%B3%95%E6%B1%82100%E4%BB%A5%E5%86%85%E7%9A%84%E7%B4%A0%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>将100个自然数有序排列。<br> 第一个数1不是质数也不是合数，不做处理。<br>第二个数2是质数，留下，并把100以内能将2整除的数划掉（置为1）<br>第三个数3是质数，留下，并把100以内能将3整除的数划掉（置1）</p><a id="more"></a><p>。<br>。<br>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isPreme</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++)&#123;</span><br><span class="line">num[i<span class="number">-1</span>] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (num[i] == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (num[i] != <span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; <span class="number">100</span>; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (num[j] % num[i] == <span class="number">0</span>)</span><br><span class="line">num[j] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">0</span>)<span class="built_in">printf</span>(<span class="string">"%d\t"</span>, num[i]);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (num[i] != num[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\t"</span>,num[i]);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分法求方程的根</title>
      <link href="/2018/08/28/%E4%BA%8C%E5%88%86%E6%B3%95%E6%B1%82%E6%96%B9%E7%A8%8B%E7%9A%84%E6%A0%B9/"/>
      <url>/2018/08/28/%E4%BA%8C%E5%88%86%E6%B3%95%E6%B1%82%E6%96%B9%E7%A8%8B%E7%9A%84%E6%A0%B9/</url>
      
        <content type="html"><![CDATA[<p>﻿二分法的原理其实还是零点定理的应用。</p><a id="more"></a><p>首先必须要有一个初试区间，而且区间端点的函数值异号，由零点定理可以知道在次区间内至少存在一个零点。然后取区间的中间值，这样就把一个区间分成了两个区间，再运用零点定理判断零点存在与哪个区间中，再在含有零点的区间取中间值，就以这样一次一次的取中间值，判断零点是否存在，当区间两端点的差的绝对值符合精度是即可停止。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//————————————————————</span></span><br><span class="line"><span class="comment">//二分法求近似的方程根</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span><span class="title">funY</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">double</span> x1 = <span class="number">-10</span>, x2 = <span class="number">10</span>;<span class="comment">//初试区间[-10，10]</span></span><br><span class="line"><span class="keyword">double</span> x;</span><br><span class="line"><span class="keyword">double</span> y1, y2,y;</span><br><span class="line">y1 = funY(x1);</span><br><span class="line">y2 = funY(x2);</span><br><span class="line"><span class="keyword">while</span> (y1*y2 &lt; <span class="number">0</span> &amp;&amp; <span class="built_in">fabs</span>(x2 - x1) &gt;= <span class="number">1e-6</span>)&#123;</span><br><span class="line">x = (x1 + x2) / <span class="number">2</span>;</span><br><span class="line">y = funY(x);</span><br><span class="line"><span class="keyword">if</span> (y*y1 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">x2 = x;</span><br><span class="line">y2 = y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (y*y2 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">x1 = x;</span><br><span class="line">y1 = y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (y == <span class="number">0</span>) </span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lf\n"</span>, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span><span class="title">funY</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">double</span> y;</span><br><span class="line">y = <span class="number">2</span> * x*x*x - <span class="number">4</span> * x*x + <span class="number">3</span> * x - <span class="number">6</span>;</span><br><span class="line"><span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牛顿迭代法的C语言实现</title>
      <link href="/2018/08/25/%E7%89%9B%E9%A1%BF%E8%BF%AD%E4%BB%A3%E6%B3%95%E7%9A%84C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/"/>
      <url>/2018/08/25/%E7%89%9B%E9%A1%BF%E8%BF%AD%E4%BB%A3%E6%B3%95%E7%9A%84C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>牛顿迭代法是求方程根的一种解法。</p><p>一、求一个数a的平方根，可以用迭代法无限逼近。<br>迭代法公式如下</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X2 = (x1+a/x1)/2</span><br></pre></td></tr></table></figure><p>S1，要先预估一个值x1，通常取x1=a/2;<br>S2，带入迭代公式，得到x2；<br>S3，计算x1 和 x2 的差的绝对值是否符合精确度；若符合则x2便是结果，若不符合进入S4；<br>S4，x1 = x2，然后重复S2、S3，直到符合精确度。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">float</span> a;</span><br><span class="line"><span class="keyword">float</span> x1, x2;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"请输入待求平方根的数："</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%f"</span>,&amp;a);</span><br><span class="line">x1 = a / <span class="number">2</span>;</span><br><span class="line">x2 = (x1 + a / x1) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">fabs</span>(x1 - x2) &gt;= <span class="number">1e-5</span>) &#123;</span><br><span class="line">x1 = x2;</span><br><span class="line">x2 = (x1 + a / x1) / <span class="number">2</span>;</span><br><span class="line">&#125;   </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%f"</span>,x2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二、求一元多次方程的根<br>迭代公式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x2 = x1 - f(x1)/df(x1);</span><br></pre></td></tr></table></figure><p>算法的基本设计思想与求平方根相同。不再赘述</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//————————————————————</span></span><br><span class="line"><span class="comment">//牛顿迭代法求方程的根</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">funY</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">funY1</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">double</span> x, x1, x2;</span><br><span class="line"></span><br><span class="line">x1 = <span class="number">1.5</span>;<span class="comment">//求1.5附近的根</span></span><br><span class="line">x2 = x1 - funY(x1) / funY1(x1);</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">fabs</span>(x2 - x1) &gt; <span class="number">1e-6</span>) &#123;</span><br><span class="line">x1 = x2;</span><br><span class="line">x2 = x2 = x1 - funY(x1) / funY1(x1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lf"</span>,x2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//————————————————————</span></span><br><span class="line"><span class="comment">//y的函数</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">funY</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">double</span> y;</span><br><span class="line">y = <span class="number">2</span> * x*x*x - <span class="number">4</span> * x*x + <span class="number">3</span> * x - <span class="number">6</span>;</span><br><span class="line"><span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//y的一阶导数</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">funY1</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">double</span> y1;</span><br><span class="line">y1 = <span class="number">6</span> * x*x - <span class="number">8</span> * x + <span class="number">3</span>;</span><br><span class="line"><span class="keyword">return</span> y1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最大公约数和最小公倍数的解决方案</title>
      <link href="/2018/08/25/%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%E5%92%8C%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/2018/08/25/%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%E5%92%8C%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<p>﻿最大公因数，也称最大公约数、最大公因子，指两个或多个整数共有约数中最大的一个。例如24、60，他们的最大公约数就是12.<br>两个或多个整数公有的倍数叫做它们的公倍数，其中除0以外最小的一个公倍数就叫做这几个整数的最小公倍数。例如24、60，他们的最小公倍数是120。</p><a id="more"></a><p>最大公约数的解决方案可以使用欧几里得算法。<br>例如，求（319，377）：<br>∵ 319÷377=0（余319）<br>∴（319，377）=（377，319）；<br>∵ 377÷319=1（余58）<br>∴（377，319）=（319，58）；<br>∵ 319÷58=5（余29）<br>∴ （319，58）=（58，29）；<br>∵ 58÷29=2（余0）<br>∴ （58，29）= 29；<br>∴ （319，377）=29。<br>最小公倍数可以用两个数相乘然后除以最大公约数。（a*b/最大公约数）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//——————————————————————————————</span></span><br><span class="line"><span class="comment">//判断两个数的最大公约数和最小公倍数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcomfac</span><span class="params">(<span class="keyword">int</span> m,<span class="keyword">int</span> n)</span></span>;<span class="comment">//最大公约数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lcommult</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> x)</span></span>;<span class="comment">//最小公倍数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> m, n, gfac, lcm;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"请输入两个数："</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;m,&amp;n);</span><br><span class="line">gfac = gcomfac(m,n);</span><br><span class="line">lcm = lcommult(m,n,gfac);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"最大公约数：%d\n最小公倍数：%d\n"</span>,gfac,lcm);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcomfac</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> result;</span><br><span class="line"><span class="keyword">if</span> (m / n == <span class="number">0</span>)</span><br><span class="line">result = gcomfac(n, m);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (m%n == <span class="number">0</span>)</span><br><span class="line">result = n;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (m%n != <span class="number">0</span>)</span><br><span class="line">result = gcomfac(n, m%n);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lcommult</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> lcm;</span><br><span class="line">lcm = (m*n) / x;</span><br><span class="line"><span class="keyword">return</span> lcm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 最大公约数 </tag>
            
            <tag> 最小公倍数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python中的三目运算</title>
      <link href="/2018/05/31/python%E4%B8%AD%E7%9A%84%E4%B8%89%E7%9B%AE%E8%BF%90%E7%AE%97/"/>
      <url>/2018/05/31/python%E4%B8%AD%E7%9A%84%E4%B8%89%E7%9B%AE%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<p>﻿python中的三目运算和C语言有点不同。</p><a id="more"></a><p>C语言里</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">4</span>;</span><br><span class="line">c = (a &lt; b) ? a : b<span class="comment">//取最小值</span></span><br></pre></td></tr></table></figure><p>python中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a, b = <span class="number">3</span>, <span class="number">4</span></span><br><span class="line"><span class="comment">#第一种方法：true if condition else false</span></span><br><span class="line">c = a <span class="keyword">if</span> a &lt; b <span class="keyword">else</span> b</span><br><span class="line"></span><br><span class="line"><span class="comment">#第二种方法：condition and ture or false</span></span><br><span class="line">d = a &lt; b <span class="keyword">and</span> a <span class="keyword">or</span> b</span><br></pre></td></tr></table></figure><p>上面的第二种方法算是对逻辑运算符的熟练运用吧<br>在a、b都为真的情况下<br>当condition为真的时候，变成Ture and a or b ,也就是a，因为or语句当左边操作数为真时，就不再判断右边操作数。<br>当condition为假的时候，变成False and a or b ，也就是b,因为and语句当左边操作数为假时，不再判断右边操作数，直接为False。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 三目运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>verilog中的generate语句</title>
      <link href="/2018/04/01/verilog%E4%B8%AD%E7%9A%84generate%E8%AF%AD%E5%8F%A5/"/>
      <url>/2018/04/01/verilog%E4%B8%AD%E7%9A%84generate%E8%AF%AD%E5%8F%A5/</url>
      
        <content type="html"><![CDATA[<p>﻿generate语句可以动态的生成verilog代码，当对矢量中的多个位进行重复操作时，或者当进行多个模块的实例引用的重复操作时，或者根据参数的定义来确定程序中是否应该包含某段Verilog代码的时候，使用生成语句能大大简化程序的编写过程。</p><a id="more"></a><p>​       生成语句生成的实例范围，关键字generate-endgenerate用来指定该范围。生成实例可以是以下的一个或多个类型：<br>​       （1）模块；（2）用户定义原语；（3）门级语句；（4）连续赋值语句；（5）initial和always块。<br>​       generate语句有generate-for，generate-if，generate-case三种语句。<br>1.generate-for语句<br>（1) 必须有genvar关键字定义for语句的变量。<br>（2）for语句的内容必须加begin和end（即使就一句）。<br>（3）for语句必须有个名字。<br>例1：assign语句实现</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> test(bin,gray);</span><br><span class="line">       <span class="keyword">parameter</span> SIZE=<span class="number">8</span>;</span><br><span class="line">       <span class="keyword">output</span> [SIZE-<span class="number">1</span>:<span class="number">0</span>] bin;</span><br><span class="line">       <span class="keyword">input</span> [SIZE-<span class="number">1</span>:<span class="number">0</span>] gray;</span><br><span class="line">       <span class="keyword">genvar</span> i; <span class="comment">//genvar i;也可以定义到generate语句里面</span></span><br><span class="line">       <span class="keyword">generate</span></span><br><span class="line">              <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;SIZE;i=i+<span class="number">1</span>)</span><br><span class="line">              <span class="keyword">begin</span>:<span class="keyword">bit</span></span><br><span class="line">                     <span class="keyword">assign</span> bin[i]=^gray[SIZE-<span class="number">1</span>:i];</span><br><span class="line">              <span class="keyword">end</span></span><br><span class="line">       <span class="keyword">endgenerate</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><p>等同于</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assign</span> bin[<span class="number">0</span>]=^gray[SIZE-<span class="number">1</span>:<span class="number">0</span>];</span><br><span class="line"><span class="keyword">assign</span> bin[<span class="number">1</span>]=^gray[SIZE-<span class="number">1</span>:<span class="number">1</span>];</span><br><span class="line"><span class="keyword">assign</span> bin[<span class="number">2</span>]=^gray[SIZE-<span class="number">1</span>:<span class="number">2</span>];</span><br><span class="line"><span class="keyword">assign</span> bin[<span class="number">3</span>]=^gray[SIZE-<span class="number">1</span>:<span class="number">3</span>];</span><br><span class="line"><span class="keyword">assign</span> bin[<span class="number">4</span>]=^gray[SIZE-<span class="number">1</span>:<span class="number">4</span>];</span><br><span class="line"><span class="keyword">assign</span> bin[<span class="number">5</span>]=^gray[SIZE-<span class="number">1</span>:<span class="number">5</span>];</span><br><span class="line"><span class="keyword">assign</span> bin[<span class="number">6</span>]=^gray[SIZE-<span class="number">1</span>:<span class="number">6</span>];</span><br><span class="line"><span class="keyword">assign</span> bin[<span class="number">7</span>]=^gray[SIZE-<span class="number">1</span>:<span class="number">7</span>];</span><br></pre></td></tr></table></figure><p>例2</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">generate</span></span><br><span class="line">       <span class="keyword">genvar</span> i;</span><br><span class="line">       <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;SIZE;i=i+<span class="number">1</span>)</span><br><span class="line">       <span class="keyword">begin</span>:shifter</span><br><span class="line">              <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk)</span><br><span class="line">                     shifter[i]&lt;=(i==<span class="number">0</span>)?din:shifter[i-<span class="number">1</span>];</span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endgenerate</span></span><br></pre></td></tr></table></figure><p>等同于</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span>@(<span class="keyword">posedge</span> clk)</span><br><span class="line">       shifter[<span class="number">0</span>]&lt;=din;</span><br><span class="line"><span class="keyword">always</span>@(<span class="keyword">posedge</span> clk)</span><br><span class="line">       shifter[<span class="number">1</span>]&lt;=shifter[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">always</span>@(<span class="keyword">posedge</span> clk)</span><br><span class="line">       shifter[<span class="number">2</span>]&lt;=shifter[<span class="number">1</span>];</span><br><span class="line">.................</span><br><span class="line">       ......................</span><br><span class="line"><span class="keyword">always</span>@(<span class="keyword">posedge</span> clk)</span><br><span class="line">       shifter[SIZE]&lt;=shifter[SIZE-<span class="number">1</span>];</span><br></pre></td></tr></table></figure><p>generate-if，generate-case和generate-for语句类似。</p><p>转载自：<a href="http://lihaichuan.blog.51cto.com/498079/1118866" target="_blank" rel="noopener">http://lihaichuan.blog.51cto.com/498079/1118866</a></p>]]></content>
      
      
      <categories>
          
          <category> FPGA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FPGA </tag>
            
            <tag> verilog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用esp8266wifi信号强度测距</title>
      <link href="/2018/02/24/%E5%88%A9%E7%94%A8esp8266wifi%E4%BF%A1%E5%8F%B7%E5%BC%BA%E5%BA%A6%E6%B5%8B%E8%B7%9D/"/>
      <url>/2018/02/24/%E5%88%A9%E7%94%A8esp8266wifi%E4%BF%A1%E5%8F%B7%E5%BC%BA%E5%BA%A6%E6%B5%8B%E8%B7%9D/</url>
      
        <content type="html"><![CDATA[<p>﻿[外链图片转存中…(img-ThlOzYaT-1571226330026)]<br>向esp8266发送指令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AT + CWLAP</span><br></pre></td></tr></table></figure><p>可以得到当前可加入wifi信号的信息，其中包括的rssi，就是我们所需要的。<br>提取出rssi，然后带入公式<br>    <a id="more"></a><br>    d = 10^((abs(rssi) - A) / (10 * n))<br>即可得到接收机和发射机之间的大概距离。<br>效果图<br>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-ciPf4oMU-1571226330029)(<a href="http://img.blog.csdn.net/20180224154307689?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQ2hlcmlzaF94/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)]" target="_blank" rel="noopener">http://img.blog.csdn.net/20180224154307689?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQ2hlcmlzaF94/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)]</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"reg52.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"string.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"math.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> uint;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> uchar;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NAME 9   <span class="comment">//xutianyun</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>N 40<span class="comment">//N = 10 * n ,其中n为环境衰减因子，3.25-4.5</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> A 51<span class="comment">//接收机和发射机间隔1m时的信号强度</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> rssidata = <span class="number">0</span>;</span><br><span class="line">uchar recbuffer[<span class="number">32</span>];</span><br><span class="line">uint cnt = <span class="number">0</span>;</span><br><span class="line">uint getit = <span class="number">0</span>;</span><br><span class="line">uint datalen = <span class="number">0</span>;</span><br><span class="line">uchar wifi_rssi[<span class="number">5</span>];</span><br><span class="line">uchar wifi_ssid[<span class="number">11</span>] = &#123;<span class="string">'"'</span>,<span class="string">'x'</span>,<span class="string">'u'</span>,<span class="string">'t'</span>,<span class="string">'i'</span>,<span class="string">'a'</span>,<span class="string">'n'</span>,<span class="string">'y'</span>,<span class="string">'u'</span>,<span class="string">'n'</span>,<span class="string">'"'</span>&#125;;</span><br><span class="line"><span class="keyword">float</span> d;</span><br><span class="line">uint dis;</span><br><span class="line">uchar temp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UsartInit</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">SCON = <span class="number">0x50</span>;</span><br><span class="line">TMOD = <span class="number">0x20</span>;</span><br><span class="line">PCON = <span class="number">0x80</span>;</span><br><span class="line">TH1  = <span class="number">0xF3</span>;</span><br><span class="line">TL1  = <span class="number">0xF3</span>;</span><br><span class="line">ES   = <span class="number">1</span>;</span><br><span class="line">EA   = <span class="number">1</span>;</span><br><span class="line">TR1  = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SendUart</span><span class="params">(uchar value)</span></span>&#123;</span><br><span class="line">ES = <span class="number">0</span>;</span><br><span class="line">SBUF = value;</span><br><span class="line"><span class="keyword">while</span>(!TI);</span><br><span class="line">TI = <span class="number">0</span>;</span><br><span class="line">ES = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SendString</span><span class="params">(uchar *str)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span>(*str != <span class="string">'\0'</span>) &#123;</span><br><span class="line">SendUart(*str);</span><br><span class="line">str++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">rssiTodis</span><span class="params">(<span class="keyword">int</span> RSSI)</span> </span>&#123;</span><br><span class="line"><span class="keyword">float</span> iu, distance;</span><br><span class="line">iu = (<span class="keyword">float</span>)(RSSI - A) / (<span class="keyword">float</span>)N;</span><br><span class="line">distance = <span class="built_in">pow</span>(<span class="number">10</span>, iu);</span><br><span class="line"><span class="keyword">return</span> distance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">UsartInit();</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Usart</span><span class="params">()</span> interrupt 4 </span>&#123;</span><br><span class="line">uchar rec;</span><br><span class="line"><span class="keyword">if</span>(RI != <span class="number">0</span>)&#123;</span><br><span class="line">rec = SBUF;</span><br><span class="line">RI = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(rec == <span class="string">'"'</span>)&#123;</span><br><span class="line">cnt = <span class="number">1</span>;</span><br><span class="line">getit = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(rec == <span class="string">','</span>) &#123;</span><br><span class="line">cnt = <span class="number">0</span>;</span><br><span class="line">datalen = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(getit == <span class="number">1</span>)&#123;</span><br><span class="line">SendUart(wifi_rssi[<span class="number">1</span>]);</span><br><span class="line">SendUart(wifi_rssi[<span class="number">2</span>]);</span><br><span class="line">SendString(<span class="string">"\r\n"</span>);</span><br><span class="line">rssidata = (wifi_rssi[<span class="number">1</span>] - <span class="string">'0'</span>)* <span class="number">10</span> + (wifi_rssi[<span class="number">2</span>] - <span class="string">'0'</span>);</span><br><span class="line"></span><br><span class="line">d = rssiTodis(rssidata);</span><br><span class="line">dis = d*<span class="number">10000</span>;</span><br><span class="line">temp = dis/<span class="number">10000</span> + <span class="string">'0'</span>;</span><br><span class="line">SendUart(temp);</span><br><span class="line">temp = dis/<span class="number">1000</span>%<span class="number">10</span> + <span class="string">'0'</span>;</span><br><span class="line">SendUart(temp);</span><br><span class="line">temp = dis/<span class="number">100</span>%<span class="number">10</span> + <span class="string">'0'</span>;</span><br><span class="line">SendUart(temp);</span><br><span class="line">temp = dis/<span class="number">10</span>%<span class="number">10</span> + <span class="string">'0'</span>;</span><br><span class="line">SendUart(temp);</span><br><span class="line">temp = dis%<span class="number">10</span> + <span class="string">'0'</span>;</span><br><span class="line">SendUart(temp);</span><br><span class="line">SendString(<span class="string">"\r\nok\r\n"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(rec == <span class="string">'-'</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strncmp</span>(recbuffer, wifi_ssid, NAME + <span class="number">2</span>) == <span class="number">0</span>)getit = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(cnt == <span class="number">1</span>)&#123;</span><br><span class="line">recbuffer[datalen++] = rec;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(getit == <span class="number">1</span>) &#123;</span><br><span class="line">wifi_rssi[datalen++] = rec;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：以上代码烧录单片机后，需要借助串口调试助手，</p>]]></content>
      
      
      <categories>
          
          <category> IoT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> wifi测距 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言比较字符串</title>
      <link href="/2018/02/22/C%E8%AF%AD%E8%A8%80%E6%AF%94%E8%BE%83%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2018/02/22/C%E8%AF%AD%E8%A8%80%E6%AF%94%E8%BE%83%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<p>库函数strcmp是C语言中比较字符串的函数。<br>在头文件string.h中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">strcmp</span>（<span class="keyword">char</span> *a, <span class="keyword">char</span> *b）;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strncmp</span><span class="params">(<span class="keyword">char</span> *a, <span class="keyword">char</span> *b, N)</span></span>;  <span class="comment">//比较前N位</span></span><br></pre></td></tr></table></figure><p>这个函数按照ASCII码表对两个字符串的每个字符进行比对。如果二者完全相同返回0，<br>如果字符串a中的字符ASCII码先出现较大者，则返回1，反之返回-1；</p>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rssi信号强度与距离的转换公式</title>
      <link href="/2018/02/22/rssi%E4%BF%A1%E5%8F%B7%E5%BC%BA%E5%BA%A6%E4%B8%8E%E8%B7%9D%E7%A6%BB%E7%9A%84%E8%BD%AC%E6%8D%A2%E5%85%AC%E5%BC%8F/"/>
      <url>/2018/02/22/rssi%E4%BF%A1%E5%8F%B7%E5%BC%BA%E5%BA%A6%E4%B8%8E%E8%B7%9D%E7%A6%BB%E7%9A%84%E8%BD%AC%E6%8D%A2%E5%85%AC%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>﻿    d = 10^((abs(rssi) - A) / (10 * n))</p><p>其中：<br>    d - 计算所得距离(单位：m)<br>    rssi - 接收信号强度<br>    A - 发射端和接收端相隔1米时的信号强度<br>    n - 环境衰减因子</p>]]></content>
      
      
      <categories>
          
          <category> IoT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rssi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FPGA--我们到底要怎么搭复位电路</title>
      <link href="/2018/02/06/FPGA%E2%80%94%E2%80%94%E6%88%91%E4%BB%AC%E5%88%B0%E5%BA%95%E8%A6%81%E6%80%8E%E4%B9%88%E6%90%AD%E5%A4%8D%E4%BD%8D%E7%94%B5%E8%B7%AF/"/>
      <url>/2018/02/06/FPGA%E2%80%94%E2%80%94%E6%88%91%E4%BB%AC%E5%88%B0%E5%BA%95%E8%A6%81%E6%80%8E%E4%B9%88%E6%90%AD%E5%A4%8D%E4%BD%8D%E7%94%B5%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<p>第一次看特权同学写的亚稳态的问题时，说实话，真的没有看懂。以前就是一直用的异步复位，同时也没有遇到过这样的问题。沉下心来，又仔细的看了一遍，发现了问题所在，特别是当你的工程特别大的时候，可能会非常严重。</p><a id="more"></a><p>异步复位：复位信号和系统时钟信号的触发可以在任何时刻。二者相互独立。<br>同步复位：在系统时钟信号的触发下，复位信号有效。<br>用verilog表示会更明显：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 异步复位</span></span><br><span class="line"><span class="keyword">reg</span>a;</span><br><span class="line"><span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)<span class="keyword">begin</span></span><br><span class="line"><span class="keyword">if</span>(!rst_n)</span><br><span class="line">a &lt;= <span class="number">'d0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">a &lt;= ~a;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//同步复位</span></span><br><span class="line"><span class="keyword">reg</span>b;</span><br><span class="line"><span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk)<span class="keyword">begin</span></span><br><span class="line"><span class="keyword">if</span>(!rst_n)</span><br><span class="line">b &lt;= <span class="number">'d0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">b &lt;= ~b;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>如果复位信号的撤销发生在系统时钟的建立和保持时间这段时间内，系统此时检测到复位信号的状态就处在一个亚稳态，无法确定是0还是1。就有可能造成系统工作不同步的问题。</p><pre><code>特权同学在书中讲到同步复位发生的概率相对异步复位比较低，这一点，我在网上查了，也是很多人都这样认为，这个我还没有理解。</code></pre><p>异步复位会影响寄存器的recovery时间，引起设计的稳定性问题，尤其对于状态机的无意识复位，将导致进入不确定的状态。<br>同步复位最主要的问题是对于不带同步复位专用端口的器件会增加额外的逻辑资源。<br>在书中，特权同学提到了一种取长补短的方法：异步复位、同步释放。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//异步复位、同步释放</span></span><br><span class="line"><span class="keyword">reg</span>rst_nr1;</span><br><span class="line"><span class="keyword">reg</span>rst_nr2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)<span class="keyword">begin</span></span><br><span class="line"><span class="keyword">if</span>(!rst_n)</span><br><span class="line">rst_nr1 &lt;= <span class="number">'d0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">rst_nr1 &lt;= <span class="number">1'b1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)<span class="keyword">begin</span></span><br><span class="line"><span class="keyword">if</span>(!rst_n)</span><br><span class="line">rst_nr2 &lt;= <span class="number">'d0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">rst_nr2 &lt;= rst_nr1;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>简单分析一下这个电路，当异步复位发生，rst_nr2直接拉低为0，并且由于rst_nr2是在时钟沿的作用下对rst_nr1进行采样，所以当rst_nr2的置1是和时钟沿同步的。也就是异步复位、同步释放。然后用信号rst_nr2作为系统复位时钟，就不发生亚稳态现象。</p><p>但是在我的理解看来，这两个触发器仍然是采用rst_n作为复位信号，所以必然会有亚稳态的现象发生，即rst_nr2还是 有可能在不应该复位的时间点复位，但是由rst_nr2作为系统复位信号的后级电路<strong>不会发生系统工作不同步</strong>的现象。</p>]]></content>
      
      
      <categories>
          
          <category> FPGA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FPGA </tag>
            
            <tag> 复位电路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FPGA--时钟分频和时钟使能的思考</title>
      <link href="/2018/02/02/FPGA%E2%80%94%E2%80%94%E6%97%B6%E9%92%9F%E5%88%86%E9%A2%91%E5%92%8C%E6%97%B6%E9%92%9F%E4%BD%BF%E8%83%BD%E7%9A%84%E6%80%9D%E8%80%83/"/>
      <url>/2018/02/02/FPGA%E2%80%94%E2%80%94%E6%97%B6%E9%92%9F%E5%88%86%E9%A2%91%E5%92%8C%E6%97%B6%E9%92%9F%E4%BD%BF%E8%83%BD%E7%9A%84%E6%80%9D%E8%80%83/</url>
      
        <content type="html"><![CDATA[<p>之前遇到时钟需要分频的时候，直接用计数器和源时钟产生，然后把这个分频时钟的上升沿作为敏感事件去写了，今天看了特权同学的书，也自己在网上看了看，这样做是不好的，降低了系统的可靠性，在实际工程中我们应该避免这中写法。采用时钟使能的方式，这样整个工程都是单一时钟电路，也利于分析维护。</p><a id="more"></a><p>建议的写法如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> pro(</span><br><span class="line"><span class="keyword">input</span>clk,</span><br><span class="line"><span class="keyword">input</span>rst_n</span><br><span class="line">);</span><br><span class="line"><span class="keyword">reg</span>[<span class="number">2</span>:<span class="number">0</span>]count;</span><br><span class="line"><span class="keyword">wire</span> clk_en;</span><br><span class="line"><span class="keyword">reg</span>a;</span><br><span class="line"><span class="keyword">reg</span>b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)<span class="keyword">begin</span></span><br><span class="line"><span class="keyword">if</span>(!rst_n)</span><br><span class="line">count &lt;= <span class="number">'d0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(count &gt; <span class="number">3'd5</span>)</span><br><span class="line">count &lt;= <span class="number">'d0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">count &lt;= count + <span class="number">1'b1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span>clk_en = (count == <span class="number">3'd5</span>);<span class="comment">//只拉高一个时钟周期</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)<span class="keyword">begin</span></span><br><span class="line"><span class="keyword">if</span>(!rst_n)<span class="keyword">begin</span></span><br><span class="line">a &lt;= <span class="number">1'b0</span>;</span><br><span class="line">b &lt;= <span class="number">1'b0</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(clk_en)<span class="keyword">begin</span><span class="comment">//分频时钟作使能信号使用</span></span><br><span class="line">a &lt;= ~b;</span><br><span class="line">b &lt;= ~a;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> FPGA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FPGA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ESP8266——OneNet的GET指令及C语言代码</title>
      <link href="/2018/01/26/ESP8266%E2%80%94%E2%80%94OneNet%E7%9A%84GET%E6%8C%87%E4%BB%A4%E5%8F%8AC%E8%AF%AD%E8%A8%80%E4%BB%A3%E7%A0%81/"/>
      <url>/2018/01/26/ESP8266%E2%80%94%E2%80%94OneNet%E7%9A%84GET%E6%8C%87%E4%BB%A4%E5%8F%8AC%E8%AF%AD%E8%A8%80%E4%BB%A3%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p>﻿GET指令的HTTP数据报文</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">GET /devices/你的设备号/datastreams/你的数据流名称 HTTP/<span class="number">1.1</span>\r\n</span><br><span class="line">Host: api.heclouds.com\r\n</span><br><span class="line">api-key: 你的apikey\r\n\r\n</span><br></pre></td></tr></table></figure><p>我更改了ESP8266的波特率，改成了4800的；</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AT+UART=4800,8,1,0,0\r\n //更改esp8266的波特率</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"reg52.h"</span></span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> uint;</span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> uchar;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DATASIZE 110</span></span><br><span class="line"></span><br><span class="line">sbit LED = P2^<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">uchar datalen = <span class="number">0</span>;</span><br><span class="line">uchar value;</span><br><span class="line">uchar cnt = <span class="number">0</span>;</span><br><span class="line">uchar recbuffer[DATASIZE];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delay600ms</span><span class="params">()</span><span class="comment">//@12.000MHz</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> i, j, k;</span><br><span class="line"></span><br><span class="line">i = <span class="number">5</span>;</span><br><span class="line">j = <span class="number">144</span>;</span><br><span class="line">k = <span class="number">71</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (--k);</span><br><span class="line">&#125; <span class="keyword">while</span> (--j);</span><br><span class="line">&#125; <span class="keyword">while</span> (--i);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UsartInit</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">SCON = <span class="number">0x50</span>;</span><br><span class="line">TMOD = <span class="number">0x20</span>;</span><br><span class="line">PCON = <span class="number">0x80</span>;</span><br><span class="line">TH1  = <span class="number">0xF3</span>;</span><br><span class="line">TL1  = <span class="number">0xF3</span>;</span><br><span class="line">ES   = <span class="number">1</span>;</span><br><span class="line">EA   = <span class="number">1</span>;</span><br><span class="line">TR1  = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SendUart</span><span class="params">(uchar value)</span></span>&#123;</span><br><span class="line">ES = <span class="number">0</span>;</span><br><span class="line">SBUF = value;</span><br><span class="line"><span class="keyword">while</span>(!TI);</span><br><span class="line">TI = <span class="number">0</span>;</span><br><span class="line">ES = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SendString</span><span class="params">(uchar *str)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span>(*str != <span class="string">'\0'</span>) &#123;</span><br><span class="line">SendUart(*str);</span><br><span class="line">str++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wificonnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">SendString(<span class="string">"AT\r\n"</span>);</span><br><span class="line"><span class="comment">//SendString("AT+CWMODE=1\r\n");</span></span><br><span class="line"><span class="comment">//SendString("AT+RST");</span></span><br><span class="line">SendString(<span class="string">"AT+CWJAP=\"****\",\"******\"\r\n"</span>);</span><br><span class="line">Delay600ms();</span><br><span class="line">Delay600ms();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TCPconnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">SendString(<span class="string">"AT+CIPMUX=0\r\n"</span>);</span><br><span class="line">Delay600ms();</span><br><span class="line">Delay600ms();</span><br><span class="line">SendString(<span class="string">"AT+CIPSTART=\"TCP\",\"183.230.40.33\",80\r\n"</span>);</span><br><span class="line">Delay600ms();</span><br><span class="line">Delay600ms();</span><br><span class="line">SendString(<span class="string">"AT+CIPMODE=1\r\n"</span>);</span><br><span class="line">Delay600ms();</span><br><span class="line">Delay600ms();</span><br><span class="line">SendString(<span class="string">"AT+CIPSEND\r\n"</span>);</span><br><span class="line">Delay600ms();</span><br><span class="line">Delay600ms();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">check</span><span class="params">()</span> </span>&#123;</span><br><span class="line">SendString(<span class="string">"GET /devices/******/datastreams/*** HTTP/1.1\r\n"</span>);</span><br><span class="line">SendString(<span class="string">"Host: api.heclouds.com\r\n"</span>);</span><br><span class="line">SendString(<span class="string">"api-key: ********************\r\n\r\n"</span>);</span><br><span class="line">Delay600ms(); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> UsartInit();</span><br><span class="line">wificonnection();</span><br><span class="line">TCPconnection();</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">check();</span><br><span class="line">Delay600ms();</span><br><span class="line"><span class="keyword">if</span>(value == <span class="string">'1'</span>) LED = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(value == <span class="string">'0'</span>) LED = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Usart</span><span class="params">()</span> interrupt 4 </span>&#123;</span><br><span class="line">uchar rec;</span><br><span class="line"><span class="keyword">if</span>(RI != <span class="number">0</span>) &#123;</span><br><span class="line">rec = SBUF;</span><br><span class="line">RI = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(rec == <span class="string">'&#123;'</span>) cnt = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(cnt == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(rec != <span class="string">'&#125;'</span>) &#123;</span><br><span class="line">recbuffer[datalen++] = rec;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">cnt = <span class="number">0</span>;</span><br><span class="line">value = recbuffer[datalen - <span class="number">1</span>];</span><br><span class="line"><span class="comment">//SendString(recbuffer);</span></span><br><span class="line"><span class="comment">//SendString("\r\n");</span></span><br><span class="line"><span class="comment">//SendUart(value);</span></span><br><span class="line"><span class="comment">//SendString("\r\nok\r\n");</span></span><br><span class="line">datalen = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> IoT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 物联网 </tag>
            
            <tag> ESP8266 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ESP8266--TCP连接</title>
      <link href="/2018/01/26/ESP8266%E2%80%94%E2%80%94TCP%E8%BF%9E%E6%8E%A5/"/>
      <url>/2018/01/26/ESP8266%E2%80%94%E2%80%94TCP%E8%BF%9E%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<p>﻿</p><p>这两天因为一个项目遗留问题，又玩了玩C51。做的是用ESP8266连接OneNet进行联网控制。<br>在淘宝购买的wifi模块，店家给的资料也实在是多，工具也很齐全。<br>首先wifi模块和C51是利用串口通信的，这就需要了解串口通信的知识。差不多一年前，我自己学过C51的一些基础知识，但是毕竟一年没有动了，有些生疏，也幸好的是，刚学完单片机这门课程，对串口通信的认识更加的深入了，所以回过头来看这些资料，感觉很轻松。</p><a id="more"></a><p>TXD（Transmit Data） 发送数据<br>RXD（Receive Data） 接受数据<br>值得注意的是，TXD、RXD在串口通信的时候需要外加参考电平。<br>下面是一些关于ESP8266的知识点。<br>ESP8266集成了AT指令，让我们开发起来更加的方便了许多。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AT\r\n       //响应ok</span><br></pre></td></tr></table></figure><p>Station模式。这个模式下ESP8266可以加入其他路由器的网络<br>AP模式，这个模式下ESP8266就相当于一个路由器，其他设备可以加入到这个模式中<br>Station+AP模式<br>在这里我用的Station模式。注意（更改模式后，需要发送指令<code>AT+RST\r\n</code>重启模块使其生效）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AT+CWMODE=1\r\n    //选择Station模式</span><br><span class="line">AT+CWMODE=2\r\n    //选择AP模式</span><br><span class="line">AT+CWMODE=3\r\n    //选择Station+AP模式</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AT+CWJAP\r\n       //查看当前可用wifi</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AT+CWJAP=&quot;ssid&quot;,&quot;pwd&quot;\r\n    //ssid是WiFi名称，pwd是WiFi密码，此条指令可以帮助esp8266连接wifi</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AT+CIPMUX=0\r\n选择单路连接模式</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AT+CIPSTART=&quot;TCP&quot;,&quot;host&quot;,port\r\n//host是你将要连接服务器的域名，port是端口号，与服务器建立TCP连接</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AT+CIPMODE=1\r\n //选择透传模式</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AT+CIPSEND\r\n//响应&gt;,便可以向服务器发送HTTP数据报</span><br></pre></td></tr></table></figure><p>下面是几条，调试的过程会用到的指令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AT+CWQAP\r\n   //退出与路由器的连接</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+++     //返回指令模式，此条指令用在已经AT+CIPSEND后面，可以辅助下面的指令断开与服务器的连接，注意没有换行</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AT+CIPCLOSE\r\n   //断开与服务器的连接</span><br></pre></td></tr></table></figure><p>陆续发送以上几条指令，不报错，就可以和服务器建立连接了。</p>]]></content>
      
      
      <categories>
          
          <category> IoT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 物联网 </tag>
            
            <tag> ESP8266 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FPGA--速度和面积的基本认识</title>
      <link href="/2018/01/22/FPGA%E2%80%94%E2%80%94%E9%80%9F%E5%BA%A6%E5%92%8C%E9%9D%A2%E7%A7%AF%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%86/"/>
      <url>/2018/01/22/FPGA%E2%80%94%E2%80%94%E9%80%9F%E5%BA%A6%E5%92%8C%E9%9D%A2%E7%A7%AF%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<p>速度是指整个工程稳定运行所能达到的最高时钟频率。<br>面积是值整个工程所需要的触发器、查找表或等效门的数量来衡量的。</p><pre><code>速度和面积是一对矛盾体，在追求速度的同时，必然会增大面积。在工程中，我们能做的只有在速度和面积中取最优的方案。之前在学习中，一直没有关注面积的问题，其实在我们资源有限的情况下，应该要注重面积的最小化。</code></pre>]]></content>
      
      
      <categories>
          
          <category> FPGA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FPGA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FPGA--关于状态机</title>
      <link href="/2018/01/19/FPGA%E2%80%94%E2%80%94%E5%85%B3%E4%BA%8E%E7%8A%B6%E6%80%81%E6%9C%BA/"/>
      <url>/2018/01/19/FPGA%E2%80%94%E2%80%94%E5%85%B3%E4%BA%8E%E7%8A%B6%E6%80%81%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<p>​    状态机，是我大二在实验室学习时，学长给我们安排的任务之一。那个时候，我还没有学过《数电》，一直搞不明白状态机的意思，做了一周，都没有结果。<br>任务是检测序列，检测到1011时输出一个高电平。</p><a id="more"></a><p>我们都知道verilog语言依靠不同的always语句块实现了硬件电路的并行执行，但是在工程中，我们不仅要处理并行执行电路，偶尔也会遇到需要串行执行的电路要求。刚开始学习FPGA的话，可能会想到我们可以利用很多很多的使能信号实现，但是这样维护的成本大大增加。状态机就可以完美的实现这一功能。先简单介绍一下状态机的基本概念。</p><p>状态机的基本要素是<strong>输入、输出和状态</strong>。输入是引起状态变化的条件，输出是状态变化引起的变化。状态就是字面理解的意思了，状态机，通俗的说就是因为输入导致状态在不断的变化的硬件电路。</p><p>Moore型状态机的输出仅与状态有关，与输入无关。<br>Mealy型状态机的输入不仅与状态有关，还与输入条件有关。<br>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Oq0qQTjK-1571226216451)(<a href="http://img.blog.csdn.net/20180119154529552?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQ2hlcmlzaF94/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)]" target="_blank" rel="noopener">http://img.blog.csdn.net/20180119154529552?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQ2hlcmlzaF94/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)]</a><br>一段式写法，输入、输出和状态在一个always语句块中，后期不容易维护。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> pro(</span><br><span class="line"><span class="keyword">input</span>clk,</span><br><span class="line"><span class="keyword">input</span>rst_n,</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span>data,</span><br><span class="line"><span class="keyword">output</span>cntout</span><br><span class="line">);</span><br><span class="line"><span class="keyword">parameter</span>INITIALSTATE = <span class="number">5'b00_001</span>,</span><br><span class="line">STATE_0 = <span class="number">5'b00_010</span>,</span><br><span class="line">STATE_1 = <span class="number">5'b00_100</span>,</span><br><span class="line">STATE_2 = <span class="number">5'b01_000</span>,</span><br><span class="line">STATE_3 = <span class="number">5'b10_000</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//————————————————————————————————————————————</span></span><br><span class="line"><span class="comment">//一段式写法, 既把输入、输出和状态写在一个always语句块</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span>[<span class="number">4</span>:<span class="number">0</span>]state_ce;<span class="comment">//状态寄存器</span></span><br><span class="line"><span class="keyword">reg</span>cnt;</span><br><span class="line"><span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)<span class="keyword">begin</span></span><br><span class="line"><span class="keyword">if</span>(!rst_n)<span class="keyword">begin</span></span><br><span class="line">cnt &lt;= <span class="number">1'b0</span>;</span><br><span class="line">state_ce &lt;= INITIALSTATE;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">case</span>(state_ce)</span><br><span class="line">INITIALSTATE:<span class="keyword">begin</span></span><br><span class="line">cnt &lt;= <span class="number">1'b0</span>;</span><br><span class="line"><span class="keyword">if</span>(data == <span class="number">1'b1</span>)</span><br><span class="line">state_ce &lt;= STATE_0;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">state_ce &lt;= INITIALSTATE;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">STATE_0:<span class="keyword">if</span>(data == <span class="number">1'b0</span>)</span><br><span class="line">state_ce &lt;= STATE_1;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">state_ce &lt;= STATE_0;</span><br><span class="line">STATE_1:<span class="keyword">if</span>(data == <span class="number">1'b1</span>)</span><br><span class="line">state_ce &lt;= STATE_2;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">state_ce &lt;= INITIALSTATE;</span><br><span class="line">STATE_2:<span class="keyword">if</span>(data == <span class="number">1'b1</span>)</span><br><span class="line">state_ce &lt;= STATE_3;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">state_ce &lt;= STATE_1;</span><br><span class="line">STATE_3:<span class="keyword">begin</span></span><br><span class="line">state_ce &lt;= INITIALSTATE;</span><br><span class="line">cnt &lt;= <span class="number">1'b1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span>cntout = cnt;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><p>[外链图片转存中…(img-CLvmuOJa-1571226216454)]</p><p>二段式写法，分成了组合逻辑和时序逻辑。时序逻辑里作状态的转移，组合逻辑里作输入条件判断和输出。但是组合逻辑输出容易出现毛刺问题。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> pro(</span><br><span class="line"><span class="keyword">input</span>clk,</span><br><span class="line"><span class="keyword">input</span>rst_n,</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span>data,</span><br><span class="line"><span class="keyword">output</span>cntout</span><br><span class="line">);</span><br><span class="line"><span class="keyword">parameter</span>INITIALSTATE = <span class="number">5'b00_001</span>,</span><br><span class="line">STATE_0 = <span class="number">5'b00_010</span>,</span><br><span class="line">STATE_1 = <span class="number">5'b00_100</span>,</span><br><span class="line">STATE_2 = <span class="number">5'b01_000</span>,</span><br><span class="line">STATE_3 = <span class="number">5'b10_000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span>[<span class="number">4</span>:<span class="number">0</span>]state_ce;</span><br><span class="line"><span class="keyword">reg</span>[<span class="number">4</span>:<span class="number">0</span>]state_nt;</span><br><span class="line"><span class="keyword">reg</span>cnt;</span><br><span class="line"><span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)<span class="keyword">begin</span></span><br><span class="line"><span class="keyword">if</span>(!rst_n)</span><br><span class="line">state_ce &lt;= INITIALSTATE;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">state_ce &lt;= state_nt;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @ (state_ce <span class="keyword">or</span> data)<span class="keyword">begin</span></span><br><span class="line"><span class="keyword">case</span>(state_ce)</span><br><span class="line">INITIALSTATE:<span class="keyword">begin</span></span><br><span class="line">cnt = <span class="number">1'b0</span>;</span><br><span class="line"><span class="keyword">if</span>(data == <span class="number">1'b1</span>)</span><br><span class="line">state_nt = STATE_0;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">state_nt = INITIALSTATE;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">STATE_0:<span class="keyword">begin</span></span><br><span class="line">cnt = <span class="number">1'b0</span>;</span><br><span class="line"><span class="keyword">if</span>(data == <span class="number">1'b0</span>)</span><br><span class="line">state_nt = STATE_1;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">state_nt = STATE_0;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">STATE_1:<span class="keyword">begin</span></span><br><span class="line">cnt = <span class="number">1'b0</span>;</span><br><span class="line"><span class="keyword">if</span>(data == <span class="number">1'b1</span>)</span><br><span class="line">state_nt = STATE_2;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">state_nt = INITIALSTATE;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">STATE_2:<span class="keyword">begin</span></span><br><span class="line"><span class="keyword">if</span>(data == <span class="number">1'b1</span>)</span><br><span class="line">state_nt= STATE_3;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">state_nt =STATE_1;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">STATE_3:<span class="keyword">begin</span></span><br><span class="line">cnt = <span class="number">1'b1</span>;</span><br><span class="line">state_nt = INITIALSTATE;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span>cntout = cnt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><p>三段式写法，又将输出写作时序逻辑输出，解决了二段式中毛刺的问题。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> pro(</span><br><span class="line"><span class="keyword">input</span>clk,</span><br><span class="line"><span class="keyword">input</span>rst_n,</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span>data,</span><br><span class="line"><span class="keyword">output</span>cntout</span><br><span class="line">);</span><br><span class="line"><span class="keyword">parameter</span>INITIALSTATE = <span class="number">5'b00_001</span>,</span><br><span class="line">STATE_0 = <span class="number">5'b00_010</span>,</span><br><span class="line">STATE_1 = <span class="number">5'b00_100</span>,</span><br><span class="line">STATE_2 = <span class="number">5'b01_000</span>,</span><br><span class="line">STATE_3 = <span class="number">5'b10_000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span>[<span class="number">4</span>:<span class="number">0</span>]state_ce;</span><br><span class="line"><span class="keyword">reg</span>[<span class="number">4</span>:<span class="number">0</span>]state_nt;</span><br><span class="line"><span class="keyword">reg</span>cnt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)<span class="keyword">begin</span></span><br><span class="line"><span class="keyword">if</span>(!rst_n)</span><br><span class="line">state_ce &lt;= INITIALSTATE;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">state_ce &lt;= state_nt;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @ (state_ce <span class="keyword">or</span> data)<span class="keyword">begin</span></span><br><span class="line"><span class="keyword">case</span>(state_ce)</span><br><span class="line">INITIALSTATE:<span class="keyword">if</span>(data == <span class="number">1'b1</span>)</span><br><span class="line">state_nt = STATE_0;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">state_nt = INITIALSTATE;</span><br><span class="line">STATE_0:<span class="keyword">if</span>(data == <span class="number">1'b0</span>)</span><br><span class="line">state_nt = STATE_1;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">state_nt = STATE_0;</span><br><span class="line">STATE_1:<span class="keyword">if</span>(data == <span class="number">1'b1</span>)</span><br><span class="line">state_nt = STATE_2;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">state_nt = INITIALSTATE;</span><br><span class="line">STATE_2:<span class="keyword">if</span>(data == <span class="number">1'b1</span>)</span><br><span class="line">state_nt = STATE_3;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">state_nt = STATE_2;</span><br><span class="line">STATE_3:  state_nt = INITIALSTATE;</span><br><span class="line"><span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)<span class="keyword">begin</span></span><br><span class="line"><span class="keyword">if</span>(!rst_n)</span><br><span class="line">cnt &lt;= <span class="number">'d0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(state_nt == STATE_3)</span><br><span class="line">cnt &lt;= <span class="number">1'b1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cnt &lt;= <span class="number">1'b0</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span>cntout = cnt;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> FPGA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FPGA </tag>
            
            <tag> 状态机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FPGA--inout的用法</title>
      <link href="/2018/01/16/FPGA%E2%80%94%E2%80%94inout%E7%9A%84%E7%94%A8%E6%B3%95/"/>
      <url>/2018/01/16/FPGA%E2%80%94%E2%80%94inout%E7%9A%84%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>﻿inout，顾名思义，也就是这个端口既可以输入数据也可以输出数据，但是他有一个规则：当他做输入端口时，一定要置为高阻态。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span>out_data;</span><br><span class="line"><span class="keyword">reg</span>test_cnt;<span class="comment">//test端口输入\输入方向控制位，1  输入  0  输出</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span>test = test_cnt ? <span class="number">1'bz</span> : out_data;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> FPGA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FPGA </tag>
            
            <tag> inout </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FPGA--for循环的些许思考</title>
      <link href="/2018/01/16/FPGA%E2%80%94%E2%80%94for%E5%BE%AA%E7%8E%AF%E7%9A%84%E4%BA%9B%E8%AE%B8%E6%80%9D%E8%80%83/"/>
      <url>/2018/01/16/FPGA%E2%80%94%E2%80%94for%E5%BE%AA%E7%8E%AF%E7%9A%84%E4%BA%9B%E8%AE%B8%E6%80%9D%E8%80%83/</url>
      
        <content type="html"><![CDATA[<p>​        以前的学习的时候，没有用过verilog中的for循环。在数字电路的课堂上，也经常会想循环电路到底是一个什么样的电路呢？在我的脑海中，感觉循环电路就像那种重复利用已知电路的电路，我是这样理解的：for循环语句块中的执行语句是一样的，其生成的电路也是一样的，这个电路我把 它交做执行电路。那么循环电路是不是就是根据条件判断运行执行电路呢，就是那种类似于负反馈电路。根据执行电路输出的一个结果来决定下次 是否要还要继续运行执行电路。</p><a id="more"></a><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> Pro(</span><br><span class="line"><span class="keyword">input</span>clk,</span><br><span class="line"><span class="keyword">input</span>rst_n,</span><br><span class="line"><span class="keyword">input</span>[<span class="number">12</span>:<span class="number">0</span>]data,</span><br><span class="line"><span class="keyword">output</span>[<span class="number">3</span>:<span class="number">0</span>]numout</span><br><span class="line">);</span><br><span class="line"><span class="keyword">reg</span>[<span class="number">3</span>:<span class="number">0</span>]i;</span><br><span class="line"><span class="keyword">reg</span>[<span class="number">3</span>:<span class="number">0</span>]num;</span><br><span class="line"><span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)<span class="keyword">begin</span></span><br><span class="line"><span class="keyword">if</span>(!rst_n)<span class="keyword">begin</span></span><br><span class="line">num = <span class="number">'d0</span>;</span><br><span class="line">i = <span class="number">'d0</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">else</span><span class="keyword">begin</span></span><br><span class="line">num = <span class="number">'d0</span>;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">'d0</span>;i &lt;= <span class="number">12</span>;i = i + <span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span>(data[i])</span><br><span class="line">num = num + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span>numout = num;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><p>for循环生成的RTL图如下：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTgwMTE2MjAyMTQyOTA5?x-oss-process=image/format,png" alt="这里写图片描述"><br>一个时钟周期检测一次的RTL图如下：<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTgwMTE2MjAyNjEwNTg4?x-oss-process=image/format,png" alt="这里写图片描述"><br>    事实结果和我想的相差太远，反而是一个时钟周期检测一次的电路和我想的一样。我们可以看到for循环电路虽然节省了时间，但是占用的资源也明显较多。<br>    在实际应用中，我们到底应该不应该大胆的使用for循环呢？<br>    我自己的观点：当你只考虑速度而不关心电路的话，是可以使用for循环的。</p>]]></content>
      
      
      <categories>
          
          <category> FPGA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FPGA </tag>
            
            <tag> for循环 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模拟登录知乎</title>
      <link href="/2017/09/09/%E7%94%A8python%E5%81%9A%E6%9C%89%E8%B6%A3%E7%9A%84%E4%BA%8B%E5%84%BF%E2%80%94%E2%80%94%E6%A8%A1%E6%8B%9F%E7%99%BB%E9%99%86%E7%9F%A5%E4%B9%8E/"/>
      <url>/2017/09/09/%E7%94%A8python%E5%81%9A%E6%9C%89%E8%B6%A3%E7%9A%84%E4%BA%8B%E5%84%BF%E2%80%94%E2%80%94%E6%A8%A1%E6%8B%9F%E7%99%BB%E9%99%86%E7%9F%A5%E4%B9%8E/</url>
      
        <content type="html"><![CDATA[<p><font face="宋体" size="4">  用Python做网络数据采集，是非常方便的。特别是使用第三方库requests。<br>    window下安装方法         pip install requests<br>    处理网页超文本信息，使用第三方库BeautifulSoup，也是很方便。<br>    window下安装方法         pip install beautifulsoup4<br>    通常会用到的是requests.get()和requests.post()。</font></p><a id="more"></a><p>其他的，当你需要的时候去官方文档是最好的捷径。<br>    我们处理的还是HTML，了解一些HTML是必须的，起码得知道标签，属性，属性值等等，只有这样我们才能在一堆信息里提取出我们想要得信息。<br>    最近在看《Python网络数据采集》，打算拿知乎当作练手的网站（心疼知乎-。-）。知乎毕竟是企业级的网站，在模拟登录的时候遇到了很多挫折，对，就是挫折，前几天因为一直登录不上还放弃过（呸，丢人的家伙）。今天不经意的在书中看到隐藏字段，恍然大悟。原来知乎的表单里有隐藏字段啊。<br>   通过BeautifulSoup过滤出隐藏字段，然后post，但是还是不能登录成功，很恼火。逼不得已上网看了别人的源码，竟然有验证码，我在知乎的网页端没看见啊，所以我把验证码的这快程序加上，结果，，，，登录成功。好吧，知乎你赢了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">Info</span><br><span class="line">- auther  : Cherish_x</span><br><span class="line">- qq      : 344799672</span><br><span class="line">- data    : 2017.9.8</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">import re</span><br><span class="line">import time</span><br><span class="line">import requests</span><br><span class="line">from io import BytesIO</span><br><span class="line">from PIL import Image</span><br><span class="line">from bs4 import BeautifulSoup</span><br><span class="line"></span><br><span class="line">loadpost_url = &apos;https://www.zhihu.com/login/phone_num&apos;</span><br><span class="line">load_url = &apos;https://www.zhihu.com/#signin&apos;</span><br><span class="line">agent = &apos;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.104 Safari/537.36&apos;</span><br><span class="line">headers = &#123;</span><br><span class="line">    &apos;User-Agent&apos;: agent,</span><br><span class="line">    &apos;Referer&apos;: &apos;https://www.zhihu.com/&apos;,</span><br><span class="line">    &apos;Host&apos;: &apos;www.zhihu.com&apos;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">FormData = &#123;</span><br><span class="line">    &apos;_xsrf&apos;: &apos;&apos;,</span><br><span class="line">    &apos;password&apos;: &apos;xu344799672&apos;,</span><br><span class="line">    &apos;phone_num&apos;: &apos;17853530696&apos;</span><br><span class="line">&#125;</span><br><span class="line">#———————————————————————————————————————————————————————————</span><br><span class="line">#       模拟登陆知乎</span><br><span class="line">def anaLoad(load_url, loadpost_url, headers, FormData):</span><br><span class="line">    #—————————————————————————————————————————————————————————</span><br><span class="line">    #   保持会话信息</span><br><span class="line">    session = requests.session()</span><br><span class="line">    #—————————————————————————————————————————————————————————</span><br><span class="line">    #   获取动态参数_xsrf</span><br><span class="line">    r = session.get(load_url, headers=headers)</span><br><span class="line">    _xsrf = r.cookies[&apos;_xsrf&apos;]</span><br><span class="line">    FormData[&apos;_xsrf&apos;] = _xsrf</span><br><span class="line">    #—————————————————————————————————————————————————————————</span><br><span class="line">    #   获取验证码，并以照片的形式打开，手动输入</span><br><span class="line">    randomtime = str(int(time.time() * 1000))</span><br><span class="line">    captchaurl = &apos;https://www.zhihu.com/captcha.gif?r=&apos; + \</span><br><span class="line">                 randomtime + &quot;&amp;type=login&quot;</span><br><span class="line">    captcharesponse = session.get(url=captchaurl, headers=headers)</span><br><span class="line">    tempIm = BytesIO(captcharesponse.content)  # 将数据流放入tempIm以字节的形式</span><br><span class="line">    im = Image.open(tempIm)  # 转换为图片的形式</span><br><span class="line">    im.show()  # 打开</span><br><span class="line">    captch = input(&apos;Please input coding:&apos;)</span><br><span class="line">    #—————————————————————————————————————————————————————————</span><br><span class="line">    #   登录</span><br><span class="line">    FormData[&apos;captcha&apos;] =captch</span><br><span class="line">    posthtml = session.post(loadpost_url, data=FormData, headers=headers)</span><br><span class="line">    #print(posthtml.cookies)</span><br><span class="line">    msg = eval(posthtml.text)#  转为字典格式</span><br><span class="line">    print(msg[&apos;msg&apos;])</span><br><span class="line">    return session  #返回会话信息，以备下次使用</span><br><span class="line"></span><br><span class="line">#———————————————————————————————————————————————————————————</span><br><span class="line">#   跳转知乎内链</span><br><span class="line">def throughUrl(session, headers):</span><br><span class="line">    urlList = []</span><br><span class="line">    r = session.get(&apos;https://www.zhihu.com/#signin&apos;, headers=headers)</span><br><span class="line">    bs0bj = BeautifulSoup(r.text, &apos;html.parser&apos;)</span><br><span class="line">    Text = bs0bj.findAll(&apos;meta&apos;, &#123;&apos;itemprop&apos;: &apos;url&apos;&#125;)</span><br><span class="line">    for i in Text:</span><br><span class="line">        i = i.attrs[&apos;content&apos;]</span><br><span class="line">        if i not in urlList and &apos;www.zhihu.com&apos; in i:#  去重、去外链（知乎专栏，不能跳转，待解决）</span><br><span class="line">            urlList.append(i)</span><br><span class="line">            accessUrl(session, i, headers, urlList)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#———————————————————————————————————————————————————————————</span><br><span class="line">#   访问链接</span><br><span class="line">def accessUrl(session, url, headers, urlList):</span><br><span class="line">    r = session.get(url, headers=headers)</span><br><span class="line">    bs0bj = BeautifulSoup(r.text, &apos;html.parser&apos;)</span><br><span class="line">    #text = bs0bj.findAll(&apos;span&apos;, &#123;&apos;itemprop&apos;: &apos;text&apos;&#125;)</span><br><span class="line">    text = bs0bj.findAll(&apos;meta&apos;, &#123;&apos;itemprop&apos;: &apos;name&apos;&#125;)</span><br><span class="line">    print(text)</span><br><span class="line">    print(&apos;——————————————————————————————————————————————————&apos;)</span><br><span class="line">    html = bs0bj.findAll(&apos;meta&apos;, &#123;&apos;itemprop&apos;: &apos;url&apos;&#125;)#  寻找链接所在</span><br><span class="line">    for i in html:</span><br><span class="line">        i = i.attrs[&apos;content&apos;]</span><br><span class="line">        if i not in urlList and &apos;www.zhihu.com&apos; in i:#  去重、去外链（知乎专栏，不能跳转，待解决）</span><br><span class="line">            urlList.append(i)</span><br><span class="line">            time.sleep(3)</span><br><span class="line">            accessUrl(session, i, headers, urlList)</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    session = anaLoad(load_url, loadpost_url, headers, FormData)</span><br><span class="line">    throughUrl(session, headers)</span><br></pre></td></tr></table></figure><p>&lt;font face = ‘宋体’， size = 4&gt;    目前实现了模拟登陆知乎，遍历采集的知乎内链（去重检查），值得注意的是，一定要有延时，应为知乎的防爬意识很严肃，在调试程序的时候，我就经常被知乎封ip，此时需要用网页登录一次输入验证码即可。    </p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>将.py文件打包为.exe</title>
      <link href="/2017/08/30/%E7%94%A8Python%E5%81%9A%E6%9C%89%E8%B6%A3%E7%9A%84%E4%BA%8B%E5%84%BF%E2%80%94%E2%80%94%E6%89%93%E5%8C%85%E7%A8%8B%E5%BA%8F%E4%B8%BA.exe/"/>
      <url>/2017/08/30/%E7%94%A8Python%E5%81%9A%E6%9C%89%E8%B6%A3%E7%9A%84%E4%BA%8B%E5%84%BF%E2%80%94%E2%80%94%E6%89%93%E5%8C%85%E7%A8%8B%E5%BA%8F%E4%B8%BA.exe/</url>
      
        <content type="html"><![CDATA[<p>﻿<font face="宋体" size="4">     Python作为一种脚本语言，我们在学习的时候，会发现，用编辑器码完代码后，生成的不是.exe文件，这点和C语言不同，生成的是.py文件，想要运行就必须在有安装Python的环境下，执行.py。写好一个脚本想给别人用，就得把它打包为.exe文件。<br>    我选择使用pyinstaller第三方。</font></p><a id="more"></a><p>​    pip下载方法：pip install pyinstaller<br>​    使用方法：在cmd命令行下，打开待打包的.py文件目录，<br>​    执行命令，pyinstaller –F (yourPro).py，会生成单个可执行文件<br>​              pyinstaller – key (password)，加密你的代码，实测还需要一个第三方PyCryto，这个第三方又需要ＶＣ＋＋２０１５，挺麻烦的，也就没试过这条命令行。<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwODMwMTQ1OTE3MTIy?x-oss-process=image/format,png" alt="这里写图片描述"><br>​    上一张成品图，目前版本的脚本，实现了查询当前已抽中课程信息并打印，查询培养方案的课程信息，比较两个信息，寻找为抽中的课程，检查未抽中课程的课余量，如果课余量大于0，自动帮用户 选上。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模拟登录学校教务系统</title>
      <link href="/2017/08/29/%E7%94%A8Python%E5%81%9A%E6%9C%89%E8%B6%A3%E7%9A%84%E4%BA%8B%E5%84%BF%E2%80%94%E2%80%94%E6%A8%A1%E6%8B%9F%E7%99%BB%E9%99%86%E5%AD%A6%E6%A0%A1%E6%95%99%E5%8A%A1%E7%B3%BB%E7%BB%9F/"/>
      <url>/2017/08/29/%E7%94%A8Python%E5%81%9A%E6%9C%89%E8%B6%A3%E7%9A%84%E4%BA%8B%E5%84%BF%E2%80%94%E2%80%94%E6%A8%A1%E6%8B%9F%E7%99%BB%E9%99%86%E5%AD%A6%E6%A0%A1%E6%95%99%E5%8A%A1%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p> HTTP，说白了就是用Post，Get获取信息。选课，咱们得先登录学校的教务系统啊，所以用<strong>谷歌浏览器</strong>观察当我们登录教务系统的时候，网页干了什么。在登录页面，按F12，打开开发者工具，假装登录一下。</p><a id="more"></a><p>   我们发现当我们登录的时候，网页带着数据Post了一下，我们只要模仿这个Post，就可以登录啦，是不是特别简单。<br>    但是我们发现，有验证码啊，这个就是用来鉴别登录的用户是人还是机器人。这个识别验证码，大家可以用python的图像处理的一些第三方处理试试，我是直接把图片提取出来，然后人工输入的。<br>   也就是说，我们获取了验证码后，再把账号，密码，验证码给Post上去。一来一去，我们就访问了两次服务器，但是我们得让服务器知道这两次访问都是来自同一个ip的，否则验证码就变了，我们也就不能成功Post了。这个时候，cookies就帮了大忙，她可以帮助我们使得两次访问是同一个会话，怎么保持cookies，Python的第三方库requerts可就十分强大了，session = requests.session()，就可以帮助我们建立一个会话，保持会话信息。<br>好了，废话不多说了，直接上。<br>   我用的Python3.5，一开始用的Python3.6，可是不能打包成exe文件，就退回了Pyhton3.5。编辑器用的Pycharm，个人观点这是一款非常棒的编辑器。<br>   首先，安装需要的第三方库。BeautifulSoup（和正则一起用，还不是爽歪歪）、requests（让HTTP服务于人类）和PIL（图像处理的一个第三方，我用它把扒取的验证码打开，然后人工输入）。如果你安装的Python3，也就自动安装了pip（用pip不是更简单吗？）<br>   三个第三方的pip下载方法：pip install beautifulsoup4<br>                            pip install requests<br>                            pip install Pillow<br>                              以我们学校的教务系统为例。打开开发者工具，点击Network，然后账号，密码，验证码瞎打点登录，就会在右边看见在登录的时候发生了什么。<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwODI5MjExNzM1ODAy?x-oss-process=image/format,png" alt="这里写图片描述">   找到一个跟登录有关的.do文件，选择headers，会看到她往一个网址(Request URL，这个url暂定义为post_url)post了一下，请求表头（Requests Headers）也在这里，里面就有咱需要的cookies，需要关注一点Referer，这里必须从Referer一栏的网址跳到这里才行。大家可以先试下不跳会怎么样，因为每个教务系统都是不一样的，不需要跳转的，就直接Post就好了。<img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwODI5MjEzMDI0Mzg0?x-oss-process=image/format,png" alt="这里写图片描述">    下拉会看到在Post的数据，分别是账号，密码，验证码，其他的可能会有别的参数，应该只有 这三个是变得。我只需要在Post的时候将数据也带上就行了。不得不说，Python3的第三方库requests实在强大，甚至暴力，又有点小清新<img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwODI5MjEzMzM5MjA0?x-oss-process=image/format,png" alt="这里写图片描述">。    点击Preview，然后挨个选择Name下的文件，找到出现验证码的一个。像下图。<img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwODI5MjEzNTM3NzUy?x-oss-process=image/format,png" alt="这里写图片描述">    再点回Headers可以看到登录的时候验证码是怎么来的，Requests URL就是我们要获取验证码而Get的url，只取红线的部分（暂定义为yzm_url）即可，后面就是唬人的。在表头那块我们可以看到Referer是loginAction.do的url。<img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwODI5MjE0MTA1Mjg5?x-oss-process=image/format,png" alt="这里写图片描述">    所以思路就来了，我们可以先访问post_url，拿到cookies后，利用session保持会话，访问yzm_url，获得验证码后，再将账号、密码和验证码Post到post_url。至此我们就可以模拟登陆教务系统了。<br>   下面直接贴核心代码了（支持开源）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">            session = requests.session()  <span class="comment"># 建立会话，保持会话信息，cookies</span></span><br><span class="line">            r = session.get(post_url)</span><br><span class="line">            cookies = r.headers[<span class="string">'Set-Cookie'</span>]  <span class="comment"># 获取cookies</span></span><br><span class="line">            cookies = cookies.strip(<span class="string">'; path=/'</span>)  </span><br><span class="line">            yam_headers = &#123;</span><br><span class="line">                <span class="string">'Accept'</span>: <span class="string">'image/webp,image/apng,image/*,*/*;q=0.8'</span>,</span><br><span class="line">                <span class="string">'Accept-Encoding'</span>: <span class="string">'gzip, deflate'</span>,</span><br><span class="line">                <span class="string">'Accept-Language'</span>: <span class="string">'zh-CN,zh;q=0.8'</span>,</span><br><span class="line">                <span class="string">'Connection'</span>: <span class="string">'keep-alive'</span>,</span><br><span class="line">                <span class="string">'Cookie'</span>: cookies,</span><br><span class="line">                <span class="string">'Host'</span>: <span class="string">'************'</span></span><br><span class="line">                <span class="string">'Referer'</span>:<span class="string">'*************'</span> </span><br><span class="line">                <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.104 Safari/537.36'</span></span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">#这是获取验证码的表头，这里的链接通google浏览器的开发者工具，按照前面说的去找。</span></span><br><span class="line">            yamdata = session.get(yzm_url, headers=yam_headers)  <span class="comment"># 获取验证码</span></span><br><span class="line">            tempIm = BytesIO(yamdata.content)  <span class="comment"># 将数据流放入tempIm以字节的形式</span></span><br><span class="line">            im = Image.open(tempIm)  <span class="comment"># 转换为图片的形式</span></span><br><span class="line">            im.show()  <span class="comment"># 展示验证码</span></span><br><span class="line">            Code = input(<span class="string">'Please Enter Code:'</span>)</span><br><span class="line">            logindata[<span class="string">'v_yzm'</span>] = Code</span><br><span class="line">            login_headers = &#123;</span><br><span class="line">                <span class="string">'Accept'</span>: <span class="string">'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8'</span>,</span><br><span class="line">                <span class="string">'Accept-Encoding'</span>: <span class="string">'gzip, deflate'</span>,</span><br><span class="line">                <span class="string">'Accept-Language'</span>: <span class="string">'zh-CN,zh;q=0.8'</span>,</span><br><span class="line">                <span class="string">'Cache-Control'</span>: <span class="string">'max-age=0'</span>,</span><br><span class="line">                <span class="string">'Connection'</span>: <span class="string">'keep-alive'</span>,</span><br><span class="line">                <span class="string">'Content-Length'</span>: <span class="string">'37'</span>,</span><br><span class="line">                <span class="string">'Content-Type'</span>: <span class="string">'application/x-www-form-urlencoded'</span>,</span><br><span class="line">                <span class="string">'Cookie'</span>: <span class="string">''</span>,</span><br><span class="line">                <span class="string">'Host'</span>: <span class="string">'***********'</span></span><br><span class="line">                <span class="string">'Origin'</span>: <span class="string">'*********'</span></span><br><span class="line">                <span class="string">'Referer'</span>: <span class="string">'***********'</span></span><br><span class="line">                <span class="string">'Upgrade-Insecure-Requests'</span>: <span class="string">'1'</span>,</span><br><span class="line">                <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.104 Safari/537.36'</span></span><br><span class="line">            &#125;</span><br><span class="line">            login_headers[<span class="string">'Cookie'</span>] = cookies</span><br><span class="line">            d = session.post(post_url, data=logindata, headers=login_headers)<span class="comment">#将账号，密码，验证码和表头Post上去，然后我们可以用过BeautifulSoup或者正则表达式，抓取d.text有用的信息，判断是否登录成功。</span></span><br></pre></td></tr></table></figure><pre><code>&lt;font face = &quot;宋体&quot; size = 4&gt; 我们成功模拟登陆教务系统后，就可以做一些我我们想做的事情了，例如抢课。模拟登陆搞明白了，抢课也就很简单了，就是Get或者Post的而已，我浪费了很多时间和代码在处理文本信息上。因为每个学校的教务系统不一样，所以就不贴代码了。</code></pre><p>​    </p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简易频谱分析仪和频率特性测试仪的原理</title>
      <link href="/2017/08/04/%E7%AE%80%E6%98%93%E9%A2%91%E8%B0%B1%E5%88%86%E6%9E%90%E4%BB%AA%E5%92%8C%E9%A2%91%E7%8E%87%E7%89%B9%E6%80%A7%E6%B5%8B%E8%AF%95%E4%BB%AA%E7%9A%84%E5%8E%9F%E7%90%86/"/>
      <url>/2017/08/04/%E7%AE%80%E6%98%93%E9%A2%91%E8%B0%B1%E5%88%86%E6%9E%90%E4%BB%AA%E5%92%8C%E9%A2%91%E7%8E%87%E7%89%B9%E6%80%A7%E6%B5%8B%E8%AF%95%E4%BB%AA%E7%9A%84%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>﻿<font face="楷体" size="5">   17年电赛的元器件清单下来了,基本仪器有频率特性测试仪，且13年国赛出现过，15年国赛也出现过频谱分析仪，知乎上有人猜测今年依然会出频域测量的题，这几天我就找了不少资料。了解了频谱分析仪和频率特性测试仪的原理。 </font><br>—————————————————————————————————————————————————————</p><a id="more"></a><p><font face="宋体" size="5"><strong>频谱分析仪</strong> </font><br><font face="宋体" size="4">     频谱分析仪主要用来分析信号中各频率成分。主要有多滤波器并行分析式、扫频外差分析式和FFT分析式。但是电赛做简易频谱分析仪我们常用扫频法。多滤波器并行分析太依赖硬件，在做测量仪器中，硬件的难度已经很大了。FFT分析式太依赖AD采样速率，像15年的赛题，做80M~100M，如果想用FFT做就要求AD芯片的采样速率可以达到200M以上。如果想采用等效采样法需要产生待分析信号的同频率的方波，才能精准的产生等效采样的时钟信号（至少我们现在掌握的技术，刚才请教了我们队的硬件，需要特定的芯片去转换）。<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwODA0MTAzNjQ5MDIx?x-oss-process=image/format,png" alt="这里写图片描述"></font><br><font face="宋体" size="4">    被测信号可能会有N个频谱分量，但利用一个<strong>频率连续扫动</strong>的扫频本地振荡器（扫频本振）产生的频率fL与被测信号混频，这样被测信号的第n个频谱分量总会有机会落入中频滤波器的通带中。通常令本地振荡的幅度保持不变，这时混频器的输出及经滤波后输出、显示都依次与被测信号的频谱分量的幅度成正比。检波后可在Y方向显示该频谱分量的大小。<br>    图中的扫频本振的输出频率是受扫描电压发生器控制的。若线性扫频，那扫描电压的幅度及扫频发生器的输出频率呈线性变化。我们可以直接把扫描电压用来驱动显示器光点在X方向移动，并把横轴直接用被测信号谱线的频率来刻度。<br> <strong>频谱分析仪的主要技术指标</strong><br>     <strong>1、有效频率范围</strong>是指在满足仪器性能指标的情况下，仪器能分析的最宽频率范围。在扫频外差式分析仪中，有效频率范围是指<strong>滤波器能选出的信号最低频率至最高频率。</strong><br>      <strong>2、频率相对误差</strong>是所有与频率相关仪器测量结果的基本保障，它对频谱仪是很重要的。<br>      <strong>3、灵敏度</strong> 用来表征在给定的其他指标条件下，频谱仪能测量最小信号的能力。<br>      <strong>4、分析时间或扫描时间</strong>，分析时间是指进行一次频谱分析所用的时间。对于扫频外差式分析仪分析时间实际上常指扫描或晨扫频时间，既显示器上扫描线从最左端扫到最右端所用的时间，应保证中频滤波器的动态特性不能因扫速过快而变坏。  </font><br> <font face="楷体" size="5"><strong>频率特性测试仪</strong> </font><br> <font face="宋体" size="4">   频率特性的测量有很多方法。其分类可以是正弦波点频测量，也可以是扫频测量；可以是直接法测量，也可以是比较法或称比值法测量；可以只反映幅值的增益或衰减，也可以既反映幅频特性又反映相频特性等。<br>     <strong>点频法</strong>既是将正弦信号被调至一个个频率点进行测量。<br>     <strong>扫频法</strong>是指采用一定方法使正弦信号的输出频率能随时间在一定范围内扫描。（个人理解和扫频外差式频谱分析仪差不多，一个是信号源经过系统，一个是和待测信号混频）<br>———————————————————————————————————————————————<br>    以上主要内容摘自《电子测量》第三版。侵删。  </font></p>]]></content>
      
      
      <categories>
          
          <category> FPGA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 电赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FFT频率和实际物理频率的分析</title>
      <link href="/2017/07/31/FFT%E9%A2%91%E7%8E%87%E5%92%8C%E5%AE%9E%E9%99%85%E7%89%A9%E7%90%86%E9%A2%91%E7%8E%87%E7%9A%84%E5%88%86%E6%9E%90/"/>
      <url>/2017/07/31/FFT%E9%A2%91%E7%8E%87%E5%92%8C%E5%AE%9E%E9%99%85%E7%89%A9%E7%90%86%E9%A2%91%E7%8E%87%E7%9A%84%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p><font face="楷体" size="5">之前有转载过一篇关于频谱分析的博客，今天想利用FPGA做FFT的有关计算，仔细查看了那篇博客发现原博主写的是一塌糊涂，被逼无奈拿起前几周考完期末考的《数字信号处理》，同时网上也有查资料，终于有一点思路了。</font><br>————————————————————————————————————————————</p><a id="more"></a><p><font face="宋体" size="4">FFT是快速傅里叶变换，是离散傅里叶变换的快速算法。我们想要利用FFT计算频率或者观察频谱特性，离不开DFT的定义和性质。先简单介绍三个名词。</font></p><p>[外链图片转存中…(img-Y1SwIZJR-1571226079885)]</p><p><font face="宋体" size="4">f 是实际物理频率，表示<strong>AD采集物理模拟信号的频率</strong>，Fs就是<strong>采样频率</strong>，根据<strong>奈奎斯特采样定理</strong>可以知道，Fs必须≥信号最高频率的2倍才能避免产生<strong>频谱混叠</strong>，也就是说用Fs做采样频率，信号的最高频率为Fs/2。<br>Ω称为模拟频率。ω称为数字频率。二者的关系<strong>ω = Ω/Fs</strong>。<br>假设x(n)的N点离散傅立叶变换为X(k),由定义式可以推出X(k)为x(n)的傅里叶变换X(e^jw)在区间[0,2π]上的N点等间隔采样，这也是DFT的物理意义。DFT的变换区间长度N不同，表示对傅里叶变换X(e^jw)在区间[0,2π]上的采样间隔和采样点数不同。N点DFT的结果还是N点。<br>我们通常只关心0<del>π的频谱，这是由于只有f = Fs/2范围内才是被采样到的有效信号。也既在ω的范围内得到的频谱是对称。</del></font><br><font face="宋体" size="4">举一个简单的例子，如果做16点DFT，假设模拟信号的最高频率为f = 64KHz,采样频率是Fs = 128KHz，根据模拟频率和数字频率的关系可以知道128KHz的模拟采样频率被分成16份，每一份是8KHz，这就是<strong>频率分辨率</strong>（频率分辨率可以理解为在使用DFT时，在频率轴上的所能得到的最小频率间隔f0 = fs/N =1/T ，其中N为采样点数，  fs为采样频率,T为采样前模拟信号的时间长度。所以信号长度越长，频率分辨率越好。摘自百度百科）。如果想要提高频率分辨率，在做FFT的时候可以适当增加采样点数。那么DFT得到的频谱的横坐标，n = 0时对应的f = 0，n = 1时对应的f = 8KHz，依次类推n = 7时对应f = 56KHz，因为模拟信号的最高频率为64KHz,而且频谱是关于n = 8对称，所以我们只需要关心n取07以内的频谱就足够了。<br>如果我们想求第k个点的实际频率，我们必须知道原信号的采样频率和采样点数。公式为f(k)=k<em>(fs/n)。</em></font><br><font face="宋体" size="5">*用DFT对连续信号进行谱分析<strong></strong></font><br><font face="宋体" size="4">在对连续信号进行谱分析时，主要关心两个问题，就是谱分析范围和频率分辨率。谱分析范围为[0，Fs/2]，直接受采样频率Fs的限制，为了不产生频谱混叠失真，通常要求信号的最高频率f &lt; Fs/2。频率分辨率用频率采样间隔F来描述，F = Fs/N；F表示谱分析中能够分辨的两个频率分量的最小间隔。F较小时，频率分辨率较高。如果维持采样频率Fs不变，为提高频率分辨率可以增加采样点数N，只要增加对信号的观察时间Tp，才能增加采样点数N。</font><br><font face="宋体" size="5">用DFT进行谱分析的误差问题**</font><br><font face="宋体" size="4">        DFT可用来对连续信号和数字信号进行谱分析，在实际分析过程中，要对连续信号采样和截断，就会引发误差，下面介可能产生误差的三种现象。<br>（1）混叠现象。对连续信号进行谱分析是，首先要对其采样，变成时域离散信号后才能用DFT(FFT)进行谱分析。采样速率Fs必须满足奈奎斯特采样定理，否则会在Fs/2附近发生频谱混叠现象。<br>（2）栅栏效应。N点DFT是在频率区间[0，2π]上对时域离散信号的频谱进行N点等间隔采样，而采样点之间的频谱是看不到的。就像上文中举的例子，原来信号可能会在5KHz出有频谱的分量，但我们的频率分辨率只有8KHz，这就导致我们无法观察在5KHz的分量。要想观察，我们就必须提高频率分辨率。对于有限长序列，可以在原序列尾部补零；对于无限长序列，可以增大截取长度及DFT变换区间长度，从而使频域采样间隔变小，增加频域采样点数和采样点位置，使原来漏掉的某些频谱分量被检测出来。对于连续信号的谱分析，只要采样速率Fs足够高，且采样点数满足频率分辨率要求，就可以认为DFT后所得离散谱的包络近似代表原信号的频谱。<br>（3）截断效应。实际中遇到的序列x(n)可能无限长的，用DFT进行谱分析时，必须将其截断，形成有限长序列。而截断后序列的频谱必将发生变化。主要有两个方面：<br>    ①泄露 ：原来的序列的频谱是离散谱线，经截断后，使原来的离散谱线向附近展宽。通常称这种展宽为泄露。泄露使频谱变模糊，频率分辨率降低。<br>    ②谱间干扰。</font></p>]]></content>
      
      
      <categories>
          
          <category> FPGA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FFT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FPGA利用FIFO做数据缓冲</title>
      <link href="/2017/07/30/FPGA%E5%88%A9%E7%94%A8FIFO%E5%81%9A%E6%95%B0%E6%8D%AE%E7%BC%93%E5%86%B2/"/>
      <url>/2017/07/30/FPGA%E5%88%A9%E7%94%A8FIFO%E5%81%9A%E6%95%B0%E6%8D%AE%E7%BC%93%E5%86%B2/</url>
      
        <content type="html"><![CDATA[<p>﻿今天尝试使用了Quartus Ⅱ 15.1 的FIFO的IP核。<br>———————————————————————————————————————<br>简单介绍一下FIFO。FIFO（First Input First Output），很容易理解，就是先进先出，和数据结构里的队列一样。举一个通俗的例子，在超市买东西，结账的时候，大家都在排队，先排队的人先结账走人，不在这里逗留（这点和RAM不同）。所以FIFO通常是作为数据缓冲结构，一般用于不同时钟域之间的数据传输，比如FIFO一端是采样速率比较慢的接口，另一端是采样速率比较块的接口。也可以用于输入数据和输出数据位宽不同的情况。</p><a id="more"></a><p>Ip核的参数配置网上有很多，大家也可以看下《HELLO FPGA》里的详细介绍。<br>FIFO IP核主要用于同步或异步时钟域先入先出数据流的缓存。<br>FIFO是没有读写地址的，根据读写使能和上升沿触发的时钟进行写入和读出。而且数据不再FIFO里逗留，读出既从“结完账走人了”。所以它有写满和读空的标志位，我们可以利用两个标志位写读写逻辑使能，这一点比利用双口RAM做缓冲会简单方便很多。<br>简单的贴下代码，使用SignalTap仿真。 </p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span>fifo(</span><br><span class="line">clk,rst_n,</span><br><span class="line">RomAddr,rddata,RomData,rden,full,empty,clk_10M</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"><span class="keyword">input</span>clk;</span><br><span class="line"><span class="keyword">input</span>rst_n;</span><br><span class="line"><span class="keyword">output</span>[<span class="number">7</span>:<span class="number">0</span>]RomData;</span><br><span class="line"><span class="keyword">output</span><span class="keyword">reg</span>[<span class="number">4</span>:<span class="number">0</span>]RomAddr;</span><br><span class="line"><span class="keyword">output</span>[<span class="number">7</span>:<span class="number">0</span>]rddata;</span><br><span class="line"><span class="keyword">output</span><span class="keyword">reg</span>rden;</span><br><span class="line"><span class="keyword">output</span>full;</span><br><span class="line"><span class="keyword">output</span>empty;</span><br><span class="line"><span class="keyword">output</span>clk_10M;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line"><span class="keyword">if</span>(!rst_n)</span><br><span class="line">rden &lt;= <span class="number">'d0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(full)</span><br><span class="line">rden &lt;= <span class="number">1'b1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(empty)</span><br><span class="line">rden &lt;= <span class="number">1'b0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">rden &lt;= rden;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Dif_Fifo Dif_Fifo_inst (</span><br><span class="line"><span class="variable">.data</span>(RomData),</span><br><span class="line"><span class="variable">.rdclk</span>(clk),</span><br><span class="line"><span class="variable">.rdreq</span>(rden),</span><br><span class="line"><span class="variable">.wrclk</span>(clk_10M),</span><br><span class="line"><span class="variable">.wrreq</span>(~rden),</span><br><span class="line"><span class="variable">.q</span>(rddata),</span><br><span class="line"><span class="variable">.rdempty</span>(empty),</span><br><span class="line"><span class="variable">.wrfull</span>(full)</span><br><span class="line">);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">FIFO FIFO_inst (</span></span><br><span class="line"><span class="comment">.clock(clk),</span></span><br><span class="line"><span class="comment">.data(RomData),</span></span><br><span class="line"><span class="comment">.rdreq(rden),</span></span><br><span class="line"><span class="comment">.wrreq(wren),</span></span><br><span class="line"><span class="comment">.empty(empty),</span></span><br><span class="line"><span class="comment">.full(full),</span></span><br><span class="line"><span class="comment">.q(rddata),</span></span><br><span class="line"><span class="comment">.usedw(usedw)</span></span><br><span class="line"><span class="comment">);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*****************10M去读rom*****************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//reg[4:0]RomAddr;</span></span><br><span class="line"><span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk_10M <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line"><span class="keyword">if</span>(!rst_n)</span><br><span class="line">RomAddr &lt;= <span class="number">'d0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(RomAddr &gt;= <span class="number">5'd31</span>)</span><br><span class="line">RomAddr &lt;= <span class="number">'d0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">RomAddr &lt;= RomAddr  + <span class="number">1'b1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//wire[7:0]RomData;</span></span><br><span class="line">Rom_Test Rom_Test_inst (</span><br><span class="line"><span class="variable">.address</span>(RomAddr),</span><br><span class="line"><span class="variable">.clock</span>(clk_10M),</span><br><span class="line"><span class="variable">.q</span>(RomData)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*****PLL分频产生10M的时钟*****/</span></span><br><span class="line"><span class="comment">//wireclk_10M;</span></span><br><span class="line">Ip_Core_PLL Ip_Core_PLL_inst (</span><br><span class="line"> <span class="variable">.refclk</span>(clk),   <span class="comment">//  refclk.clk</span></span><br><span class="line"> <span class="variable">.rst</span>(!rst_n),      <span class="comment">//   reset.reset</span></span><br><span class="line"> <span class="variable">.outclk_0</span>(clk_10M), <span class="comment">// outclk0.clk</span></span><br><span class="line"> <span class="variable">.locked</span>()    <span class="comment">//  locked.export</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><p>仿真：<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNzMwMjAwMTMyNjQ3?x-oss-process=image/format,png" alt="这里写图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> FPGA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FPGA </tag>
            
            <tag> FIFO </tag>
            
            <tag> 数据缓冲 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>等精度测频的原理和基于FPGA的实现</title>
      <link href="/2017/07/29/%E7%AD%89%E7%B2%BE%E5%BA%A6%E6%B5%8B%E9%A2%91%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E5%9F%BA%E4%BA%8EFPGA%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
      <url>/2017/07/29/%E7%AD%89%E7%B2%BE%E5%BA%A6%E6%B5%8B%E9%A2%91%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E5%9F%BA%E4%BA%8EFPGA%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>﻿我们通过FPGA测量信号频率，一般来说有两种方案。传统测频法和等精度测频法。<br>方案一：<br>传统测频是在一段闸门时间内直接对输入信号的周期进行计数，也被叫做直接测频法。设闸门信号为gate，检测待测信号上升沿，然后判断gate是否为高电平，若为高电平便开始计数。这就存在gate的时间和待测信号周期数可能不成整数倍，导致产生+1hz或-1hz的误差。</p><a id="more"></a><p>方案二：<br>等精度测频可以弥补传统测频的缺点，它保证了闸门时间永远是被测信号周期的整数倍。设预设闸门信号为base，实际闸门信号为gate，检测待测信号上升沿，当base为高电平时，实际闸门打开，gate为高电平，此时两个计数器同时对标准信号和待测信号的周期进行计数。当base为低电平，实际闸门关闭，gate为低电平计数器停止计数。下面的时序图（从别人博客摘过来的，但是他博客里说时从百度摘过来的，原博客看水印）可以很好的说明。<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNzI5MjA1NDU0OTM0?x-oss-process=image/format,png" alt="这里写图片描述"><br> 最终由公式：<br>待测信号频率/待测信号实际闸门周期数 = 标准信号频率/标准信号实际闸门周期数<br>       可以得到待测信号的频率。<br>结论：<br>       由等精度测量公式可以知道等精度测频的误差来源于标准信号，而标准信号的频率为50Mhz，可以认为误差足够小，所以可以消除+1hz或-1hz的误差。并且因为等精度测频能够在整个时域保持恒定的误差，所以非常适合用来测量可调位同步时钟信号的频率。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span>FreMeasure(</span><br><span class="line"><span class="keyword">input</span>clk,</span><br><span class="line"><span class="keyword">input</span>rst_n,</span><br><span class="line"><span class="keyword">input</span>Sig_in,</span><br><span class="line"><span class="keyword">output</span><span class="keyword">reg</span>[<span class="number">31</span>:<span class="number">0</span>]           Fre</span><br><span class="line">);</span><br><span class="line"><span class="keyword">parameter</span> T_1s = <span class="number">28'd49_999_999</span>;</span><br><span class="line"><span class="comment">//————————————————————————</span></span><br><span class="line"><span class="comment">//预置闸门</span></span><br><span class="line"><span class="keyword">reg</span>[<span class="number">27</span>:<span class="number">0</span>]TCount;</span><br><span class="line"><span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line"><span class="keyword">if</span>(!rst_n)</span><br><span class="line">TCount &lt;= <span class="number">28'd0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(TCount &gt;= T_1s)</span><br><span class="line">TCount &lt;= <span class="number">'d0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">TCount &lt;= TCount + <span class="number">1'b1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span>TCountCnt;</span><br><span class="line"><span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line"><span class="keyword">if</span>(!rst_n)</span><br><span class="line">TCountCnt &lt;= <span class="number">1'b0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(TCount &gt;= T_1s)</span><br><span class="line">TCountCnt &lt;= ~TCountCnt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//————————————————————————</span></span><br><span class="line"><span class="comment">//实际闸门</span></span><br><span class="line"><span class="keyword">reg</span>startCnt;</span><br><span class="line"><span class="keyword">always</span> @ (<span class="keyword">posedge</span> Sig_in)</span><br><span class="line"><span class="keyword">if</span>(TCountCnt == <span class="number">1'b1</span>)</span><br><span class="line">startCnt &lt;= <span class="number">1'b1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">startCnt &lt;= <span class="number">1'b0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//————————————————————————</span></span><br><span class="line"><span class="comment">//在实际闸门中计数</span></span><br><span class="line"><span class="keyword">reg</span>[<span class="number">31</span>:<span class="number">0</span>]SigTemp;</span><br><span class="line"><span class="keyword">always</span> @ (<span class="keyword">negedge</span> Sig_in)</span><br><span class="line"><span class="keyword">if</span>(startCnt == <span class="number">1'b1</span>)</span><br><span class="line">SigTemp &lt;= SigTemp + <span class="number">1'b1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">SigTemp &lt;= <span class="number">'d0</span>;</span><br><span class="line"><span class="comment">//————————————————————————</span></span><br><span class="line"><span class="comment">//锁存输出</span></span><br><span class="line"><span class="keyword">always</span> @ (<span class="keyword">negedge</span> startCnt)</span><br><span class="line">Fre &lt;= SigTemp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> FPGA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 等精度测评 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
