<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>远程登录Oracle数据库报ORA12368:身份证明检索失败</title>
    <url>/2019/10/31/%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95Oracle%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%A5ORA12368-%E8%BA%AB%E4%BB%BD%E8%AF%81%E6%98%8E%E6%A3%80%E7%B4%A2%E5%A4%B1%E8%B4%A5/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2019/10/31/SKHNp6LaMGIE2oB.jpg" alt></p>
<a id="more"></a>

<p>​    之前都是连接的本地的oracle数据库，全部数据测试完毕后，打算连接服务器上的数据库时出现报错<strong>ORA12368：身份证明检索失败</strong>。</p>
<p>​    <strong>解决方法：</strong></p>
<p>​        找到<strong>本地</strong>安装的oracle的客户端数据的安装目录，例如我的是<strong>H:\oracleDatabase\oracleRoot\product\11.2.0\dbhome_1\NETWORK\ADMIN</strong>打开文件<strong>sqlnet.ora</strong>。</p>
<pre><code>1. 将`SQLNET.AUTHENTICATION_SERVICES= (NTS)`注释掉`#SQLNET.AUTHENTICATION_SERVICES= (NTS)`。
  2. 将`SQLNET.AUTHENTICATION_SERVICES= (NTS)`修改为`SQLNET.AUTHENTICATION_SERVICES= (BEQ,NONE)`。</code></pre>]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>局域网时钟同步PTP协议简介</title>
    <url>/2019/10/28/%E5%B1%80%E5%9F%9F%E7%BD%91%E6%97%B6%E9%92%9F%E5%90%8C%E6%AD%A5PTP%E5%8D%8F%E8%AE%AE%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<p><img src="https://raw.githubusercontent.com/xutianyun1/cloudimage/master/img/5b2c772f345ce21897fe5ec9ae348267_hd.jpg" alt></p>
<a id="more"></a>

<h3 id="IEEE1588-PTP-协议简介"><a href="#IEEE1588-PTP-协议简介" class="headerlink" title="IEEE1588(PTP)协议简介"></a>IEEE1588(PTP)协议简介</h3><p>​    IEEE1588协议，称作PTP(precise time protocol,  精确时间协议)，2002年发布version1，2008年发布version2。即可以用<strong>硬件</strong>实现，也可以用<strong>软件</strong>实现。当采用硬件实现时可以达到ns级的精度，采用软件实现时通常可以达到ms级精度。当在网络中采用软件实现<em>亚毫秒</em>的精度时，存在多种因素的 影响会造成时间同步的不可靠。例如：<strong>网络的不平稳性</strong>、<strong>网卡对信息包的缓存效应</strong>、<strong>操作系统进程调度的影响</strong>。</p>
<p>​    IEEE1588v2协议提出的同步原理<strong>Delay Request-Response Mechanism（延时响应机制）</strong>如图1所示。</p>
<p><img src="https://raw.githubusercontent.com/xutianyun1/cloudimage/master/img/PTP%E5%8D%8F%E8%AE%AE%E5%BB%B6%E8%BF%9F%E5%93%8D%E5%BA%94%E6%9C%BA%E5%88%B6.png" alt="图1 PTP协议延迟响应机制"></p>
<p>​                                        <strong>图1 PTP协议延迟响应机制</strong></p>
<p>图中所描述的PTP报文为一下几种：</p>
<ul>
<li><strong>sync 同步报文</strong></li>
<li><strong>Follow_up 跟随报文</strong></li>
<li><strong>Delay_req 延迟请求报文</strong></li>
<li><strong>Delay_resp 延迟请求响应报文</strong></li>
</ul>
<p><strong>延迟相应同步机制</strong>的报文收发流程：</p>
<ol>
<li><p>主时钟<strong>周期性</strong>的发出<strong>sync</strong>报文，并记录下<strong>sync</strong>报文离开主时钟的精确发送时间<strong>t1</strong>。</p>
<p>（如果sync在此时携带发送时间，这个发送时间并不是精确的，是预估的，在不要求精度的情况下允许这么做，称为单步同步）</p>
</li>
<li><p>主时钟将精确发送时间<strong>t1</strong>封装到<strong>Follow_up</strong>报文中，发送给从时钟。</p>
</li>
<li><p>从时钟记录<strong>sync</strong>报文到达从时钟的时间<strong>t2</strong>。</p>
</li>
<li><p>从时钟发出<strong>Delay_req</strong>报文并且记录下发出的时间<strong>t3</strong>。</p>
</li>
<li><p>主时钟记录下<strong>Delay_req</strong>报文到达主时钟的精确时间<strong>t4</strong>。</p>
</li>
<li><p>主时钟将<strong>t4</strong>封装到<strong>Delay_resp</strong>报文给从时钟。</p>
</li>
</ol>
<p>主从时钟的差异主要是由时钟偏差和数据包在网络中传输的延迟构成。</p>
<p><strong>时钟偏差&amp;网络延时</strong></p>
<p>​    <strong>offset</strong>：主从时钟的时间偏差；<strong>delay</strong>：网络延时（报文在网络中传输的延时）</p>
<p>​    经过延迟响应同步机制后，从时钟获得<strong>t1,t2,t3,t4</strong>四个精确的时间戳，可以据此计算<strong>offset</strong>和<strong>delay</strong>：</p>
<p><img src="https://raw.githubusercontent.com/xutianyun1/cloudimage/master/img/%E6%97%B6%E9%92%9F%E5%81%8F%E5%B7%AE%E5%92%8C%E7%BD%91%E7%BB%9C%E5%BB%B6%E6%97%B6%E7%9A%84%E8%AE%A1%E7%AE%97%E5%85%AC%E5%BC%8F.png" alt></p>
<p>​    在从时钟中计算得到<strong>offset</strong>和<strong>delay</strong>，用<strong>current_time</strong>表示从时钟的当前时间，那么同步公式为：</p>
<p>​    <strong>current_time = current_time - offset - delay</strong></p>
<hr>
<p><strong>参考</strong>：<a href="https://www.cnblogs.com/AdaminXie/p/6754644.html" target="_blank" rel="noopener">https://www.cnblogs.com/AdaminXie/p/6754644.html</a></p>
]]></content>
      <categories>
        <category>车联网</category>
      </categories>
      <tags>
        <tag>时钟同步</tag>
        <tag>IEEE1588v2</tag>
      </tags>
  </entry>
  <entry>
    <title>最长回文子串（马拉车算法）</title>
    <url>/2019/08/27/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<p>﻿最长回文子串，即正反读起来都一样，例如“ababa”。Manacher Algorithm算法利用了回文的重复特性，让时间复杂度降为了O(n)。</p>
<a id="more"></a>

<p>马拉车算法详解：</p>
<ol>
<li>改造字符串，在中心扩展法中，要求区分字符串长度为奇数或偶数的情况，我们这里对字符串进行简单的改造，让字符串变成奇数便于处理。例：“ababad” —-&gt;“a#b#a#b#a#d”。为了在检测回文子串的时候避免判断越界，我们可以在开头和结束添加两个不同的字符—-&gt;”$a#b#a#b#a#d^”（也不可不做这一步，如果不在开头和结束添加两个不同的字符的话，就需要在检测回文子串的时候检测开头和结尾） </li>
<li>为了能够充分利用回文子串的重复性质，我们可以将字符串中每个字符的回文半径存如一个数组P中</li>
<li>这样就将问题转换为了求数组P中的最大值所在的下标和值。但在实际操作中我们并不这样做，是动态的寻着数组P的最大值，即一边写入一边检测，而不是等数组P填充完毕后再去寻找数组P的最大值。因为字符串”a#a”和”#a#”虽然第一个字符串的”#”和第二个字符串的”a”的回文半径是相同的，但是，显而易见，在去掉”#”后 一个是”aa”，一个是”a”。</li>
<li>关于如何填充数组P<pre><code>先设置两个变量，马拉车算法就是在动态的更新这两个变量。
center：是最大回文子串的中心位置
mx_right：是最大回文子串所能覆盖的最右端的位置。
共分为两种情况：
当 i &lt; mx_right时：即i位于目前的最大回文子串max_str中。那么我们根据回文的重复特性，取检查j = 2 * center - i(j为i以center为中心的对称点)。如果P[j] &lt; mx_right - i 说明以j为中心的回文子串依然位于目前的最大回文子串max_str，很具重复特性可以知道此时P[i] == p[j]。如果P[j] &gt;= mx_right - i,此时只能保证到i的回文子串到mx_right这位置是依然满足的，这里别无他法，只能暴力取匹配mx_right外面的，直到失配，然后在根据大小判断是否更新最大回文子串max_str
当i &gt;= mx_right时：此时不能充分利用回文子串的重复特性，只能暴力匹配。</code></pre></li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestPainromedon</span><span class="params">(s:str)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> len(s) &lt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line">    new_str = <span class="string">'$'</span> + <span class="string">'#'</span>.join(s) + <span class="string">'^'</span>		<span class="comment">#避免判断越界</span></span><br><span class="line">    center = <span class="number">1</span>					<span class="comment">#最长回文子串中心位置</span></span><br><span class="line">    mx_right = <span class="number">1</span>				<span class="comment">#最长回文子串最右面覆盖的位置</span></span><br><span class="line">    max_str = new_str[<span class="number">1</span>]			<span class="comment">#最长回文子串</span></span><br><span class="line">    p = [<span class="number">0</span>]*len(new_str)			<span class="comment">#回文子串半径表列</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(new_str)<span class="number">-1</span>):</span><br><span class="line"></span><br><span class="line">        j = <span class="number">2</span>*center - i</span><br><span class="line">        <span class="keyword">if</span> i &lt; mx_right:</span><br><span class="line">            <span class="keyword">if</span> p[j] &lt; mx_right - i:</span><br><span class="line">                p[i] = p[j]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                k = mx_right+<span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> new_str[k] == new_str[<span class="number">2</span>*i - k]:</span><br><span class="line">                    k += <span class="number">1</span></span><br><span class="line">                k -= <span class="number">1</span></span><br><span class="line">                p[i] =  k - i</span><br><span class="line">                cur_str = new_str[i - p[i]:i + p[i] + <span class="number">1</span>].replace(<span class="string">'#'</span>, <span class="string">''</span>)</span><br><span class="line">                <span class="keyword">if</span> len(cur_str) &gt; len(max_str):</span><br><span class="line">                    max_str = cur_str</span><br><span class="line">                    center, mx_right = i, k</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            k = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> new_str[i - k - <span class="number">1</span>] == new_str[i + k + <span class="number">1</span>]:</span><br><span class="line">                k += <span class="number">1</span></span><br><span class="line">            p[i] = k</span><br><span class="line">            cur_str = new_str[i - p[i]:i+p[i] + <span class="number">1</span>].replace(<span class="string">'#'</span>, <span class="string">''</span>)</span><br><span class="line">            <span class="keyword">if</span> len(cur_str) &gt; len(max_str):</span><br><span class="line">                max_str = cur_str</span><br><span class="line">                center, mx_right = i, k + i</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max_str</span><br></pre></td></tr></table></figure>

<p>代码如上，此代码时完全照算法来的，其他的博客的代码我想应该是有所优化，导致我一开始有点懵。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法、字符串、回文子串</tag>
      </tags>
  </entry>
  <entry>
    <title>python比较时间</title>
    <url>/2019/08/11/python%E6%AF%94%E8%BE%83%E6%97%B6%E9%97%B4%20(1)/</url>
    <content><![CDATA[<p>今天在写爬虫的时候，遇到了需要把从网页上爬取下来的时间进行比较，所以遇到了这个问题，如何比较时间，我一开始是打算把它转换为字符串，然后自己撸一个算法进行诸位比较。后来知道可以将其转为datetime格式，就可以进行比较了，而且还可以做减法求两个时间点的时间间隔，无敌！！</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line">st = <span class="string">'13:10'</span></span><br><span class="line">time = datetime.datetime.strptime(st, <span class="string">"%Y-%m-%d %H:%M:%S"</span>)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>比较时间</tag>
      </tags>
  </entry>
  <entry>
    <title>独热编码--One-Hot Encoding</title>
    <url>/2019/06/01/%E7%8B%AC%E7%83%AD%E7%BC%96%E7%A0%81%E2%80%94%E2%80%94One-Hot%20Encoding%20(2)/</url>
    <content><![CDATA[<p>﻿ - One-Hot Encoding介绍<br>         又称为一位有效编码，用N位状态寄存器来对N个状态进行编码，每个状态都由独立的寄存器表示，其中只有一位有效。<br>         对于1， 2， 3，经过独热编码后为001，010，100</p>
<ul>
<li>应用<br> 对于有些特征变量可能是属性变量，<br> 如color：[‘red’,’blue’,’green’]<br>我们就要把这个color特征变量编码为数字。我们可编码为[1,2,3]。但是这样的编码并不能直接应用于我们的分类器中，因为分类器往往默认特征变量数据是连续的（可以计算距离的）、有序的（3&gt;2&gt;1）。但是按照我们的常识，如果像这样编码显然是不合理的，因为为‘red’、‘blue’、‘green’并没有什么联系，是相互独立的。<br> 因此我们就要使用独热编码来避免出现这种情况。</li>
</ul>
]]></content>
      <categories>
        <category>ML</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>编码</tag>
      </tags>
  </entry>
  <entry>
    <title>吴恩达《机器学习》——第七次作业：k-means算法</title>
    <url>/2019/06/01/%E5%90%B4%E6%81%A9%E8%BE%BE%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E2%80%94%E2%80%94%E7%AC%AC%E4%B8%83%E6%AC%A1%E4%BD%9C%E4%B8%9A%EF%BC%9Ak-means%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<ol>
<li><p>2D-kmeans算法</p>
<a id="more"></a>


</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sb</span><br><span class="line"><span class="keyword">from</span> scipy.io <span class="keyword">import</span> loadmat</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_closet_centroids</span><span class="params">(X, centroids)</span>:</span></span><br><span class="line">    <span class="string">'''将每个特征计算属于那个特征'''</span></span><br><span class="line">    m = X.shape[<span class="number">0</span>]</span><br><span class="line">    k = centroids.shape[<span class="number">0</span>]</span><br><span class="line">    idx = np.zeros(m)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line"></span><br><span class="line">        min_dist = <span class="number">1000000</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(k):</span><br><span class="line"></span><br><span class="line">            dist = np.sum((X[i, :] - centroids[j, :]) ** <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">if</span> dist &lt; min_dist:</span><br><span class="line">                min_dist = dist</span><br><span class="line">                idx[i] = j</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> idx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compute_centroids</span><span class="params">(X, idx, k)</span>:</span></span><br><span class="line">    <span class="string">'''更新聚类中心'''</span></span><br><span class="line">    m, n = X.shape</span><br><span class="line">    centroids = np.zeros((k, n))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line"></span><br><span class="line">        indices = np.where(idx == i)</span><br><span class="line">        centroids[i, :] = (np.sum(X[indices, :], axis=<span class="number">1</span>) / len(indices[<span class="number">0</span>])).ravel()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> centroids</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_one_kmeans</span><span class="params">(X, initial_centroids, max_iters)</span>:</span></span><br><span class="line">    <span class="string">'''运行k-means均值算法进行聚类'''</span></span><br><span class="line">    m, n = X.shape</span><br><span class="line">    k = initial_centroids.shape[<span class="number">0</span>]</span><br><span class="line">    idx = np.zeros(m)</span><br><span class="line">    centroids = initial_centroids</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(max_iters):</span><br><span class="line">        idx = find_closet_centroids(X, centroids)</span><br><span class="line">        centroids = compute_centroids(X, idx, k)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> idx, centroids</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init_centroids</span><span class="params">(X, k)</span>:</span></span><br><span class="line">    <span class="string">'''随机初始化聚类中心'''</span></span><br><span class="line">    m, n = X.shape</span><br><span class="line">    centroids = np.zeros((k, n))</span><br><span class="line">    idx = np.random.randint(<span class="number">0</span>, m, k)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">        centroids[i, :] = X[idx[i], :]</span><br><span class="line">    <span class="keyword">return</span> centroids</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_all_kmeans</span><span class="params">(X, k, n_init, max_iter)</span>:</span></span><br><span class="line">    <span class="string">'''kmeans算法'''</span></span><br><span class="line">    min_dist = <span class="number">1000000</span></span><br><span class="line">    m, n = X.shape</span><br><span class="line">    result_centroids = np.zeros((k, n))</span><br><span class="line">    result_idx = np.zeros(m)</span><br><span class="line">    cnt = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n_init):</span><br><span class="line">        initial_centroids = init_centroids(X, k)        <span class="comment">#</span></span><br><span class="line">        <span class="comment">#print(initial_centroids)</span></span><br><span class="line">        idx, centroids = run_one_kmeans(X, initial_centroids, max_iter)</span><br><span class="line">        dist = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(m):</span><br><span class="line">            dist += np.sum((X[j, :] - centroids[int(idx[j]), :]) ** <span class="number">2</span>) / len(X)</span><br><span class="line">        <span class="keyword">if</span> dist &lt; min_dist:</span><br><span class="line">            min_dist = dist</span><br><span class="line">            result_idx = idx</span><br><span class="line">            result_centroids = centroids</span><br><span class="line">            cnt = i</span><br><span class="line">    <span class="comment">#print(cnt)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result_idx, result_centroids</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">data = loadmat(<span class="string">'data/ex7data2.mat'</span>)</span><br><span class="line">X = data[<span class="string">'X'</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">idx, centroids = run_all_kmeans(X, <span class="number">3</span>, <span class="number">30</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">cluster1 = X[np.where(idx == <span class="number">0</span>)[<span class="number">0</span>], :]</span><br><span class="line">cluster2 = X[np.where(idx == <span class="number">1</span>)[<span class="number">0</span>], :]</span><br><span class="line">cluster3 = X[np.where(idx == <span class="number">2</span>)[<span class="number">0</span>], :]</span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">12</span>, <span class="number">8</span>))</span><br><span class="line">ax.scatter(cluster1[:, <span class="number">0</span>], cluster1[:, <span class="number">1</span>], s=<span class="number">30</span>, color=<span class="string">'r'</span>, label=<span class="string">'Cluster 1'</span>)</span><br><span class="line">ax.scatter(cluster2[:, <span class="number">0</span>], cluster2[:, <span class="number">1</span>], s=<span class="number">30</span>, color=<span class="string">'g'</span>, label=<span class="string">'Cluster 2'</span>)</span><br><span class="line">ax.scatter(cluster3[:, <span class="number">0</span>], cluster3[:, <span class="number">1</span>], s=<span class="number">30</span>, color=<span class="string">'b'</span>, label=<span class="string">'Cluster 3'</span>)</span><br><span class="line">ax.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20190525172655371.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NoZXJpc2hfeA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ol start="2">
<li>k-means应用：图像压缩<br>图像压缩前：<br><img src="https://img-blog.csdnimg.cn/20190525180102555.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NoZXJpc2hfeA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython.display <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sb</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> k_means_and_PCA.kmeans_2D <span class="keyword">import</span> run_all_kmeans</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> scipy.io <span class="keyword">import</span> loadmat</span><br><span class="line"></span><br><span class="line">Image(filename=<span class="string">'data/bird_small.png'</span>)</span><br><span class="line"></span><br><span class="line">image_data = loadmat(<span class="string">'data/bird_small.mat'</span>)</span><br><span class="line"></span><br><span class="line">A = image_data[<span class="string">'A'</span>] / <span class="number">255</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">X = np.reshape(A, (A.shape[<span class="number">0</span>] * A.shape[<span class="number">1</span>], A.shape[<span class="number">2</span>]))</span><br><span class="line"></span><br><span class="line">idx, centroids = run_all_kmeans(X, <span class="number">16</span>, <span class="number">10</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">X_recovered = centroids[idx.astype(int), :]</span><br><span class="line">X_recovered = np.reshape(X_recovered, (A.shape[<span class="number">0</span>], A.shape[<span class="number">1</span>], A.shape[<span class="number">2</span>]))</span><br><span class="line">X_recovered *= <span class="number">255</span></span><br><span class="line">plt.imshow(X_recovered.astype(int))</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p>图像压缩处理后 ：<br><img src="https://img-blog.csdnimg.cn/20190525182212232.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NoZXJpc2hfeA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>ML</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>python编译报错TypeError_ 'builtin_function_or_method' object is not subscriptable</title>
    <url>/2019/05/30/python%E7%BC%96%E8%AF%91%E6%8A%A5%E9%94%99TypeError_%20&#39;builtin_function_or_method&#39;%20object%20is%20not%20subscriptable/</url>
    <content><![CDATA[<p>﻿报错代码片段：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">embacked_dict = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> embacked:</span><br><span class="line">    <span class="keyword">if</span> embacked_dict.get[i]:<span class="comment">#此处报错</span></span><br><span class="line">        embacked_dict[i] += <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        embacked_dict[i] = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>此类型错误一般是把函数参数用[ ]传入了，改为()即可</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>编译报错</tag>
      </tags>
  </entry>
  <entry>
    <title>吴恩达《机器学习》——第七次作业：主要成分分析(PCA)</title>
    <url>/2019/05/25/%E5%90%B4%E6%81%A9%E8%BE%BE%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E2%80%94%E2%80%94%E7%AC%AC%E4%B8%83%E6%AC%A1%E4%BD%9C%E4%B8%9A%EF%BC%9A%E4%B8%BB%E8%A6%81%E6%88%90%E5%88%86%E5%88%86%E6%9E%90(PCA)/</url>
    <content><![CDATA[<p>主要成分分析</p>
<a id="more"></a>





<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> scipy.io <span class="keyword">import</span> loadmat</span><br><span class="line"></span><br><span class="line">data = loadmat(<span class="string">'data/ex7data1.mat'</span>)</span><br><span class="line">X = data[<span class="string">'X'</span>]</span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">12</span>, <span class="number">8</span>))</span><br><span class="line">ax.scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>])</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pca</span><span class="params">(X)</span>:</span></span><br><span class="line">    X = (X - X.mean()) / X.std()        <span class="comment">#特征缩放</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">X = np.matrix(X)</span><br><span class="line"></span><br><span class="line">cov = (X.T * X) / X.shape[<span class="number">0</span>]        <span class="comment">#协方差</span></span><br><span class="line"></span><br><span class="line">U, S, V = np.linalg.svd(cov)        <span class="comment">#奇异值分解</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> U, S, V</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">project_data</span><span class="params">(X, U, k)</span>:</span></span><br><span class="line">    U_reduced = U[:, :k]</span><br><span class="line">    <span class="keyword">return</span> np.dot(X, U_reduced)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recover_data</span><span class="params">(Z, U, k)</span>:</span></span><br><span class="line">    U_reduced = U[:, :k]</span><br><span class="line">    <span class="keyword">return</span> np.dot(Z, U_reduced.T)</span><br><span class="line"></span><br><span class="line">U, S, V = pca(X)</span><br><span class="line"></span><br><span class="line">Z = project_data(X, U, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>ML</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>吴恩达《机器学习》——第四次作业：BP神经网络</title>
    <url>/2019/05/18/%E5%90%B4%E6%81%A9%E8%BE%BE%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E2%80%94%E2%80%94%E7%AC%AC%E5%9B%9B%E6%AC%A1%E4%BD%9C%E4%B8%9A%EF%BC%9ABP%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<p>本此作业和上次作业的目标一样，属于多元分类任务。不过这次是使用BP神经网络。准确度比没有使用神经网络的第三次作业要高，但是训练的时间也长了很多。<br>参考：<a href="https://github.com/fengdu78/Coursera-ML-AndrewNg-Notes/tree/master/code" target="_blank" rel="noopener">https://github.com/fengdu78/Coursera-ML-AndrewNg-Notes/tree/master/code</a></p>
<a id="more"></a>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> scipy.io <span class="keyword">as</span> sio</span><br><span class="line"><span class="keyword">import</span> matplotlib</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> scipy.optimize <span class="keyword">as</span> opt</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> classification_report</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> OneHotEncoder</span><br><span class="line"></span><br><span class="line">data = sio.loadmat(<span class="string">'ex4data1.mat'</span>)</span><br><span class="line">X = data[<span class="string">'X'</span>]</span><br><span class="line">y = data[<span class="string">'y'</span>]</span><br><span class="line"></span><br><span class="line">encoder = OneHotEncoder(sparse=<span class="literal">False</span>)</span><br><span class="line">y_onehot = encoder.fit_transform(y)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sigmoid</span><span class="params">(z)</span>:</span></span><br><span class="line">    <span class="string">'''激活函数'''</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> / (<span class="number">1</span> + np.exp(-z))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">forward_propagate</span><span class="params">(X, theta1, theta2)</span>:</span></span><br><span class="line">    <span class="string">'''前向传播算法'''</span></span><br><span class="line">    m = X.shape[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    a1 = np.insert(X, <span class="number">0</span>, values=np.ones(m), axis=<span class="number">1</span>)</span><br><span class="line">    z2 = a1 * theta1.T</span><br><span class="line">    a2 = sigmoid(z2)</span><br><span class="line">    a2 = np.insert(a2, <span class="number">0</span>, values=np.ones(m), axis=<span class="number">1</span>)</span><br><span class="line">    z3 = a2 * theta2.T</span><br><span class="line">    h = sigmoid(z3)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a1, z2, a2, z3, h</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cost</span><span class="params">(params, input_size, hidden_size, num_labels, X, y, learning_rate)</span>:</span></span><br><span class="line">    <span class="string">'''代价函数'''</span></span><br><span class="line">    m = X.shape[<span class="number">0</span>]</span><br><span class="line">    X = np.matrix(X)</span><br><span class="line">    y = np.matrix(y)</span><br><span class="line"></span><br><span class="line">    theta1 = np.matrix(np.reshape(params[:hidden_size * (input_size + <span class="number">1</span>)], (hidden_size, (input_size + <span class="number">1</span>))))</span><br><span class="line">    theta2 = np.matrix(np.reshape(params[hidden_size * (input_size + <span class="number">1</span>):], (num_labels, (hidden_size + <span class="number">1</span>))))</span><br><span class="line"></span><br><span class="line">    a1, z2, a2, z3, h = forward_propagate(X, theta1, theta2)</span><br><span class="line"></span><br><span class="line">    J = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">        first_term = np.multiply(-y[i, :], np.log(h[i, :]))</span><br><span class="line">        second_term = np.multiply(<span class="number">1</span> - y[i, :], np.log(<span class="number">1</span> - h[i, :]))</span><br><span class="line">        J += np.sum(first_term - second_term)</span><br><span class="line"></span><br><span class="line">    J = J/m</span><br><span class="line"></span><br><span class="line">    J += (float(learning_rate) / (<span class="number">2</span> * m)) * (np.sum(np.power(theta1[:, <span class="number">1</span>:], <span class="number">2</span>)) + np.sum(np.power(theta2[:, <span class="number">1</span>:], <span class="number">2</span>)))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> J</span><br><span class="line">input_size = <span class="number">400</span></span><br><span class="line">hidden_size = <span class="number">25</span></span><br><span class="line">num_labels = <span class="number">10</span></span><br><span class="line">learning_rate = <span class="number">1</span></span><br><span class="line">params = (np.random.random(size=hidden_size * (input_size + <span class="number">1</span>) + num_labels * (hidden_size + <span class="number">1</span>)) - <span class="number">0.5</span>) * <span class="number">0.25</span></span><br><span class="line"><span class="comment">#print(cost(params, input_size, hidden_size, num_labels, X, y_onehot, learning_rate))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sigmoid_gradient</span><span class="params">(z)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> np.multiply(sigmoid(z), (<span class="number">1</span> - sigmoid(z)))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">back_prop</span><span class="params">(params, input_size, hidden_size, num_labels, X, y, learning_rate)</span>:</span></span><br><span class="line">    <span class="string">'''反向传播算法'''</span></span><br><span class="line">    m = X.shape[<span class="number">0</span>]</span><br><span class="line">    X = np.matrix(X)</span><br><span class="line">    y = np.matrix(y)</span><br><span class="line"></span><br><span class="line">    theta1 = np.matrix(np.reshape(params[:hidden_size * (input_size + <span class="number">1</span>)], (hidden_size, (input_size + <span class="number">1</span>))))</span><br><span class="line">    theta2 = np.matrix(np.reshape(params[hidden_size * (input_size + <span class="number">1</span>):], (num_labels, (hidden_size + <span class="number">1</span>))))</span><br><span class="line"></span><br><span class="line">    a1, z2, a2, z3, h = forward_propagate(X, theta1, theta2)</span><br><span class="line"></span><br><span class="line">    J = <span class="number">0</span></span><br><span class="line">    delta1 = np.zeros(theta1.shape)</span><br><span class="line">    delta2 = np.zeros(theta2.shape)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">        first_term = np.multiply(-y[i, :], np.log(h[i, :]))</span><br><span class="line">        second_term = np.multiply(<span class="number">1</span> - y[i, :], np.log(<span class="number">1</span> - h[i, :]))</span><br><span class="line">        J += np.sum(first_term - second_term)</span><br><span class="line"></span><br><span class="line">    J = J / m</span><br><span class="line"></span><br><span class="line">    J += (float(learning_rate) / (<span class="number">2</span> * m)) * (np.sum(np.power(theta1[:, <span class="number">1</span>:], <span class="number">2</span>)) + np.sum(np.power(theta2[:, <span class="number">1</span>:], <span class="number">2</span>)))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> range(m):</span><br><span class="line">        a1t = a1[t, :]</span><br><span class="line">        z2t = z2[t, :]</span><br><span class="line">        a2t = a2[t, :]</span><br><span class="line">        ht = h[t, :]</span><br><span class="line">        yt = y[t, :]</span><br><span class="line"></span><br><span class="line">        d3t = ht - yt</span><br><span class="line">        z2t = np.insert(z2t, <span class="number">0</span>, values=np.ones(<span class="number">1</span>))</span><br><span class="line">        d2t = np.multiply((theta2.T * d3t.T).T, sigmoid_gradient(z2t))</span><br><span class="line"></span><br><span class="line">        delta1 = delta1 + (d2t[:, <span class="number">1</span>:]).T * a1t</span><br><span class="line">        delta2 = delta2 + d3t.T * a2t</span><br><span class="line"></span><br><span class="line">    delta1 /= m</span><br><span class="line">    delta2 /= m</span><br><span class="line"></span><br><span class="line">    delta1[:, <span class="number">1</span>:] = delta1[:, <span class="number">1</span>:] + (theta1[:, <span class="number">1</span>:] * learning_rate) / m</span><br><span class="line">    delta2[:, <span class="number">1</span>:] = delta2[:, <span class="number">1</span>:] + (theta2[:, <span class="number">1</span>:] * learning_rate) / m</span><br><span class="line"></span><br><span class="line">    grad = np.concatenate((np.ravel(delta1), np.ravel(delta2)))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> J, grad</span><br><span class="line"></span><br><span class="line">fmin = opt.minimize(fun=back_prop, x0=params, args=(input_size, hidden_size, num_labels, X, y_onehot, learning_rate),</span><br><span class="line">                    method=<span class="string">'TNC'</span>, jac=<span class="literal">True</span>, options=&#123;<span class="string">'maxiter'</span>: <span class="number">250</span>&#125;)</span><br><span class="line"></span><br><span class="line">X = np.matrix(X)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">X = np.matrix(X)</span><br><span class="line">theta1 = np.matrix(np.reshape(fmin.x[:hidden_size * (input_size + <span class="number">1</span>)], (hidden_size, (input_size + <span class="number">1</span>))))</span><br><span class="line">theta2 = np.matrix(np.reshape(fmin.x[hidden_size * (input_size + <span class="number">1</span>):], (num_labels, (hidden_size + <span class="number">1</span>))))</span><br><span class="line"></span><br><span class="line">a1, z2, a2, z3, h = forward_propagate(X, theta1, theta2)</span><br><span class="line">y_pred = np.array(np.argmax(h, axis=<span class="number">1</span>) + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#准确度</span></span><br><span class="line">print(classification_report(y, y_pred))</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>ML</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>吴恩达《机器学习》——第三次作业：多元分类</title>
    <url>/2019/05/18/%E5%90%B4%E6%81%A9%E8%BE%BE%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E2%80%94%E2%80%94%E7%AC%AC%E4%B8%89%E6%AC%A1%E4%BD%9C%E4%B8%9A%EF%BC%9A%E5%A4%9A%E5%85%83%E5%88%86%E7%B1%BB/</url>
    <content><![CDATA[<p>写了好长时间的驼峰命名，最近有点恶心了，决定python用下划线，C++用驼峰。<br>这次作业是对手写数字的数据集进行训练。多元分类的一个任务。</p>
<p>参考：<a href="https://github.com/fengdu78/Coursera-ML-AndrewNg-Notes/tree/master/code" target="_blank" rel="noopener">https://github.com/fengdu78/Coursera-ML-AndrewNg-Notes/tree/master/code</a></p>
<a id="more"></a>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> scipy.io <span class="keyword">as</span> sio</span><br><span class="line"><span class="keyword">import</span> matplotlib</span><br><span class="line"><span class="keyword">import</span> scipy.optimize <span class="keyword">as</span> opt</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> classification_report</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_data</span><span class="params">(path, transpose=True)</span>:</span></span><br><span class="line">    <span class="string">'''载入数据'''</span></span><br><span class="line">    data = sio.loadmat(path)</span><br><span class="line">    y = data.get(<span class="string">'y'</span>)</span><br><span class="line"></span><br><span class="line">    y = y.reshape(y.shape[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    X = data.get(<span class="string">'X'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> transpose:</span><br><span class="line">        X = np.array([im.reshape((<span class="number">20</span>, <span class="number">20</span>)).T <span class="keyword">for</span> im <span class="keyword">in</span> X])</span><br><span class="line"></span><br><span class="line">        X = np.array([im.reshape(<span class="number">400</span>) <span class="keyword">for</span> im <span class="keyword">in</span> X])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> X, y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">raw_X, raw_y = load_data(<span class="string">'ex3data1.mat'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#def plot_image(image):</span></span><br><span class="line"><span class="comment">#    '''随机显示一张图片'''</span></span><br><span class="line"><span class="comment">#    fig, ax = plt.subplots(figsize=(1, 1))</span></span><br><span class="line"><span class="comment">#    ax.matshow(image.reshape((20, 20)), cmap=matplotlib.cm.binary)</span></span><br><span class="line"><span class="comment">#    plt.xticks(np.array([]))</span></span><br><span class="line"><span class="comment">#    plt.yticks(np.array([]))</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#pick_one = np.random.randint(0, 5000)              #在(0,5000)氛围内随机取一个数</span></span><br><span class="line"><span class="comment">#plot_image(X[pick_one, :])</span></span><br><span class="line"><span class="comment">#plt.show()</span></span><br><span class="line"><span class="comment">#print("this should be &#123;&#125;".format(y[pick_one]))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#def plot_100_image(X):</span></span><br><span class="line"><span class="comment">#    '''显示100张图片'''</span></span><br><span class="line"><span class="comment">#    size = int(np.sqrt(X.shape[1]))</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#    sample_idx = np.random.choice(np.arange(X.shape[0]), 100)</span></span><br><span class="line"><span class="comment">#    sample_images = X[sample_idx, :]</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#    fig, ax_array = plt.subplots(nrows=10, ncols=10, sharey=True, sharex=True, figsize=(8, 8))</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#    for r in range(10):</span></span><br><span class="line"><span class="comment">#        for c in range(10):</span></span><br><span class="line"><span class="comment">#            ax_array[r, c].matshow(sample_images[10 * r + c].reshape((size, size)),</span></span><br><span class="line"><span class="comment">#                                   cmap=matplotlib.cm.binary)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#            plt.xticks(np.array([]))</span></span><br><span class="line"><span class="comment">#            plt.yticks(np.array([]))</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#准备数据</span></span><br><span class="line">X = np.insert(raw_X, <span class="number">0</span>, values=np.ones(raw_X.shape[<span class="number">0</span>]), axis=<span class="number">1</span>)     <span class="comment">#插入第一列，全部为1</span></span><br><span class="line"></span><br><span class="line">y_matrix = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>):</span><br><span class="line">    y_matrix.append((raw_y == k).astype(int))</span><br><span class="line"></span><br><span class="line">y_matrix = [y_matrix[<span class="number">-1</span>]] + y_matrix[:<span class="number">-1</span>]</span><br><span class="line">y = np.array(y_matrix)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#print(y.shape)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#训练一维模型</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sigmoid</span><span class="params">(z)</span>:</span></span><br><span class="line">    <span class="string">'''激活函数'''</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> / (<span class="number">1</span> + np.exp(-z))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gradient</span><span class="params">(theta, X, y)</span>:</span></span><br><span class="line">    <span class="string">'''一次梯度下降'''</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1</span> / len(X)) * X.T @ (sigmoid(X@theta) - y)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cost</span><span class="params">(theta, X, y)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="string">'''代价函数'''</span></span><br><span class="line">    h = sigmoid(X@theta)</span><br><span class="line">    inner = y.T * np.log(h) + (<span class="number">1</span>-y).T*np.log(<span class="number">1</span>-h)</span><br><span class="line">    <span class="keyword">return</span> - (np.sum(inner)/len(X))</span><br><span class="line">    <span class="comment">#return np.mean(-y * np.log(sigmoid(X*theta.T)) - (1-y)*np.log(1-sigmoid(X*theta.T)))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">regularized_cost</span><span class="params">(theta, X, y, l=<span class="number">1</span>)</span>:</span></span><br><span class="line">    <span class="string">'''正则化'''</span></span><br><span class="line">    theta_j1_to_n = theta[<span class="number">1</span>:]</span><br><span class="line">    regularized_term = (<span class="number">1</span> / (<span class="number">2</span> * len(X))) * np.power(theta_j1_to_n, <span class="number">2</span>).sum()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cost(theta, X, y) + regularized_term</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">regularized_gradient</span><span class="params">(theta, X, y, l=<span class="number">1</span>)</span>:</span></span><br><span class="line"></span><br><span class="line">    theta_j1_to_n = theta[:<span class="number">-1</span>]</span><br><span class="line">    regularized_theta = (l / len(X)) * theta_j1_to_n</span><br><span class="line"></span><br><span class="line">    regularized_term = np.concatenate([np.array([<span class="number">0</span>]), regularized_theta])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> gradient(theta, X, y) + regularized_term</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logistic_regression</span><span class="params">(X, y, l=<span class="number">1</span>)</span>:</span></span><br><span class="line"></span><br><span class="line">    theta = np.zeros(X.shape[<span class="number">1</span>])</span><br><span class="line">    res = opt.minimize(fun=regularized_cost,</span><br><span class="line">                       x0=theta,</span><br><span class="line">                       args=(X, y, l),</span><br><span class="line">                       method=<span class="string">'TNC'</span>,</span><br><span class="line">                       jac=regularized_gradient,</span><br><span class="line">                       options=&#123;<span class="string">'disp'</span>: <span class="literal">True</span>&#125;)</span><br><span class="line"></span><br><span class="line">    final_theta = res.x</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> final_theta</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(x, theta)</span>:</span></span><br><span class="line">    <span class="string">'''预测函数'''</span></span><br><span class="line">    prob = sigmoid(X @ theta)</span><br><span class="line">    <span class="keyword">return</span> (prob &gt;= <span class="number">0.5</span>).astype(int)</span><br><span class="line"></span><br><span class="line">t0 = logistic_regression(X, y[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#print(t0.shape)</span></span><br><span class="line"><span class="comment">#y_pred = predict(X, t0)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#print('Accuracy = &#123;&#125;'.format(np.mean(y[0] == y_pred)))</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#训练k维模型</span></span><br><span class="line"></span><br><span class="line">k_theta = np.array([logistic_regression(X, y[k]) <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">10</span>)])</span><br><span class="line"><span class="comment">#print(k_theta.shape)</span></span><br><span class="line"></span><br><span class="line">prob_matrix = sigmoid(X@k_theta.T)</span><br><span class="line">np.set_printoptions(suppress=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">y_pred = np.argmax(prob_matrix, axis=<span class="number">1</span>)</span><br><span class="line"><span class="comment">#返回沿轴axis最大值的索引，axis=1代表行</span></span><br><span class="line"></span><br><span class="line">y_answer = raw_y.copy()</span><br><span class="line">y_answer[y_answer == <span class="number">10</span>] = <span class="number">0</span></span><br><span class="line">print(classification_report(y_answer, y_pred))</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>ML</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>用神经网络实现异或运算</title>
    <url>/2019/05/14/%E7%94%A8%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<p><img src="https://img-blog.csdnimg.cn/20190514155909150.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NoZXJpc2hfeA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<a id="more"></a>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logistic</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sigmoid</span><span class="params">(self, z)</span>:</span></span><br><span class="line">        <span class="string">'''激活函数'''</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> / (<span class="number">1</span> + np.exp(-z))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">logistic</span><span class="params">(self, X, theta)</span>:</span></span><br><span class="line">        <span class="string">'''一层神经网络进行简单的逻辑运算'''</span></span><br><span class="line">        h = self.sigmoid(X*theta.T)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(int(h.shape[<span class="number">1</span>])):</span><br><span class="line">            h[<span class="number">0</span>, i] = <span class="number">1</span> <span class="keyword">if</span> h[<span class="number">0</span>, i] &gt;= <span class="number">0.5</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> h</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">X = np.matrix(np.array([<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]))</span><br><span class="line">theta1 = np.matrix([[<span class="number">-30</span>, <span class="number">20</span>, <span class="number">20</span>], [<span class="number">10</span>, <span class="number">-20</span>, <span class="number">-20</span>]])     <span class="comment">#第一层网络的权重</span></span><br><span class="line">theta2 = np.matrix([<span class="number">-10</span>, <span class="number">20</span>, <span class="number">-20</span>])                      <span class="comment">#第二层网络的权重</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">log = Logistic()       <span class="comment">#实例化</span></span><br><span class="line"></span><br><span class="line">a1 = log.logistic(X, theta1)         <span class="comment">#第一层</span></span><br><span class="line">a1 = np.c_[<span class="number">1</span>, a1]                    <span class="comment">#添加偏置单元</span></span><br><span class="line">a2 = log.logistic(a1, theta2)        <span class="comment">#第二层</span></span><br><span class="line">print(a2)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>ML</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title>初识动态规划</title>
    <url>/2019/05/14/%E5%88%9D%E8%AF%86%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<p>﻿<a href="https://mp.weixin.qq.com/s/3h9iqU4rdH3EIy5m6AzXsg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/3h9iqU4rdH3EIy5m6AzXsg</a><br>很可爱的漫画。讲的不错，通俗易懂。mark以下，这里就只记一些概念性问题。<br>动态规划的英文名Dynamic Programming，是一种分阶段求解决问题的数学思想。它不止应用于编程领域，也应用于管理学、经济学、生物学。</p>
<a id="more"></a>

<p>它的思想是：<strong>大事化小，小事化了</strong><br>动态规划当中包含三个重要的概念：<strong>最优子结构</strong>，<strong>边界</strong>，<strong>状态转移公式</strong><br>通过下面漫画提到的题目对三个概念阐述。<br><img src="https://img-blog.csdnimg.cn/20190514100652421.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NoZXJpc2hfeA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">    在最后一级台阶，由2种走法，第一种：从第九级台阶跨一步到达第十级台阶；第二种：从第八级台阶跨2步到达第十级台阶。那是不是说，到达第十级台阶的走法有多少种，是由到达第八级台阶和到底第九级台阶的走法之和决定的呢？<br>当然是的。<br>因此，可以以此类推，直到第一级台阶或者第二级台阶。<br>用公式简化过程：<br>f(n)表示到达第n级台阶的走法，由上面分析，有<br>f(10) = f(9) + f(8)<br>f(9) = f(8) + f(7)<br>。。。<br>f(3) = f(2) + f(1)<br>归纳：<br>f(1) = 1<br>f(2) = 2<br>f(n) = f(n-1) + f(n-2)  (n&gt;=3)<br>刚才分析出f(10) = f(9) + f(8)，因此f(9)和f(8)是f(10)的<strong>最优子结构</strong><br>当只用一级台阶或2级台阶的时候，我们可以直接得出结果，无需继续简化。我们成f(1)和f(2)为问题<strong>边界</strong>。如果一个问题没有边界，将永远无法得到有限的结果。<br>f(n) = f(n-1) + f(n-2)是阶段与阶段之间的<strong>状态转移方程</strong>。这是动态规划的核心，决定了问题的每一个阶段和下一个阶段的关系。<br>其实分析到这里后，和漫画里的小灰一样，我的第一反应也是用递归做，毕竟递归方程和边界都给出了。<br>下面给出递归的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dp</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">elif</span> n == <span class="number">1</span> <span class="keyword">or</span> n == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> dp(n<span class="number">-1</span>) + dp(n<span class="number">-2</span>)</span><br></pre></td></tr></table></figure>

<p>但是递归的时间复杂度有点高。<img src="https://img-blog.csdnimg.cn/20190514103043450.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NoZXJpc2hfeA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>差不多应该是O(2^n)。<br>从上图可以看出有些数据被重复计算了，那么我们可将这些数据缓存下来。<br>下面用<strong>备忘录算法</strong>优化一下。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">hashMap = &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dp</span><span class="params">(n, hashMap)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span> <span class="keyword">or</span> n == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    <span class="keyword">elif</span> n <span class="keyword">in</span> hashMap:</span><br><span class="line">        <span class="keyword">return</span> hashMap[n]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        hashMap[n] = dp(n<span class="number">-1</span>, hashMap) + dp(n<span class="number">-2</span>, hashMap)</span><br><span class="line">        <span class="keyword">return</span> hashMap[n]</span><br></pre></td></tr></table></figure>

<p>这样时间复杂度就降到了O(n)，但是空间复杂度也就变成了O(n)。<br>上面的两种实现方法都是自顶向下递归实现的，因此也就无法利用之前计算的结果。因为本题归纳的公式，我们可以看出如果自低向上迭代运算，在下一次运算可以用到上次运算的结果。每一次迭代过程中，只要保留之前的两个状态，就可以推导出新的状态。这就是动态规划。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dp</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">elif</span> n == <span class="number">1</span> <span class="keyword">or</span> n == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    f1, f2 = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>, n+<span class="number">1</span>):</span><br><span class="line">        f1, f2 = f2, f1 + f2</span><br><span class="line">    <span class="keyword">return</span> f2</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>吴恩达《机器学习》第二次作业——逻辑回归</title>
    <url>/2019/05/10/%E5%90%B4%E6%81%A9%E8%BE%BE%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E7%AC%AC%E4%BA%8C%E6%AC%A1%E4%BD%9C%E4%B8%9A%E2%80%94%E2%80%94%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/</url>
    <content><![CDATA[<p>  ﻿ 1. 逻辑回归<br>       给的数据集有两个特征变量。<br>            设想你是大学相关部分的管理者，想通过申请学生两次测试的评分，来决定他们是否被录取。现在你拥有之前申请学生的可以用于训练逻辑回归的训练样本集。对于每一个训练样本，你有他们两次测试的评分和最后是被录取的结果。由此建立逻辑回归分类器。</p>
<p>注： <a href="https://github.com/fengdu78/Coursera-ML-AndrewNg-Notes/tree/master/code" target="_blank" rel="noopener">https://github.com/fengdu78/Coursera-ML-AndrewNg-Notes/tree/master/code</a><br>github上并没有使用梯度下降来优化参数，应该是使用的是其他的优化算法（SciPy’s truncated newton（TNC））。</p>
<a id="more"></a>

<p>用梯度下降法优化参数，并不能很好的降低代价函数，相比于其他优化算法。可能是对于这个数据集来说，需要迭代相当多的次数。<br><img src="https://img-blog.csdnimg.cn/20190510104710116.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NoZXJpc2hfeA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> scipy.optimize <span class="keyword">as</span> opt</span><br><span class="line"></span><br><span class="line">path = <span class="string">'ex2data1.txt'</span>   <span class="comment">#相对路径</span></span><br><span class="line">data = pd.read_csv(path, header=<span class="literal">None</span>, names=[<span class="string">'First'</span>, <span class="string">'Second'</span>, <span class="string">'Admission'</span>])</span><br><span class="line"></span><br><span class="line"><span class="string">'''观察数据'''</span></span><br><span class="line"><span class="comment">#positive = data[data['Admission'].isin([1])]</span></span><br><span class="line"><span class="comment">#negative = data[data['Admission'].isin([0])]</span></span><br><span class="line"><span class="comment">#fig, ax = plt.subplots(figsize=(12, 8))</span></span><br><span class="line"><span class="comment">#ax.scatter(positive['First'], positive['Second'], s=50, c='b', marker='o', label='Admission')</span></span><br><span class="line"><span class="comment">#ax.scatter(negative['First'], negative['Second'], s=50, c='r', marker='x', label='Not Admission')</span></span><br><span class="line"><span class="comment">#ax.legend()</span></span><br><span class="line"><span class="comment">#ax.set_xlabel('First Score')</span></span><br><span class="line"><span class="comment">#ax.set_ylabel('Second Score')</span></span><br><span class="line"><span class="comment">#plt.show()</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">'''操作数据，以便后续处理'''</span></span><br><span class="line"><span class="comment">#data['First'] = (data['First'] - data['First'].mean())/data['First'].std()</span></span><br><span class="line"><span class="comment">#data['Second'] = (data['Second'] - data['Second'.mean()])/data['Second'].std()  #特征缩放，</span></span><br><span class="line"></span><br><span class="line">data.insert(<span class="number">0</span>, <span class="string">'Ones'</span>, <span class="number">1</span>)</span><br><span class="line">cols = data.shape[<span class="number">1</span>]                <span class="comment">#data的列数</span></span><br><span class="line">X = data.iloc[:, <span class="number">0</span>:cols<span class="number">-1</span>]          <span class="comment">#特征变量</span></span><br><span class="line">y = data.iloc[:, cols<span class="number">-1</span>:cols]       <span class="comment">#目标变量</span></span><br><span class="line">X = np.matrix(X.values)             <span class="comment">#转为矩阵</span></span><br><span class="line">y = np.matrix(y.values)</span><br><span class="line">theta = np.matrix(np.array([<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(X.shape[<span class="number">1</span>])]))         <span class="comment">#初始化θ的值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sigmoid</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="string">'''sigmoid函数'''</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> / (<span class="number">1</span> + np.exp(-x))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">computeCost</span><span class="params">(X, y, theta)</span>:</span></span><br><span class="line">    <span class="string">'''代价函数'''</span></span><br><span class="line">    h = sigmoid(X * theta.T)</span><br><span class="line">    inner = y.T*np.log(h) + (<span class="number">1</span>-y).T*np.log(<span class="number">1</span>-h)</span><br><span class="line">    <span class="keyword">return</span> -(np.sum(inner)/X.shape[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">alpha = <span class="number">0.001</span></span><br><span class="line">iters = <span class="number">150000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gradienDescent</span><span class="params">(X, y, theta, alpha, iters)</span>:</span></span><br><span class="line">    cost = np.zeros(iters)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(iters):</span><br><span class="line">        h = sigmoid(X * theta.T) - y</span><br><span class="line">        innre = X.T * h</span><br><span class="line">        theta = theta - (alpha/len(X)) * innre.T</span><br><span class="line">        cost[i] = computeCost(X, y, theta)</span><br><span class="line">    <span class="keyword">return</span> theta, cost</span><br><span class="line"></span><br><span class="line">theta, cost = gradienDescent(X, y, theta, alpha, iters)</span><br><span class="line"><span class="comment">#print(cost[-1])</span></span><br><span class="line"></span><br><span class="line"><span class="string">'''观察代价函数的迭代'''</span></span><br><span class="line"><span class="comment">#fig, ax = plt.subplots(figsize=(12, 8))</span></span><br><span class="line"><span class="comment">#ax.plot(np.arange(iters), cost, 'r')</span></span><br><span class="line"><span class="comment">#ax.set_xlabel('Iterations')</span></span><br><span class="line"><span class="comment">#ax.set_ylabel('Cost')</span></span><br><span class="line"><span class="comment">#ax.set_title('Error vs. Ttainging Epoch')</span></span><br><span class="line"><span class="comment">#plt.show()</span></span><br><span class="line"></span><br><span class="line"><span class="string">'''检测逻辑回归分类器的精度'''</span></span><br><span class="line">probability = sigmoid(X * theta.T)</span><br><span class="line">predictions = [<span class="number">1</span> <span class="keyword">if</span> x &gt;= <span class="number">0.5</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">for</span> x <span class="keyword">in</span> probability]</span><br><span class="line">correct = [<span class="number">1</span> <span class="keyword">if</span> ((a == <span class="number">1</span> <span class="keyword">and</span> b == <span class="number">1</span>) <span class="keyword">or</span> (a == <span class="number">0</span> <span class="keyword">and</span> b == <span class="number">0</span>)) <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">for</span> (a, b) <span class="keyword">in</span> zip(predictions, y)]</span><br><span class="line">accuracy = (sum(map(int, correct)) % len(correct))</span><br><span class="line">print(<span class="string">'accuracy = &#123;0&#125;%'</span>.format(accuracy))</span><br></pre></td></tr></table></figure>

<ul>
<li>逻辑回归的正则化</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> scipy.optimize <span class="keyword">as</span> opt</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">path = <span class="string">'ex2data2.txt'</span></span><br><span class="line"></span><br><span class="line">data2 = pd.read_csv(path, header=<span class="literal">None</span>, names=[<span class="string">'Test1'</span>, <span class="string">'Test2'</span>, <span class="string">'Accepted'</span>])</span><br><span class="line"></span><br><span class="line">degree = <span class="number">5</span></span><br><span class="line">x1 = data2[<span class="string">'Test1'</span>]</span><br><span class="line">x2 = data2[<span class="string">'Test2'</span>]</span><br><span class="line"></span><br><span class="line">data2.insert(<span class="number">3</span>, <span class="string">'Ones'</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, degree):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(i):</span><br><span class="line">        data2[<span class="string">'F'</span> + str(i) + str(j)] = np.power(x1, i- j) * np.power(x2, j)</span><br><span class="line"></span><br><span class="line">data2.drop(<span class="string">'Test1'</span>, axis=<span class="number">1</span>, inplace=<span class="literal">True</span>)</span><br><span class="line">data2.drop(<span class="string">'Test2'</span>, axis=<span class="number">1</span>, inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sigmoid</span><span class="params">(z)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> / (<span class="number">1</span> + np.exp(-z))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cost</span><span class="params">(theta, X, y, learningRate)</span>:</span></span><br><span class="line">    theta = np.matrix(theta)</span><br><span class="line">    X = np.matrix(X)</span><br><span class="line">    y = np.matrix(y)</span><br><span class="line">    first = np.multiply(-y, np.log(sigmoid(X * theta.T)))</span><br><span class="line">    second = np.multiply((<span class="number">1</span> - y), np.log(<span class="number">1</span> - sigmoid(X * theta.T)))</span><br><span class="line">    reg = (learningRate / (<span class="number">2</span> * len(X))) * np.sum(np.power(theta[:,<span class="number">1</span>:theta.shape[<span class="number">1</span>]], <span class="number">2</span>))</span><br><span class="line">    <span class="keyword">return</span> np.sum(first - second) / len(X) + reg</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gradientReg</span><span class="params">(theta, X, y, learningRate)</span>:</span></span><br><span class="line">    theta = np.matrix(theta)</span><br><span class="line">    X = np.matrix(X)</span><br><span class="line">    y = np.matrix(y)</span><br><span class="line"></span><br><span class="line">    parameters = int(theta.ravel().shape[<span class="number">1</span>])</span><br><span class="line">    grad = np.zeros(parameters)</span><br><span class="line"></span><br><span class="line">    error = sigmoid(X * theta.T) - y</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(parameters):</span><br><span class="line">        term = np.multiply(error, X[:, i])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>):</span><br><span class="line">            grad[i] = np.sum(term) / len(X)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            grad[i] = (np.sum(term) / len(X)) + ((learningRate / len(X)) * theta[:, i])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> grad</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># set X and y (remember from above that we moved the label to column 0)</span></span><br><span class="line">cols = data2.shape[<span class="number">1</span>]</span><br><span class="line">X2 = data2.iloc[:,<span class="number">1</span>:cols]</span><br><span class="line">y2 = data2.iloc[:,<span class="number">0</span>:<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># convert to numpy arrays and initalize the parameter array theta</span></span><br><span class="line">X2 = np.array(X2.values)</span><br><span class="line">y2 = np.array(y2.values)</span><br><span class="line">theta2 = np.zeros(<span class="number">11</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">learningRate = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">result2 = opt.fmin_tnc(func=cost, x0=theta2, fprime=gradientReg, args=(X2, y2, learningRate))</span><br><span class="line"></span><br><span class="line">theta = np.matrix(result2[<span class="number">0</span>])</span><br><span class="line">probability = sigmoid(X2 * theta.T)</span><br><span class="line">predictions = [<span class="number">1</span> <span class="keyword">if</span> x &gt;= <span class="number">0.5</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">for</span> x <span class="keyword">in</span> probability]</span><br><span class="line">correct = [<span class="number">1</span> <span class="keyword">if</span> ((a == <span class="number">1</span> <span class="keyword">and</span> b == <span class="number">1</span>) <span class="keyword">or</span> (a == <span class="number">0</span> <span class="keyword">and</span> b == <span class="number">0</span>)) <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">for</span> (a, b) <span class="keyword">in</span> zip(predictions, y2)]</span><br><span class="line">accuracy = (sum(map(int, correct)) % len(correct))</span><br><span class="line">print(<span class="string">'accuracy = &#123;0&#125;%'</span>.format(accuracy))</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>ML</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>VS2017生成的.exe文件无法在其他电脑上运行的解决方法</title>
    <url>/2019/05/02/VS2017%E7%94%9F%E6%88%90%E7%9A%84.exe%E6%96%87%E4%BB%B6%E6%97%A0%E6%B3%95%E5%9C%A8%E5%85%B6%E5%AE%83%E7%94%B5%E8%84%91%E4%B8%8A%E8%BF%90%E8%A1%8C%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<ol>
<li><p>项目-&gt;属性–&gt;配置属性–&gt;常规–&gt;MFC的使用。<br>  将其改为在静态库中使用MFC。然后重新编译。</p>
<ol start="2">
<li><p>具体过程如下图</p>
<a id="more"></a>

</li>
</ol>
</li>
</ol>
<p>以本工程为例。<br>在<strong>项目</strong>里面选择<strong>test521属性</strong>。<br><img src="https://img-blog.csdnimg.cn/20190502210356274.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NoZXJpc2hfeA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">将<strong>常规</strong>里的<strong>MFC的使用</strong>更改为<strong>在静态库中使用MFC</strong><br><img src="https://img-blog.csdnimg.cn/20190502210714214.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NoZXJpc2hfeA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>最后重新编译生成即可。</p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>vs2017</tag>
      </tags>
  </entry>
  <entry>
    <title>各种排序算法的python实现</title>
    <url>/2019/04/28/%E5%90%84%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84python%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>﻿ - 冒泡排序</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sortBubble</span><span class="params">(array)</span>:</span></span><br><span class="line">    <span class="string">'''冒泡排序'''</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(len(array)):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(array)<span class="number">-1</span>-j):</span><br><span class="line">            <span class="keyword">if</span> array[i] &gt; array[i+<span class="number">1</span>]:</span><br><span class="line">                array[i], array[i+<span class="number">1</span>] = array[i+<span class="number">1</span>], array[i]</span><br><span class="line"></span><br><span class="line">A = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">23</span>,<span class="number">12</span>,<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">sortBubble(A)</span><br><span class="line">print(A)</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>结果：<br><img src="https://img-blog.csdnimg.cn/2019042820195042.png" alt="冒泡排序"></p>
<ul>
<li>选择排序</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sortSelection</span><span class="params">(array)</span>:</span></span><br><span class="line">    <span class="string">'''冒泡排序'''</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(len(array)):</span><br><span class="line">        min = array[j]</span><br><span class="line">        k = j</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(j, len(array)):</span><br><span class="line">            <span class="keyword">if</span> array[i] &lt; min:</span><br><span class="line">                min = array[i]</span><br><span class="line">                k = i</span><br><span class="line">        array[k], array[j] = array[j], array[k]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">list = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">32</span>, <span class="number">1</span>]</span><br><span class="line">sortSelection(list)</span><br><span class="line">print(list)</span><br></pre></td></tr></table></figure>

<p>结果<br><img src="https://img-blog.csdnimg.cn/20190506161309466.png" alt="选择排序"></p>
<ul>
<li>快速排序</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">qsort</span><span class="params">(list)</span>:</span></span><br><span class="line">    <span class="string">'''快速排序'''</span></span><br><span class="line">    <span class="keyword">if</span> len(list) &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> list</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        mid = list[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">del</span> list[<span class="number">0</span>]</span><br><span class="line">        right, left = [], []</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> list:</span><br><span class="line">            <span class="keyword">if</span> x &gt;= mid:</span><br><span class="line">                right.append(x)</span><br><span class="line">            <span class="keyword">elif</span> x &lt; mid:</span><br><span class="line">                left.append(x)</span><br><span class="line">        <span class="keyword">return</span> qsort(left) + [mid] + qsort(right)</span><br><span class="line"></span><br><span class="line">num = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>]</span><br><span class="line">print(qsort(num))</span><br></pre></td></tr></table></figure>

<p>结果<br><img src="https://img-blog.csdnimg.cn/20190507211305725.png" alt="快速排序"></p>
<ul>
<li>直接插入排序</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_sort</span><span class="params">(array)</span>:</span></span><br><span class="line">    <span class="string">'''直接插入排序'''</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(array)):</span><br><span class="line">        temp = array[i]</span><br><span class="line">        j = i - <span class="number">1</span></span><br><span class="line">        print(array)</span><br><span class="line">        <span class="keyword">while</span> j &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> temp &lt; array[j]:</span><br><span class="line">                array[j+<span class="number">1</span>] = array[j]</span><br><span class="line">                j = j - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                array[j+<span class="number">1</span>] = temp</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        array[j + <span class="number">1</span>] = temp</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">array = [<span class="number">2</span>, <span class="number">1</span>,<span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>,<span class="number">5</span>]</span><br><span class="line">insert_sort(array)</span><br></pre></td></tr></table></figure>

<p>结果<br><img src="https://img-blog.csdnimg.cn/20190520202814260.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NoZXJpc2hfeA==,size_16,color_FFFFFF,t_70" alt="直接插入排序"></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>吴恩达《机器学习》第一次作业——多变量线性回归</title>
    <url>/2019/04/27/%E5%90%B4%E6%81%A9%E8%BE%BE%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BD%9C%E4%B8%9A%E2%80%94%E2%80%94%E5%A4%9A%E5%8F%98%E9%87%8F%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/</url>
    <content><![CDATA[<p>﻿看这里 <a href="https://github.com/fengdu78/Coursera-ML-AndrewNg-Notes/tree/master/code" target="_blank" rel="noopener">https://github.com/fengdu78/Coursera-ML-AndrewNg-Notes/tree/master/code</a><br>这是一位大神整理的作业代码。我也就是照葫芦画瓢，慢慢来吧。</p>
<a id="more"></a>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">path = <span class="string">'ex1data2.txt'</span>   <span class="comment">#相对路径</span></span><br><span class="line">data = pd.read_csv(path, header=<span class="literal">None</span>, names=[<span class="string">'Size'</span>, <span class="string">'Bedrooms'</span>, <span class="string">'Price'</span>])</span><br><span class="line"></span><br><span class="line"><span class="string">'''记录目标变量的均值和和差值'''</span></span><br><span class="line">meanPrice = data[<span class="string">'Price'</span>].mean()</span><br><span class="line">stdPrice = data[<span class="string">'Price'</span>].std()</span><br><span class="line"></span><br><span class="line"><span class="string">'''操作数据，以便后续处理'''</span></span><br><span class="line">data = (data-data.mean())/data.std()        <span class="comment">#特征缩放</span></span><br><span class="line">data.insert(<span class="number">0</span>, <span class="string">'Ones'</span>, <span class="number">1</span>)</span><br><span class="line">cols = data.shape[<span class="number">1</span>]</span><br><span class="line">X = data.iloc[:, <span class="number">0</span>:cols<span class="number">-1</span>]</span><br><span class="line">y = data.iloc[:, cols<span class="number">-1</span>:cols]</span><br><span class="line">X = np.matrix(X.values)     <span class="comment">#特征变量</span></span><br><span class="line">y = np.matrix(y.values)     <span class="comment">#目标变量</span></span><br><span class="line">theta = np.matrix(np.array([<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]))</span><br><span class="line"><span class="comment">#————————————————————————————————————————————————————</span></span><br><span class="line"><span class="comment">#cost function</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">computeCost</span><span class="params">(X, y, theta)</span>:</span></span><br><span class="line">    <span class="string">'''损失函数'''</span></span><br><span class="line">    inner = np.power((X*theta.T - y), <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> np.sum(inner) / (<span class="number">2</span> * len(X))</span><br><span class="line"></span><br><span class="line">alpha = <span class="number">0.01</span></span><br><span class="line">iters = <span class="number">1000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gradientDescent</span><span class="params">(X, y, theta, alpha, iters)</span>:</span></span><br><span class="line">    <span class="string">'''梯度下降算法'''</span></span><br><span class="line">    temp = np.matrix(np.zeros(theta.shape))</span><br><span class="line">    cost = np.zeros(iters)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(iters):</span><br><span class="line">        inner = X * theta.T - y</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(temp.shape[<span class="number">1</span>]):</span><br><span class="line">            term = np.multiply(inner, X[:, j])</span><br><span class="line">            temp[<span class="number">0</span>, j] = theta[<span class="number">0</span>, j] - (alpha/len(X))*np.sum(term)</span><br><span class="line">        theta = temp    <span class="comment">#更新theta</span></span><br><span class="line">        cost[i] = computeCost(X, y, theta)</span><br><span class="line">    <span class="keyword">return</span> theta, cost</span><br><span class="line"></span><br><span class="line"><span class="string">'''梯度下降'''</span></span><br><span class="line">theta, cost = gradientDescent(X, y, theta, alpha, iters)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">'''测试集'''</span></span><br><span class="line">testpath = <span class="string">'testdata2.txt'</span></span><br><span class="line">testdata = pd.read_csv(testpath, header=<span class="literal">None</span>, names=[<span class="string">'Size'</span>, <span class="string">'Bedrooms'</span>])</span><br><span class="line">testdata = (testdata-testdata.mean())/testdata.std()        <span class="comment">#特征缩放</span></span><br><span class="line">testdata.insert(<span class="number">0</span>, <span class="string">'Ones'</span>, <span class="number">1</span>)</span><br><span class="line">Td = np.matrix(testdata)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">h_theta_x</span><span class="params">(theta, Td)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> Td*theta.T</span><br><span class="line">d1 = h_theta_x(theta, X)*stdPrice + meanPrice    <span class="comment">#逆特征缩放</span></span><br><span class="line">d1 = d1.astype(np.int32)      <span class="comment">#将矩阵元素类型转换为整数</span></span><br><span class="line">print(<span class="string">'通过梯度下降'</span>)</span><br><span class="line">print(d1)</span><br><span class="line"></span><br><span class="line"><span class="string">'''绘图-cost function的收敛'''</span></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">12</span>,<span class="number">8</span>))</span><br><span class="line">ax.plot(np.arange(iters), cost, <span class="string">'r'</span>)</span><br><span class="line">ax.set_xlabel(<span class="string">'Iterations'</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">'Cost'</span>)</span><br><span class="line">ax.set_title(<span class="string">'Error vs. Training Epoch'</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#—————————————————————————————————————————————</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">normalEqn</span><span class="params">(X, y)</span>:</span></span><br><span class="line">    <span class="string">'''正规方程'''</span></span><br><span class="line">    theta = np.linalg.inv(X.T@X)@X.T@y</span><br><span class="line">    <span class="keyword">return</span> theta</span><br><span class="line"></span><br><span class="line">nEtheta = normalEqn(X, y)</span><br><span class="line"></span><br><span class="line"><span class="string">'''测试集'''</span></span><br><span class="line">testpath = <span class="string">'testdata2.txt'</span></span><br><span class="line">testdata = pd.read_csv(testpath, header=<span class="literal">None</span>, names=[<span class="string">'Size'</span>, <span class="string">'Bedrooms'</span>])</span><br><span class="line">testdata = (testdata-testdata.mean())/testdata.std()        <span class="comment">#特征均一化</span></span><br><span class="line">testdata.insert(<span class="number">0</span>, <span class="string">'Ones'</span>, <span class="number">1</span>)</span><br><span class="line">Td = np.matrix(testdata)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">h_theta_x</span><span class="params">(theta, Td)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> Td*theta.T</span><br><span class="line">d2 = h_theta_x(theta, X)*stdPrice + meanPrice    <span class="comment">#逆特征缩放</span></span><br><span class="line">d2 = d2.astype(np.int32)      <span class="comment">#将矩阵元素类型转换为整数</span></span><br><span class="line">print(<span class="string">'通过正规方程'</span>)</span><br><span class="line">print(d2)</span><br><span class="line"></span><br><span class="line">print(theta - nEtheta)		<span class="comment">#用梯度下降和正规方程求得的参数是不同的</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>ML</category>
      </categories>
      <tags>
        <tag>ML</tag>
      </tags>
  </entry>
  <entry>
    <title>队列的python实现</title>
    <url>/2019/04/26/%E9%98%9F%E5%88%97%E7%9A%84python%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>﻿队列（queue)，是一种<strong>操作受限的线性表</strong>。只允许在队列的一端添加元素，在队列的另一端删除元素。能添加元素的一端称为<strong>队尾</strong>，能删除元素的一端称为<strong>队头</strong>。</p>
<a id="more"></a>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    队列</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.__space = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isempty</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        判断队列是否为空</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="keyword">return</span> self.__space == []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">enqueue</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        添加元素到对头</span></span><br><span class="line"><span class="string">        :param item:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        self.__space.append(item)</span><br><span class="line">        <span class="comment">#self.__space.insert(0, item)</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dequeue</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        弹出元素从队尾</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        self.__space.pop(<span class="number">0</span>)</span><br><span class="line">        <span class="comment">#self.__space.pop()</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">access</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        返回队列中的全部元素</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="keyword">return</span> self.__space</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        队列元素个数</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="keyword">return</span> len(self.__space)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    qu = Queue()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>栈的python实现</title>
    <url>/2019/04/26/%E6%A0%88%E7%9A%84python%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>﻿栈（stack),是一种<strong>操作受限的线性表</strong>。它的特点是只能在线性表的一端添加元素、删除元素，能进行添加、删除的元素的一端称为栈顶（top），另外一端称为栈底。按照先进后出（LIFO）的原则进行元素操作。</p>
<a id="more"></a>

<p><img src="https://img-blog.csdnimg.cn/2019042619572083.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NoZXJpc2hfeA==,size_16,color_FFFFFF,t_70" alt="栈"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    堆栈</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.__space = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isempty</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        判断栈是否为空</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="keyword">return</span> self.__space == []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        添加一个元素到栈顶</span></span><br><span class="line"><span class="string">        :param item:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        self.__space.append(item)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        弹出栈顶元素</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        self.__space.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">access</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        访问栈内所有元素</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="keyword">if</span> self.__space:</span><br><span class="line">            <span class="keyword">return</span> self.__space</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        返回栈的元素个数</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="keyword">return</span> len(self.__space)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    s = Stack()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>python链表操作</title>
    <url>/2019/04/19/Python%E9%93%BE%E8%A1%A8%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>python的链表操作</p>
<a id="more"></a>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value=None, next=None)</span>:</span></span><br><span class="line">        self.__value = value</span><br><span class="line">        self.__next = next</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getValue</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self.__value</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getNext</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self.__next</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">setValue</span><span class="params">(self, newValue)</span>:</span></span><br><span class="line">    self.__value = newValue</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">setNext</span><span class="params">(self, nexNext)</span>:</span></span><br><span class="line">    self.__next = nexNext</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Link</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.__head = Node()             <span class="comment">#头结点，不存放元素，哨兵节点</span></span><br><span class="line">        self.__tail = <span class="literal">None</span></span><br><span class="line">        self.__length = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    判断链表是否为空</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="keyword">return</span> self.__head.getNext() == <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, value)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    头插法插入元素</span></span><br><span class="line"><span class="string">    :param value:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    newnode = Node(value, <span class="literal">None</span>)</span><br><span class="line">    newnode.setNext(self.__head.getNext())</span><br><span class="line">    self.__head.setNext(newnode)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">append</span><span class="params">(self, value)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    尾插法插入元素</span></span><br><span class="line"><span class="string">    :param value:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    newnode = Node(value)</span><br><span class="line">    <span class="keyword">if</span> self.isEmpty():</span><br><span class="line">        self.__head.setNext(newnode)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        current = self.__head.getNext()</span><br><span class="line">        <span class="keyword">while</span> current.getNext() != <span class="literal">None</span>:</span><br><span class="line">            current = current.getNext()</span><br><span class="line">        current.setNext(newnode)</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, value)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    查找链表中是否含有该元素</span></span><br><span class="line"><span class="string">    :param value:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    current = self.__head</span><br><span class="line">    foundvalue = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">while</span> current != <span class="literal">None</span> <span class="keyword">and</span> <span class="keyword">not</span> foundvalue:</span><br><span class="line">        <span class="keyword">if</span> current.getValue() == value:</span><br><span class="line">            foundvalue = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            current = current.getNext()</span><br><span class="line">    <span class="keyword">return</span> foundvalue</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(self, value)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    查找该元素在链表中的下标位置，</span></span><br><span class="line"><span class="string">    若没有则返回None</span></span><br><span class="line"><span class="string">    :param value:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    current = self._head</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    found = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">while</span> current != <span class="literal">None</span> <span class="keyword">and</span> <span class="keyword">not</span> found:</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> current.getValue() == value:</span><br><span class="line">            <span class="keyword">return</span> count</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    打印链表元素</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    current = self.__head.getNext()</span><br><span class="line">    <span class="keyword">while</span> current != <span class="literal">None</span>:</span><br><span class="line">        print(current.getValue())</span><br><span class="line">        current = current.getNext()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(self, value)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    删除指定元素</span></span><br><span class="line"><span class="string">    :param value:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    current = self._head</span><br><span class="line">    <span class="keyword">while</span> current.getNext() != <span class="literal">None</span> <span class="keyword">and</span> current.getNext().getValue() != value:</span><br><span class="line">        current = current.getNext()</span><br><span class="line">    <span class="keyword">if</span> current.getNext() == <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>                    <span class="comment">#链表中无此元素，删除失败</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        r = current.getNext()</span><br><span class="line">        current.setNext(r.getNext())</span><br><span class="line">        <span class="keyword">del</span> r</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>python删除列表元素的3种方法</title>
    <url>/2019/04/01/python%E5%88%A0%E9%99%A4%E5%88%97%E8%A1%A8%E5%85%83%E7%B4%A0%E7%9A%843%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>​    1. remove:删除单个元素，<strong>按值删除</strong> </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str = [<span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>]</span><br><span class="line">str.remove(<span class="number">2</span>)</span><br><span class="line">print(str)</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>pop:删除单个或多个元素，<strong>按位删除</strong></p>
<a id="more"></a>


</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">str.pop(<span class="number">2</span>)				<span class="comment">#会返回被删除的元素的值</span></span><br><span class="line">print(str)</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>del:<strong>按位删除（根据元素在列表中的位置）</strong></li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">del</span> str[<span class="number">0</span>]</span><br><span class="line">print(str)</span><br><span class="line"></span><br><span class="line">[<span class="number">2</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">del</span> str[<span class="number">0</span>:<span class="number">2</span>]			<span class="comment">#利用切片删除多个元素</span></span><br><span class="line">print(str)</span><br><span class="line"></span><br><span class="line">[<span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">del</span> str			<span class="comment">#删除整个列表</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>列表</tag>
      </tags>
  </entry>
  <entry>
    <title>十六进制转十进制的C语言实现</title>
    <url>/2018/09/05/%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E8%BD%AC%E5%8D%81%E8%BF%9B%E5%88%B6%E7%9A%84C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>嘻嘻，用到了前几天学到的循环队列，认识到了数据结构的魅力。<br>将输入的数据入队后，再挨个出队，首先检查队列的前两个数据是否为‘0x’<br>若是，再将其他数据出队，并且完成一系列操作。</p>
<a id="more"></a>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//————————————————————————</span></span><br><span class="line"><span class="comment">//十六进制转十进制（队列）</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxSize 10</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">product2</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">word2num</span><span class="params">(<span class="keyword">char</span> w)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hTod</span><span class="params">(<span class="keyword">char</span> a[])</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xQueue</span> &#123;</span></span><br><span class="line">	<span class="keyword">char</span> data[maxSize];</span><br><span class="line">	<span class="keyword">int</span> front, rear;</span><br><span class="line">	<span class="keyword">int</span> length;<span class="comment">//表示队列长度</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> a[<span class="number">50</span>];</span><br><span class="line">	gets(a);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,hTod(a));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hTod</span><span class="params">(<span class="keyword">char</span> a[])</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> c, b, d;</span><br><span class="line">	<span class="keyword">int</span> num = <span class="number">0</span>, numDem = <span class="number">0</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">xQueue</span> <span class="title">que</span>;</span></span><br><span class="line">	que.front = <span class="number">0</span>; que.rear = <span class="number">0</span>;</span><br><span class="line">	que.length = <span class="number">0</span>;<span class="comment">//初始化循环队列</span></span><br><span class="line">	<span class="keyword">char</span> *p = a;</span><br><span class="line">	<span class="keyword">while</span> (*p != <span class="string">'\0'</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (que.front == (que.rear + <span class="number">1</span>) % maxSize)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//队列满</span></span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			que.rear = (que.rear + <span class="number">1</span>) % maxSize;</span><br><span class="line">			que.data[que.rear] = *p++;</span><br><span class="line">			que.length++;</span><br><span class="line">		&#125;		</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	que.front = (que.front + <span class="number">1</span>) % maxSize;</span><br><span class="line">	c = que.data[que.front];</span><br><span class="line">	que.length--;</span><br><span class="line">	<span class="keyword">if</span> (c == <span class="string">'0'</span>) &#123;</span><br><span class="line">		que.front = (que.front + <span class="number">1</span>) % maxSize;</span><br><span class="line">		b = que.data[que.front];</span><br><span class="line">		que.length--;</span><br><span class="line">		<span class="keyword">if</span> (b != <span class="string">'x'</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-2</span>;<span class="comment">//表示输入不是十六进制</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">	<span class="keyword">while</span> (que.front != que.rear) &#123;</span><br><span class="line">		que.front = (que.front + <span class="number">1</span>) % maxSize;</span><br><span class="line">		d = que.data[que.front];</span><br><span class="line">		<span class="keyword">if</span> (d &gt;= <span class="string">'A'</span> &amp;&amp; d &lt;= <span class="string">'F'</span>)</span><br><span class="line">			num = word2num(d);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (d &gt;= <span class="string">'0'</span> &amp;&amp; d &lt;= <span class="string">'9'</span>)</span><br><span class="line">			num = d - <span class="string">'0'</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> <span class="number">-3</span>;<span class="comment">//表示不符合十六进制的格式</span></span><br><span class="line">		que.length--;</span><br><span class="line">		numDem = numDem + num*product2(que.length);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> numDem;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">word2num</span><span class="params">(<span class="keyword">char</span> w)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> num;</span><br><span class="line">	<span class="keyword">switch</span>(w) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">'A'</span>: num = <span class="number">10</span>; <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">'B'</span>: num = <span class="number">11</span>; <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">'C'</span>: num = <span class="number">12</span>; <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">'D'</span>: num = <span class="number">13</span>; <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">'E'</span>: num = <span class="number">14</span>; <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">'F'</span>: num = <span class="number">15</span>; <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:num = <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">product2</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">16</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">16</span> * product2(n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>循环队列</tag>
      </tags>
  </entry>
  <entry>
    <title>利用FFT频谱分析测量频率与幅值</title>
    <url>/2018/08/31/%E5%88%A9%E7%94%A8FFT%E9%A2%91%E8%B0%B1%E5%88%86%E6%9E%90%E6%B5%8B%E9%87%8F%E9%A2%91%E7%8E%87%E4%B8%8E%E5%B9%85%E5%80%BC/</url>
    <content><![CDATA[<p>之前做比赛的时候，发现这篇博客的访问量激增，意识到一丝不妙的感觉，就赶紧删除了，今天补一下。</p>
<p>之前幅值的问题也解决了。是我没把输入信号转成有符号信号送到FFT，而是直接将外部信号送入至FFT，虽然频率是对的，但是幅值就出现了很大的问题。<br>将信号转为有符号信号后，经FFT后得到最大值，然后根据AD的位宽，再转成响应的幅值。<br>——————————————————————————————————</p>
<a id="more"></a>

<p>先放几张仿真图，频谱分辨率分别是1 10 100 1000，输入信号频率是450Hz。我们可以从这几张图中，再次认识到用FFT做频谱分析出现误差的栅栏效应（在我上一篇博客中有详细讲解，当然大多是摘自高西全老师的《数字信号处理》一书） </p>
<p> <img src="https://img-blog.csdn.net/20180831172751335?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NoZXJpc2hfeA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br> <img src="https://img-blog.csdn.net/20180831172806767?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NoZXJpc2hfeA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br> <img src="https://img-blog.csdn.net/20180831172823100?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NoZXJpc2hfeA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br> <img src="https://img-blog.csdn.net/20180831172833689?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NoZXJpc2hfeA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>   利用FFT测频的思路是寻找最大幅值，确定最大幅值的RAM地址，再根据公式和频谱分辨率相称即可。用FFT测量幅值，我虽然没有做出来，可能是太废，但原理还是比较简单的。寻找到最大值后根据缩放因子进行左移或后移，再除于（N/2）。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span>  Mre_Fre(</span><br><span class="line">    <span class="keyword">input</span>                               clk,</span><br><span class="line">    <span class="keyword">input</span>                               rst_n,</span><br><span class="line">    <span class="keyword">input</span>               [<span class="number">1</span>:<span class="number">0</span>]           NumKey1,</span><br><span class="line">    <span class="keyword">input</span>               [<span class="number">9</span>:<span class="number">0</span>]           Data_In,</span><br><span class="line">    <span class="keyword">input</span>               [<span class="number">9</span>:<span class="number">0</span>]           WrAddr,</span><br><span class="line">    <span class="keyword">output</span>              [<span class="number">19</span>:<span class="number">0</span>]      Assignment,<span class="comment">//幅值</span></span><br><span class="line">    <span class="keyword">output</span>              [<span class="number">31</span>:<span class="number">0</span>]      Fre<span class="comment">//频率</span></span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span>     [<span class="number">9</span>:<span class="number">0</span>]       Fre_reso;<span class="comment">//频率分辨率</span></span><br><span class="line"><span class="keyword">always</span> @  (<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line">    <span class="keyword">if</span>(!rst_n)</span><br><span class="line">        Fre_reso &lt;= <span class="number">1'b1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">case</span>(NumKey1)</span><br><span class="line">            <span class="number">2'd0</span> :</span><br><span class="line">                Fre_reso &lt;= <span class="number">1'b1</span>;</span><br><span class="line">            <span class="number">2'd1</span> :</span><br><span class="line">                Fre_reso &lt;= <span class="number">4'd10</span>;</span><br><span class="line">            <span class="number">2'd2</span> :</span><br><span class="line">                Fre_reso &lt;= <span class="number">7'd100</span>;</span><br><span class="line">            <span class="number">2'd3</span> :</span><br><span class="line">                Fre_reso &lt;= <span class="number">10'd1000</span>;</span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//状态锁存      </span></span><br><span class="line"><span class="keyword">reg</span>     [<span class="number">9</span>:<span class="number">0</span>]       temp1,temp2,temp3;<span class="comment">//寄存器</span></span><br><span class="line"><span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line">    <span class="keyword">if</span>(!rst_n)</span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            temp1 &lt;= <span class="number">'d0</span>;</span><br><span class="line">            temp2 &lt;= <span class="number">'d0</span>;</span><br><span class="line">            temp3 &lt;= <span class="number">'d0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            temp1 &lt;= Data_In;</span><br><span class="line">            temp2 &lt;= temp1;</span><br><span class="line">            temp3 &lt;= temp2;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span>     [<span class="number">1</span>:<span class="number">0</span>]           status;<span class="comment">//状态</span></span><br><span class="line"><span class="keyword">reg</span>     [<span class="number">9</span>:<span class="number">0</span>]           A;<span class="comment">//幅值</span></span><br><span class="line"><span class="keyword">reg</span>     [<span class="number">31</span>:<span class="number">0</span>]      F;<span class="comment">//频率</span></span><br><span class="line"><span class="keyword">reg</span>                     Flag;<span class="comment">//峰值标志位</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line">    <span class="keyword">if</span>(!rst_n)</span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            status &lt;= <span class="number">'d0</span>;</span><br><span class="line">            A &lt;= <span class="number">'d0</span>;</span><br><span class="line">            F &lt;= <span class="number">'d0</span>;</span><br><span class="line">            Flag &lt;= <span class="number">'d0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">case</span>(status)</span><br><span class="line">            <span class="number">2'd0</span> :</span><br><span class="line">                <span class="keyword">if</span>(WrAddr == <span class="number">10'd1</span>)</span><br><span class="line">                    <span class="keyword">begin</span></span><br><span class="line">                        status &lt;= <span class="number">1'd1</span>;</span><br><span class="line">                        A &lt;= <span class="number">'d0</span>;</span><br><span class="line">                        F &lt;= <span class="number">'d0</span>;</span><br><span class="line">                        Flag &lt;= <span class="number">'d0</span>;</span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">begin</span></span><br><span class="line">                        Flag &lt;= <span class="number">'d0</span>;</span><br><span class="line">                        status &lt;= <span class="number">'d0</span>;</span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">            <span class="number">2'd1</span> :</span><br><span class="line">                <span class="keyword">if</span>(WrAddr &lt;= <span class="number">10'd512</span>)</span><br><span class="line">                    <span class="keyword">begin</span></span><br><span class="line">                        status &lt;= <span class="number">1'd1</span>;</span><br><span class="line">                        <span class="keyword">if</span>(temp2 - temp1 &gt; <span class="number">3'd5</span> &amp;&amp; temp2 &gt; temp3)</span><br><span class="line">                            <span class="keyword">begin</span></span><br><span class="line">                                <span class="keyword">if</span>(temp2 &gt;= A)</span><br><span class="line">                                    <span class="keyword">begin</span></span><br><span class="line">                                        F &lt;= WrAddr - <span class="number">2</span>;<span class="comment">//Ram的特性，会有两个地址的延迟。</span></span><br><span class="line">                                        A &lt;= temp2;</span><br><span class="line">                                    <span class="keyword">end</span></span><br><span class="line">                            <span class="keyword">end</span></span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">begin</span></span><br><span class="line">                        Flag &lt;= <span class="number">1'b1</span>;</span><br><span class="line">                        status &lt;= <span class="number">'d2</span>;                      </span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">            <span class="number">2'd2</span> :</span><br><span class="line">                status &lt;= <span class="number">'d0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span>  Fre = Flag ? F*Fre_reso : Fre;</span><br><span class="line"><span class="keyword">assign</span>  Assignment = Flag ? A * <span class="number">2</span> : Assignment;</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"><span class="meta">`</span></span><br></pre></td></tr></table></figure>

<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>FPGA</category>
      </categories>
      <tags>
        <tag>电赛</tag>
      </tags>
  </entry>
  <entry>
    <title>筛选法求100以内的素数</title>
    <url>/2018/08/31/%E7%AD%9B%E9%80%89%E6%B3%95%E6%B1%82100%E4%BB%A5%E5%86%85%E7%9A%84%E7%B4%A0%E6%95%B0/</url>
    <content><![CDATA[<p>将100个自然数有序排列。<br> 第一个数1不是质数也不是合数，不做处理。<br>第二个数2是质数，留下，并把100以内能将2整除的数划掉（置为1）<br>第三个数3是质数，留下，并把100以内能将3整除的数划掉（置1）</p>
<a id="more"></a>

<p>。<br>。<br>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isPreme</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> num[<span class="number">100</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++)&#123;</span><br><span class="line">		num[i<span class="number">-1</span>] = i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (num[i] == <span class="number">1</span>)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (num[i] != <span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; <span class="number">100</span>; j++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (num[j] % num[i] == <span class="number">0</span>)</span><br><span class="line">					num[j] = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (i == <span class="number">0</span>)	<span class="built_in">printf</span>(<span class="string">"%d\t"</span>, num[i]);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (num[i] != num[<span class="number">0</span>])</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d\t"</span>,num[i]);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>二分法求方程的根</title>
    <url>/2018/08/28/%E4%BA%8C%E5%88%86%E6%B3%95%E6%B1%82%E6%96%B9%E7%A8%8B%E7%9A%84%E6%A0%B9/</url>
    <content><![CDATA[<p>﻿二分法的原理其实还是零点定理的应用。</p>
<a id="more"></a>

<p>首先必须要有一个初试区间，而且区间端点的函数值异号，由零点定理可以知道在次区间内至少存在一个零点。然后取区间的中间值，这样就把一个区间分成了两个区间，再运用零点定理判断零点存在与哪个区间中，再在含有零点的区间取中间值，就以这样一次一次的取中间值，判断零点是否存在，当区间两端点的差的绝对值符合精度是即可停止。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//————————————————————</span></span><br><span class="line"><span class="comment">//二分法求近似的方程根</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span>	<span class="title">funY</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">double</span> x1 = <span class="number">-10</span>, x2 = <span class="number">10</span>;<span class="comment">//初试区间[-10，10]</span></span><br><span class="line">	<span class="keyword">double</span> x;</span><br><span class="line">	<span class="keyword">double</span> y1, y2,y;</span><br><span class="line">	y1 = funY(x1);</span><br><span class="line">	y2 = funY(x2);</span><br><span class="line">	<span class="keyword">while</span> (y1*y2 &lt; <span class="number">0</span> &amp;&amp; <span class="built_in">fabs</span>(x2 - x1) &gt;= <span class="number">1e-6</span>)	&#123;</span><br><span class="line">		x = (x1 + x2) / <span class="number">2</span>;</span><br><span class="line">		y = funY(x);</span><br><span class="line">		<span class="keyword">if</span> (y*y1 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			x2 = x;</span><br><span class="line">			y2 = y;</span><br><span class="line">		&#125;	</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (y*y2 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			x1 = x;</span><br><span class="line">			y1 = y;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (y == <span class="number">0</span>) </span><br><span class="line">			<span class="keyword">break</span>;	</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%lf\n"</span>, x);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span>	<span class="title">funY</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">double</span> y;</span><br><span class="line">	y = <span class="number">2</span> * x*x*x - <span class="number">4</span> * x*x + <span class="number">3</span> * x - <span class="number">6</span>;</span><br><span class="line">	<span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>牛顿迭代法的C语言实现</title>
    <url>/2018/08/25/%E7%89%9B%E9%A1%BF%E8%BF%AD%E4%BB%A3%E6%B3%95%E7%9A%84C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>牛顿迭代法是求方程根的一种解法。</p>
<p>一、求一个数a的平方根，可以用迭代法无限逼近。<br>迭代法公式如下</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">X2 = (x1+a/x1)/2</span><br></pre></td></tr></table></figure>

<p>S1，要先预估一个值x1，通常取x1=a/2;<br>S2，带入迭代公式，得到x2；<br>S3，计算x1 和 x2 的差的绝对值是否符合精确度；若符合则x2便是结果，若不符合进入S4；<br>S4，x1 = x2，然后重复S2、S3，直到符合精确度。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">float</span> a;</span><br><span class="line">	<span class="keyword">float</span> x1, x2;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"请输入待求平方根的数："</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%f"</span>,&amp;a);</span><br><span class="line">	x1 = a / <span class="number">2</span>;</span><br><span class="line">	x2 = (x1 + a / x1) / <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">fabs</span>(x1 - x2) &gt;= <span class="number">1e-5</span>) &#123;</span><br><span class="line">		x1 = x2;</span><br><span class="line">		x2 = (x1 + a / x1) / <span class="number">2</span>;</span><br><span class="line">	&#125;   </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%f"</span>,x2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二、求一元多次方程的根<br>迭代公式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">x2 = x1 - f(x1)/df(x1);</span><br></pre></td></tr></table></figure>

<p>算法的基本设计思想与求平方根相同。不再赘述</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//————————————————————</span></span><br><span class="line"><span class="comment">//牛顿迭代法求方程的根</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">funY</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">funY1</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">double</span> x, x1, x2;</span><br><span class="line"></span><br><span class="line">	x1 = <span class="number">1.5</span>;<span class="comment">//求1.5附近的根</span></span><br><span class="line">	x2 = x1 - funY(x1) / funY1(x1);</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">fabs</span>(x2 - x1) &gt; <span class="number">1e-6</span>) &#123;</span><br><span class="line">		x1 = x2;</span><br><span class="line">		x2 = x2 = x1 - funY(x1) / funY1(x1);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lf"</span>,x2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//————————————————————</span></span><br><span class="line"><span class="comment">//	y的函数</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">funY</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">double</span> y;</span><br><span class="line">	y = <span class="number">2</span> * x*x*x - <span class="number">4</span> * x*x + <span class="number">3</span> * x - <span class="number">6</span>;</span><br><span class="line">	<span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//y的一阶导数</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">funY1</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">double</span> y1;</span><br><span class="line">	y1 = <span class="number">6</span> * x*x - <span class="number">8</span> * x + <span class="number">3</span>;</span><br><span class="line">	<span class="keyword">return</span> y1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>最大公约数和最小公倍数的解决方案</title>
    <url>/2018/08/25/%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%E5%92%8C%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<p>﻿最大公因数，也称最大公约数、最大公因子，指两个或多个整数共有约数中最大的一个。例如24、60，他们的最大公约数就是12.<br>两个或多个整数公有的倍数叫做它们的公倍数，其中除0以外最小的一个公倍数就叫做这几个整数的最小公倍数。例如24、60，他们的最小公倍数是120。</p>
<a id="more"></a>

<p>最大公约数的解决方案可以使用欧几里得算法。<br>例如，求（319，377）：<br>∵ 319÷377=0（余319）<br>∴（319，377）=（377，319）；<br>∵ 377÷319=1（余58）<br>∴（377，319）=（319，58）；<br>∵ 319÷58=5（余29）<br>∴ （319，58）=（58，29）；<br>∵ 58÷29=2（余0）<br>∴ （58，29）= 29；<br>∴ （319，377）=29。<br>最小公倍数可以用两个数相乘然后除以最大公约数。（a*b/最大公约数）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//——————————————————————————————</span></span><br><span class="line"><span class="comment">//判断两个数的最大公约数和最小公倍数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcomfac</span><span class="params">(<span class="keyword">int</span> m,<span class="keyword">int</span> n)</span></span>;<span class="comment">//最大公约数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lcommult</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> x)</span></span>;<span class="comment">//最小公倍数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> m, n, gfac, lcm;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"请输入两个数："</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;m,&amp;n);</span><br><span class="line">	gfac = gcomfac(m,n);</span><br><span class="line">	lcm = lcommult(m,n,gfac);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"最大公约数：%d\n最小公倍数：%d\n"</span>,gfac,lcm);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcomfac</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> result;</span><br><span class="line">	<span class="keyword">if</span> (m / n == <span class="number">0</span>)</span><br><span class="line">		result = gcomfac(n, m);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (m%n == <span class="number">0</span>)</span><br><span class="line">		result = n;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (m%n != <span class="number">0</span>)</span><br><span class="line">		result = gcomfac(n, m%n);</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lcommult</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> lcm;</span><br><span class="line">	lcm = (m*n) / x;</span><br><span class="line">	<span class="keyword">return</span> lcm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>最大公约数</tag>
        <tag>最小公倍数</tag>
      </tags>
  </entry>
  <entry>
    <title>python中的三目运算</title>
    <url>/2018/05/31/python%E4%B8%AD%E7%9A%84%E4%B8%89%E7%9B%AE%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<p>﻿python中的三目运算和C语言有点不同。</p>
<a id="more"></a>

<p>C语言里</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">4</span>;</span><br><span class="line">c = (a &lt; b) ? a : b<span class="comment">//取最小值</span></span><br></pre></td></tr></table></figure>

<p>python中</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a, b = <span class="number">3</span>, <span class="number">4</span></span><br><span class="line"><span class="comment">#第一种方法：true if condition else false</span></span><br><span class="line">c = a <span class="keyword">if</span> a &lt; b <span class="keyword">else</span> b</span><br><span class="line"></span><br><span class="line"><span class="comment">#第二种方法：condition and ture or false</span></span><br><span class="line">d = a &lt; b <span class="keyword">and</span> a <span class="keyword">or</span> b</span><br></pre></td></tr></table></figure>

<p>上面的第二种方法算是对逻辑运算符的熟练运用吧<br>在a、b都为真的情况下<br>当condition为真的时候，变成Ture and a or b ,也就是a，因为or语句当左边操作数为真时，就不再判断右边操作数。<br>当condition为假的时候，变成False and a or b ，也就是b,因为and语句当左边操作数为假时，不再判断右边操作数，直接为False。</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>三目运算</tag>
      </tags>
  </entry>
  <entry>
    <title>verilog中的generate语句</title>
    <url>/2018/04/01/verilog%E4%B8%AD%E7%9A%84generate%E8%AF%AD%E5%8F%A5/</url>
    <content><![CDATA[<p>﻿generate语句可以动态的生成verilog代码，当对矢量中的多个位进行重复操作时，或者当进行多个模块的实例引用的重复操作时，或者根据参数的定义来确定程序中是否应该包含某段Verilog代码的时候，使用生成语句能大大简化程序的编写过程。</p>
<a id="more"></a>

<p>​       生成语句生成的实例范围，关键字generate-endgenerate用来指定该范围。生成实例可以是以下的一个或多个类型：<br>​       （1）模块；（2）用户定义原语；（3）门级语句；（4）连续赋值语句；（5）initial和always块。<br>​       generate语句有generate-for，generate-if，generate-case三种语句。<br>1.generate-for语句<br>（1) 必须有genvar关键字定义for语句的变量。<br>（2）for语句的内容必须加begin和end（即使就一句）。<br>（3）for语句必须有个名字。<br>例1：assign语句实现</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> test(bin,gray);</span><br><span class="line">       <span class="keyword">parameter</span> SIZE=<span class="number">8</span>;</span><br><span class="line">       <span class="keyword">output</span> [SIZE-<span class="number">1</span>:<span class="number">0</span>] bin;</span><br><span class="line">       <span class="keyword">input</span> [SIZE-<span class="number">1</span>:<span class="number">0</span>] gray;</span><br><span class="line">       <span class="keyword">genvar</span> i; <span class="comment">//genvar i;也可以定义到generate语句里面</span></span><br><span class="line">       <span class="keyword">generate</span></span><br><span class="line">              <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;SIZE;i=i+<span class="number">1</span>)</span><br><span class="line">              <span class="keyword">begin</span>:<span class="keyword">bit</span></span><br><span class="line">                     <span class="keyword">assign</span> bin[i]=^gray[SIZE-<span class="number">1</span>:i];</span><br><span class="line">              <span class="keyword">end</span></span><br><span class="line">       <span class="keyword">endgenerate</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<p>等同于</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> bin[<span class="number">0</span>]=^gray[SIZE-<span class="number">1</span>:<span class="number">0</span>];</span><br><span class="line"><span class="keyword">assign</span> bin[<span class="number">1</span>]=^gray[SIZE-<span class="number">1</span>:<span class="number">1</span>];</span><br><span class="line"><span class="keyword">assign</span> bin[<span class="number">2</span>]=^gray[SIZE-<span class="number">1</span>:<span class="number">2</span>];</span><br><span class="line"><span class="keyword">assign</span> bin[<span class="number">3</span>]=^gray[SIZE-<span class="number">1</span>:<span class="number">3</span>];</span><br><span class="line"><span class="keyword">assign</span> bin[<span class="number">4</span>]=^gray[SIZE-<span class="number">1</span>:<span class="number">4</span>];</span><br><span class="line"><span class="keyword">assign</span> bin[<span class="number">5</span>]=^gray[SIZE-<span class="number">1</span>:<span class="number">5</span>];</span><br><span class="line"><span class="keyword">assign</span> bin[<span class="number">6</span>]=^gray[SIZE-<span class="number">1</span>:<span class="number">6</span>];</span><br><span class="line"><span class="keyword">assign</span> bin[<span class="number">7</span>]=^gray[SIZE-<span class="number">1</span>:<span class="number">7</span>];</span><br></pre></td></tr></table></figure>

<p>例2</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">generate</span></span><br><span class="line">       <span class="keyword">genvar</span> i;</span><br><span class="line">       <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;SIZE;i=i+<span class="number">1</span>)</span><br><span class="line">       <span class="keyword">begin</span>:shifter</span><br><span class="line">              <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk)</span><br><span class="line">                     shifter[i]&lt;=(i==<span class="number">0</span>)?din:shifter[i-<span class="number">1</span>];</span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endgenerate</span></span><br></pre></td></tr></table></figure>

<p>等同于</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">always</span>@(<span class="keyword">posedge</span> clk)</span><br><span class="line">       shifter[<span class="number">0</span>]&lt;=din;</span><br><span class="line"><span class="keyword">always</span>@(<span class="keyword">posedge</span> clk)</span><br><span class="line">       shifter[<span class="number">1</span>]&lt;=shifter[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">always</span>@(<span class="keyword">posedge</span> clk)</span><br><span class="line">       shifter[<span class="number">2</span>]&lt;=shifter[<span class="number">1</span>];</span><br><span class="line">.................</span><br><span class="line">       ......................</span><br><span class="line"><span class="keyword">always</span>@(<span class="keyword">posedge</span> clk)</span><br><span class="line">       shifter[SIZE]&lt;=shifter[SIZE-<span class="number">1</span>];</span><br></pre></td></tr></table></figure>

<p>generate-if，generate-case和generate-for语句类似。</p>
<p>转载自：<a href="http://lihaichuan.blog.51cto.com/498079/1118866" target="_blank" rel="noopener">http://lihaichuan.blog.51cto.com/498079/1118866</a></p>
]]></content>
      <categories>
        <category>FPGA</category>
      </categories>
      <tags>
        <tag>FPGA</tag>
        <tag>verilog</tag>
      </tags>
  </entry>
  <entry>
    <title>利用esp8266wifi信号强度测距</title>
    <url>/2018/02/24/%E5%88%A9%E7%94%A8esp8266wifi%E4%BF%A1%E5%8F%B7%E5%BC%BA%E5%BA%A6%E6%B5%8B%E8%B7%9D/</url>
    <content><![CDATA[<p>﻿[外链图片转存中…(img-ThlOzYaT-1571226330026)]<br>向esp8266发送指令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AT + CWLAP</span><br></pre></td></tr></table></figure>

<p>可以得到当前可加入wifi信号的信息，其中包括的rssi，就是我们所需要的。<br>提取出rssi，然后带入公式<br>    <a id="more"></a><br>    d = 10^((abs(rssi) - A) / (10 * n))<br>即可得到接收机和发射机之间的大概距离。<br>效果图<br>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-ciPf4oMU-1571226330029)(<a href="http://img.blog.csdn.net/20180224154307689?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQ2hlcmlzaF94/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)]" target="_blank" rel="noopener">http://img.blog.csdn.net/20180224154307689?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQ2hlcmlzaF94/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)]</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"reg52.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"string.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"math.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> uint;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> uchar;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NAME 9   <span class="comment">//xutianyun</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	N 40				<span class="comment">//N = 10 * n ,其中n为环境衰减因子，3.25-4.5</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> A 51			<span class="comment">//接收机和发射机间隔1m时的信号强度</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> rssidata = <span class="number">0</span>;</span><br><span class="line">uchar recbuffer[<span class="number">32</span>];</span><br><span class="line">uint cnt = <span class="number">0</span>;</span><br><span class="line">uint getit = <span class="number">0</span>;</span><br><span class="line">uint datalen = <span class="number">0</span>;</span><br><span class="line">uchar wifi_rssi[<span class="number">5</span>];</span><br><span class="line">uchar wifi_ssid[<span class="number">11</span>] = &#123;<span class="string">'"'</span>,<span class="string">'x'</span>,<span class="string">'u'</span>,<span class="string">'t'</span>,<span class="string">'i'</span>,<span class="string">'a'</span>,<span class="string">'n'</span>,<span class="string">'y'</span>,<span class="string">'u'</span>,<span class="string">'n'</span>,<span class="string">'"'</span>&#125;;</span><br><span class="line"><span class="keyword">float</span> d;</span><br><span class="line">uint dis;</span><br><span class="line">uchar temp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UsartInit</span><span class="params">(<span class="keyword">void</span>)</span>	</span>&#123;</span><br><span class="line">	SCON = <span class="number">0x50</span>;</span><br><span class="line">	TMOD = <span class="number">0x20</span>;</span><br><span class="line">	PCON = <span class="number">0x80</span>;</span><br><span class="line">	TH1  = <span class="number">0xF3</span>;</span><br><span class="line">	TL1  = <span class="number">0xF3</span>;</span><br><span class="line">	ES   = <span class="number">1</span>;</span><br><span class="line">	EA   = <span class="number">1</span>;</span><br><span class="line">	TR1  = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SendUart</span><span class="params">(uchar value)</span>	</span>&#123;</span><br><span class="line">	ES = <span class="number">0</span>;</span><br><span class="line">	SBUF = value;</span><br><span class="line">	<span class="keyword">while</span>(!TI);</span><br><span class="line">	TI = <span class="number">0</span>;</span><br><span class="line">	ES = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SendString</span><span class="params">(uchar *str)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(*str != <span class="string">'\0'</span>) &#123;</span><br><span class="line">		SendUart(*str);</span><br><span class="line">		str++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">rssiTodis</span><span class="params">(<span class="keyword">int</span> RSSI)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">float</span> iu, distance;</span><br><span class="line">	iu = (<span class="keyword">float</span>)(RSSI - A) / (<span class="keyword">float</span>)N;	</span><br><span class="line">	distance = <span class="built_in">pow</span>(<span class="number">10</span>, iu);</span><br><span class="line">	<span class="keyword">return</span> distance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	UsartInit();</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Usart</span><span class="params">()</span> interrupt 4 </span>&#123;</span><br><span class="line">	uchar rec;</span><br><span class="line">	<span class="keyword">if</span>(RI != <span class="number">0</span>)	&#123;</span><br><span class="line">		rec = SBUF;</span><br><span class="line">		RI = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(rec == <span class="string">'"'</span>)	&#123;</span><br><span class="line">		cnt = <span class="number">1</span>;</span><br><span class="line">		getit = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(rec == <span class="string">','</span>) &#123;</span><br><span class="line">		cnt = <span class="number">0</span>;</span><br><span class="line">		datalen = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(getit == <span class="number">1</span>)	&#123;</span><br><span class="line">			SendUart(wifi_rssi[<span class="number">1</span>]);</span><br><span class="line">			SendUart(wifi_rssi[<span class="number">2</span>]);</span><br><span class="line">			SendString(<span class="string">"\r\n"</span>);</span><br><span class="line">			rssidata = (wifi_rssi[<span class="number">1</span>] - <span class="string">'0'</span>)* <span class="number">10</span> + (wifi_rssi[<span class="number">2</span>] - <span class="string">'0'</span>);</span><br><span class="line"></span><br><span class="line">			d = rssiTodis(rssidata);</span><br><span class="line">			dis = d*<span class="number">10000</span>;	</span><br><span class="line">			temp = dis/<span class="number">10000</span> + <span class="string">'0'</span>;</span><br><span class="line">			SendUart(temp);</span><br><span class="line">			temp = dis/<span class="number">1000</span>%<span class="number">10</span> + <span class="string">'0'</span>;</span><br><span class="line">			SendUart(temp);</span><br><span class="line">			temp = dis/<span class="number">100</span>%<span class="number">10</span> + <span class="string">'0'</span>;</span><br><span class="line">			SendUart(temp);</span><br><span class="line">			temp = dis/<span class="number">10</span>%<span class="number">10</span> + <span class="string">'0'</span>;</span><br><span class="line">			SendUart(temp);</span><br><span class="line">			temp = dis%<span class="number">10</span> + <span class="string">'0'</span>;</span><br><span class="line">			SendUart(temp);</span><br><span class="line">			SendString(<span class="string">"\r\nok\r\n"</span>);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(rec == <span class="string">'-'</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">strncmp</span>(recbuffer, wifi_ssid, NAME + <span class="number">2</span>) == <span class="number">0</span>)	getit = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(cnt == <span class="number">1</span>)	&#123;</span><br><span class="line">		recbuffer[datalen++] = rec;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(getit == <span class="number">1</span>) &#123;</span><br><span class="line">		wifi_rssi[datalen++] = rec;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：以上代码烧录单片机后，需要借助串口调试助手，</p>
]]></content>
      <categories>
        <category>IoT</category>
      </categories>
      <tags>
        <tag>wifi测距</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言比较字符串</title>
    <url>/2018/02/22/C%E8%AF%AD%E8%A8%80%E6%AF%94%E8%BE%83%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<p>库函数strcmp是C语言中比较字符串的函数。<br>在头文件string.h中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">strcmp</span>（<span class="keyword">char</span> *a, <span class="keyword">char</span> *b）;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strncmp</span><span class="params">(<span class="keyword">char</span> *a, <span class="keyword">char</span> *b, N)</span></span>;  <span class="comment">//比较前N位</span></span><br></pre></td></tr></table></figure>

<p>这个函数按照ASCII码表对两个字符串的每个字符进行比对。如果二者完全相同返回0，<br>如果字符串a中的字符ASCII码先出现较大者，则返回1，反之返回-1；</p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>rssi信号强度与距离的转换公式</title>
    <url>/2018/02/22/rssi%E4%BF%A1%E5%8F%B7%E5%BC%BA%E5%BA%A6%E4%B8%8E%E8%B7%9D%E7%A6%BB%E7%9A%84%E8%BD%AC%E6%8D%A2%E5%85%AC%E5%BC%8F/</url>
    <content><![CDATA[<p>﻿    d = 10^((abs(rssi) - A) / (10 * n))</p>
<p>其中：<br>    d - 计算所得距离(单位：m)<br>    rssi - 接收信号强度<br>    A - 发射端和接收端相隔1米时的信号强度<br>    n - 环境衰减因子</p>
]]></content>
      <categories>
        <category>IoT</category>
      </categories>
      <tags>
        <tag>rssi</tag>
      </tags>
  </entry>
  <entry>
    <title>FPGA--我们到底要怎么搭复位电路</title>
    <url>/2018/02/06/FPGA%E2%80%94%E2%80%94%E6%88%91%E4%BB%AC%E5%88%B0%E5%BA%95%E8%A6%81%E6%80%8E%E4%B9%88%E6%90%AD%E5%A4%8D%E4%BD%8D%E7%94%B5%E8%B7%AF/</url>
    <content><![CDATA[<p>第一次看特权同学写的亚稳态的问题时，说实话，真的没有看懂。以前就是一直用的异步复位，同时也没有遇到过这样的问题。沉下心来，又仔细的看了一遍，发现了问题所在，特别是当你的工程特别大的时候，可能会非常严重。</p>
<a id="more"></a>

<p>异步复位：复位信号和系统时钟信号的触发可以在任何时刻。二者相互独立。<br>同步复位：在系统时钟信号的触发下，复位信号有效。<br>用verilog表示会更明显：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 异步复位</span></span><br><span class="line"><span class="keyword">reg</span>	a;</span><br><span class="line"><span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)	<span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">if</span>(!rst_n)</span><br><span class="line">		a &lt;= <span class="number">'d0</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		a &lt;= ~a;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">//同步复位</span></span><br><span class="line"><span class="keyword">reg</span>	b;</span><br><span class="line"><span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk)	<span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">if</span>(!rst_n)</span><br><span class="line">		b &lt;= <span class="number">'d0</span>;</span><br><span class="line">	<span class="keyword">else</span>	</span><br><span class="line">		b &lt;= ~b;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>如果复位信号的撤销发生在系统时钟的建立和保持时间这段时间内，系统此时检测到复位信号的状态就处在一个亚稳态，无法确定是0还是1。就有可能造成系统工作不同步的问题。</p>
<pre><code>特权同学在书中讲到同步复位发生的概率相对异步复位比较低，这一点，我在网上查了，也是很多人都这样认为，这个我还没有理解。</code></pre><p>异步复位会影响寄存器的recovery时间，引起设计的稳定性问题，尤其对于状态机的无意识复位，将导致进入不确定的状态。<br>同步复位最主要的问题是对于不带同步复位专用端口的器件会增加额外的逻辑资源。<br>在书中，特权同学提到了一种取长补短的方法：异步复位、同步释放。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">//异步复位、同步释放</span></span><br><span class="line"><span class="keyword">reg</span>	rst_nr1;</span><br><span class="line"><span class="keyword">reg</span>	rst_nr2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)	<span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">if</span>(!rst_n)</span><br><span class="line">		rst_nr1 &lt;= <span class="number">'d0</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		rst_nr1 &lt;= <span class="number">1'b1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)	<span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">if</span>(!rst_n)</span><br><span class="line">		rst_nr2 &lt;= <span class="number">'d0</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		rst_nr2 &lt;= rst_nr1;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>简单分析一下这个电路，当异步复位发生，rst_nr2直接拉低为0，并且由于rst_nr2是在时钟沿的作用下对rst_nr1进行采样，所以当rst_nr2的置1是和时钟沿同步的。也就是异步复位、同步释放。然后用信号rst_nr2作为系统复位时钟，就不发生亚稳态现象。</p>
<p>但是在我的理解看来，这两个触发器仍然是采用rst_n作为复位信号，所以必然会有亚稳态的现象发生，即rst_nr2还是 有可能在不应该复位的时间点复位，但是由rst_nr2作为系统复位信号的后级电路<strong>不会发生系统工作不同步</strong>的现象。</p>
]]></content>
      <categories>
        <category>FPGA</category>
      </categories>
      <tags>
        <tag>FPGA</tag>
        <tag>复位电路</tag>
      </tags>
  </entry>
  <entry>
    <title>FPGA--时钟分频和时钟使能的思考</title>
    <url>/2018/02/02/FPGA%E2%80%94%E2%80%94%E6%97%B6%E9%92%9F%E5%88%86%E9%A2%91%E5%92%8C%E6%97%B6%E9%92%9F%E4%BD%BF%E8%83%BD%E7%9A%84%E6%80%9D%E8%80%83/</url>
    <content><![CDATA[<p>之前遇到时钟需要分频的时候，直接用计数器和源时钟产生，然后把这个分频时钟的上升沿作为敏感事件去写了，今天看了特权同学的书，也自己在网上看了看，这样做是不好的，降低了系统的可靠性，在实际工程中我们应该避免这中写法。采用时钟使能的方式，这样整个工程都是单一时钟电路，也利于分析维护。</p>
<a id="more"></a>

<p>建议的写法如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> pro(</span><br><span class="line">	<span class="keyword">input</span>		clk,</span><br><span class="line">	<span class="keyword">input</span>		rst_n</span><br><span class="line">);</span><br><span class="line">	<span class="keyword">reg</span>[<span class="number">2</span>:<span class="number">0</span>]	count;</span><br><span class="line">	<span class="keyword">wire</span> 		clk_en;</span><br><span class="line">	<span class="keyword">reg</span>			a;</span><br><span class="line">	<span class="keyword">reg</span>			b;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)	<span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">if</span>(!rst_n)</span><br><span class="line">			count &lt;= <span class="number">'d0</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(count &gt; <span class="number">3'd5</span>)</span><br><span class="line">			count &lt;= <span class="number">'d0</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			count &lt;= count + <span class="number">1'b1</span>;</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">assign</span>	clk_en = (count == <span class="number">3'd5</span>);<span class="comment">//只拉高一个时钟周期</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)	<span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">if</span>(!rst_n)	<span class="keyword">begin</span></span><br><span class="line">			a &lt;= <span class="number">1'b0</span>;</span><br><span class="line">			b &lt;= <span class="number">1'b0</span>;</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(clk_en)	<span class="keyword">begin</span>		<span class="comment">//分频时钟作使能信号使用</span></span><br><span class="line">			a &lt;= ~b;</span><br><span class="line">			b &lt;= ~a;</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>FPGA</category>
      </categories>
      <tags>
        <tag>FPGA</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP8266——OneNet的GET指令及C语言代码</title>
    <url>/2018/01/26/ESP8266%E2%80%94%E2%80%94OneNet%E7%9A%84GET%E6%8C%87%E4%BB%A4%E5%8F%8AC%E8%AF%AD%E8%A8%80%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<p>﻿GET指令的HTTP数据报文</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">GET /devices/你的设备号/datastreams/你的数据流名称 HTTP/<span class="number">1.1</span>\r\n</span><br><span class="line">Host: api.heclouds.com\r\n</span><br><span class="line">api-key: 你的apikey\r\n\r\n</span><br></pre></td></tr></table></figure>

<p>我更改了ESP8266的波特率，改成了4800的；</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AT+UART=4800,8,1,0,0\r\n //更改esp8266的波特率</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"reg52.h"</span></span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> uint;</span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> uchar;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DATASIZE 110</span></span><br><span class="line"></span><br><span class="line">sbit LED = P2^<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">uchar datalen = <span class="number">0</span>;</span><br><span class="line">uchar value;</span><br><span class="line">uchar cnt = <span class="number">0</span>;</span><br><span class="line">uchar recbuffer[DATASIZE];</span><br><span class="line"></span><br><span class="line">			</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delay600ms</span><span class="params">()</span>		<span class="comment">//@12.000MHz</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> i, j, k;</span><br><span class="line"></span><br><span class="line">	i = <span class="number">5</span>;</span><br><span class="line">	j = <span class="number">144</span>;</span><br><span class="line">	k = <span class="number">71</span>;</span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">do</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">while</span> (--k);</span><br><span class="line">		&#125; <span class="keyword">while</span> (--j);</span><br><span class="line">	&#125; <span class="keyword">while</span> (--i);</span><br><span class="line">&#125;</span><br><span class="line">																 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UsartInit</span><span class="params">(<span class="keyword">void</span>)</span>	</span>&#123;</span><br><span class="line">	SCON = <span class="number">0x50</span>;</span><br><span class="line">	TMOD = <span class="number">0x20</span>;</span><br><span class="line">	PCON = <span class="number">0x80</span>;</span><br><span class="line">	TH1  = <span class="number">0xF3</span>;</span><br><span class="line">	TL1  = <span class="number">0xF3</span>;</span><br><span class="line">	ES   = <span class="number">1</span>;</span><br><span class="line">	EA   = <span class="number">1</span>;</span><br><span class="line">	TR1  = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SendUart</span><span class="params">(uchar value)</span>	</span>&#123;</span><br><span class="line">	ES = <span class="number">0</span>;</span><br><span class="line">	SBUF = value;</span><br><span class="line">	<span class="keyword">while</span>(!TI);</span><br><span class="line">	TI = <span class="number">0</span>;</span><br><span class="line">	ES = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SendString</span><span class="params">(uchar *str)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(*str != <span class="string">'\0'</span>) &#123;</span><br><span class="line">		SendUart(*str);</span><br><span class="line">		str++;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wificonnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	SendString(<span class="string">"AT\r\n"</span>);</span><br><span class="line">	<span class="comment">//SendString("AT+CWMODE=1\r\n");</span></span><br><span class="line">	<span class="comment">//SendString("AT+RST");</span></span><br><span class="line">	SendString(<span class="string">"AT+CWJAP=\"****\",\"******\"\r\n"</span>);</span><br><span class="line">	Delay600ms();</span><br><span class="line">	Delay600ms();</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TCPconnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	SendString(<span class="string">"AT+CIPMUX=0\r\n"</span>);</span><br><span class="line">	Delay600ms();</span><br><span class="line">	Delay600ms();</span><br><span class="line">	SendString(<span class="string">"AT+CIPSTART=\"TCP\",\"183.230.40.33\",80\r\n"</span>);</span><br><span class="line">	Delay600ms();</span><br><span class="line">	Delay600ms();</span><br><span class="line">	SendString(<span class="string">"AT+CIPMODE=1\r\n"</span>);</span><br><span class="line">	Delay600ms();</span><br><span class="line">	Delay600ms();</span><br><span class="line">	SendString(<span class="string">"AT+CIPSEND\r\n"</span>);</span><br><span class="line">	Delay600ms();</span><br><span class="line">	Delay600ms();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">check</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	SendString(<span class="string">"GET /devices/******/datastreams/*** HTTP/1.1\r\n"</span>);</span><br><span class="line">	SendString(<span class="string">"Host: api.heclouds.com\r\n"</span>);</span><br><span class="line">	SendString(<span class="string">"api-key: ********************\r\n\r\n"</span>);</span><br><span class="line">	Delay600ms();			 </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> 	UsartInit();</span><br><span class="line">	wificonnection();</span><br><span class="line">	TCPconnection();</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		check();</span><br><span class="line">		Delay600ms();</span><br><span class="line">		<span class="keyword">if</span>(value == <span class="string">'1'</span>) LED = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(value == <span class="string">'0'</span>) LED = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Usart</span><span class="params">()</span> interrupt 4 </span>&#123;</span><br><span class="line">	uchar rec;</span><br><span class="line">	<span class="keyword">if</span>(RI != <span class="number">0</span>) &#123;</span><br><span class="line">		rec = SBUF;</span><br><span class="line">		RI = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(rec == <span class="string">'&#123;'</span>) cnt = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(cnt == <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span>(rec != <span class="string">'&#125;'</span>) &#123;</span><br><span class="line">			recbuffer[datalen++] = rec;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			cnt = <span class="number">0</span>;</span><br><span class="line">			value = recbuffer[datalen - <span class="number">1</span>];</span><br><span class="line">			<span class="comment">//SendString(recbuffer);</span></span><br><span class="line">			<span class="comment">//SendString("\r\n");</span></span><br><span class="line">			<span class="comment">//SendUart(value);</span></span><br><span class="line">			<span class="comment">//SendString("\r\nok\r\n");</span></span><br><span class="line">			datalen = <span class="number">0</span>;</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>IoT</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>物联网</tag>
        <tag>ESP8266</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP8266--TCP连接</title>
    <url>/2018/01/26/ESP8266%E2%80%94%E2%80%94TCP%E8%BF%9E%E6%8E%A5/</url>
    <content><![CDATA[<p>﻿</p>
<p>这两天因为一个项目遗留问题，又玩了玩C51。做的是用ESP8266连接OneNet进行联网控制。<br>在淘宝购买的wifi模块，店家给的资料也实在是多，工具也很齐全。<br>首先wifi模块和C51是利用串口通信的，这就需要了解串口通信的知识。差不多一年前，我自己学过C51的一些基础知识，但是毕竟一年没有动了，有些生疏，也幸好的是，刚学完单片机这门课程，对串口通信的认识更加的深入了，所以回过头来看这些资料，感觉很轻松。</p>
<a id="more"></a>

<p>TXD（Transmit Data） 发送数据<br>RXD（Receive Data） 接受数据<br>值得注意的是，TXD、RXD在串口通信的时候需要外加参考电平。<br>下面是一些关于ESP8266的知识点。<br>ESP8266集成了AT指令，让我们开发起来更加的方便了许多。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AT\r\n       //响应ok</span><br></pre></td></tr></table></figure>

<p>Station模式。这个模式下ESP8266可以加入其他路由器的网络<br>AP模式，这个模式下ESP8266就相当于一个路由器，其他设备可以加入到这个模式中<br>Station+AP模式<br>在这里我用的Station模式。注意（更改模式后，需要发送指令<code>AT+RST\r\n</code>重启模块使其生效）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AT+CWMODE=1\r\n    //选择Station模式</span><br><span class="line">AT+CWMODE=2\r\n    //选择AP模式</span><br><span class="line">AT+CWMODE=3\r\n    //选择Station+AP模式</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AT+CWJAP\r\n       //查看当前可用wifi</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AT+CWJAP=&quot;ssid&quot;,&quot;pwd&quot;\r\n    //ssid是WiFi名称，pwd是WiFi密码，此条指令可以帮助esp8266连接wifi</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AT+CIPMUX=0\r\n			选择单路连接模式</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AT+CIPSTART=&quot;TCP&quot;,&quot;host&quot;,port\r\n	//host是你将要连接服务器的域名，port是端口号，与服务器建立TCP连接</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AT+CIPMODE=1\r\n 	//选择透传模式</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AT+CIPSEND\r\n		//响应&gt;,便可以向服务器发送HTTP数据报</span><br></pre></td></tr></table></figure>

<p>下面是几条，调试的过程会用到的指令。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AT+CWQAP\r\n   //退出与路由器的连接</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+++     			//返回指令模式，此条指令用在已经AT+CIPSEND后面，可以辅助下面的指令断开与服务器的连接，注意没有换行</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AT+CIPCLOSE\r\n   //断开与服务器的连接</span><br></pre></td></tr></table></figure>

<p>陆续发送以上几条指令，不报错，就可以和服务器建立连接了。</p>
]]></content>
      <categories>
        <category>IoT</category>
      </categories>
      <tags>
        <tag>物联网</tag>
        <tag>ESP8266</tag>
      </tags>
  </entry>
  <entry>
    <title>FPGA--速度和面积的基本认识</title>
    <url>/2018/01/22/FPGA%E2%80%94%E2%80%94%E9%80%9F%E5%BA%A6%E5%92%8C%E9%9D%A2%E7%A7%AF%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%86/</url>
    <content><![CDATA[<p>速度是指整个工程稳定运行所能达到的最高时钟频率。<br>面积是值整个工程所需要的触发器、查找表或等效门的数量来衡量的。</p>
<pre><code>速度和面积是一对矛盾体，在追求速度的同时，必然会增大面积。在工程中，我们能做的只有在速度和面积中取最优的方案。之前在学习中，一直没有关注面积的问题，其实在我们资源有限的情况下，应该要注重面积的最小化。</code></pre>]]></content>
      <categories>
        <category>FPGA</category>
      </categories>
      <tags>
        <tag>FPGA</tag>
      </tags>
  </entry>
  <entry>
    <title>FPGA--关于状态机</title>
    <url>/2018/01/19/FPGA%E2%80%94%E2%80%94%E5%85%B3%E4%BA%8E%E7%8A%B6%E6%80%81%E6%9C%BA/</url>
    <content><![CDATA[<p>​    状态机，是我大二在实验室学习时，学长给我们安排的任务之一。那个时候，我还没有学过《数电》，一直搞不明白状态机的意思，做了一周，都没有结果。<br>任务是检测序列，检测到1011时输出一个高电平。</p>
<a id="more"></a>

<p>我们都知道verilog语言依靠不同的always语句块实现了硬件电路的并行执行，但是在工程中，我们不仅要处理并行执行电路，偶尔也会遇到需要串行执行的电路要求。刚开始学习FPGA的话，可能会想到我们可以利用很多很多的使能信号实现，但是这样维护的成本大大增加。状态机就可以完美的实现这一功能。先简单介绍一下状态机的基本概念。</p>
<p>状态机的基本要素是<strong>输入、输出和状态</strong>。输入是引起状态变化的条件，输出是状态变化引起的变化。状态就是字面理解的意思了，状态机，通俗的说就是因为输入导致状态在不断的变化的硬件电路。</p>
<p>Moore型状态机的输出仅与状态有关，与输入无关。<br>Mealy型状态机的输入不仅与状态有关，还与输入条件有关。<br>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Oq0qQTjK-1571226216451)(<a href="http://img.blog.csdn.net/20180119154529552?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQ2hlcmlzaF94/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)]" target="_blank" rel="noopener">http://img.blog.csdn.net/20180119154529552?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQ2hlcmlzaF94/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)]</a><br>一段式写法，输入、输出和状态在一个always语句块中，后期不容易维护。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> pro(</span><br><span class="line">	<span class="keyword">input</span>	clk,</span><br><span class="line">	<span class="keyword">input</span>	rst_n,</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">input</span>	data,</span><br><span class="line">	<span class="keyword">output</span>	cntout</span><br><span class="line">);</span><br><span class="line">	<span class="keyword">parameter</span>	INITIALSTATE = <span class="number">5'b00_001</span>,</span><br><span class="line">						STATE_0 = <span class="number">5'b00_010</span>,</span><br><span class="line">						STATE_1 = <span class="number">5'b00_100</span>,</span><br><span class="line">						STATE_2 = <span class="number">5'b01_000</span>,</span><br><span class="line">						STATE_3 = <span class="number">5'b10_000</span>;</span><br><span class="line">					</span><br><span class="line"></span><br><span class="line">					</span><br><span class="line">	<span class="comment">//————————————————————————————————————————————</span></span><br><span class="line">	<span class="comment">//一段式写法, 既把输入、输出和状态写在一个always语句块					</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">reg</span>[<span class="number">4</span>:<span class="number">0</span>]	state_ce;		<span class="comment">//状态寄存器</span></span><br><span class="line">	<span class="keyword">reg</span>	cnt;</span><br><span class="line">	<span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)	<span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">if</span>(!rst_n)	<span class="keyword">begin</span></span><br><span class="line">			cnt &lt;= <span class="number">1'b0</span>;</span><br><span class="line">			state_ce &lt;= INITIALSTATE;</span><br><span class="line">			<span class="keyword">end</span></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">case</span>(state_ce)</span><br><span class="line">				INITIALSTATE:	<span class="keyword">begin</span></span><br><span class="line">											cnt &lt;= <span class="number">1'b0</span>;</span><br><span class="line">											<span class="keyword">if</span>(data == <span class="number">1'b1</span>)</span><br><span class="line">												state_ce &lt;= STATE_0;</span><br><span class="line">											<span class="keyword">else</span></span><br><span class="line">												state_ce &lt;= INITIALSTATE;</span><br><span class="line">											<span class="keyword">end</span></span><br><span class="line">				STATE_0:			<span class="keyword">if</span>(data == <span class="number">1'b0</span>)</span><br><span class="line">											state_ce &lt;= STATE_1;</span><br><span class="line">										<span class="keyword">else</span></span><br><span class="line">											state_ce &lt;= STATE_0;</span><br><span class="line">				STATE_1:			<span class="keyword">if</span>(data == <span class="number">1'b1</span>)</span><br><span class="line">											state_ce &lt;= STATE_2;</span><br><span class="line">										<span class="keyword">else</span></span><br><span class="line">											state_ce &lt;= INITIALSTATE;</span><br><span class="line">				STATE_2:			<span class="keyword">if</span>(data == <span class="number">1'b1</span>)</span><br><span class="line">											state_ce &lt;= STATE_3;</span><br><span class="line">										<span class="keyword">else</span></span><br><span class="line">											state_ce &lt;= STATE_1;</span><br><span class="line">				STATE_3:			<span class="keyword">begin</span></span><br><span class="line">											state_ce &lt;= INITIALSTATE;</span><br><span class="line">											cnt &lt;= <span class="number">1'b1</span>;</span><br><span class="line">											<span class="keyword">end</span></span><br><span class="line">			<span class="keyword">endcase</span></span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">assign</span>	cntout = cnt;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<p>[外链图片转存中…(img-CLvmuOJa-1571226216454)]</p>
<p>二段式写法，分成了组合逻辑和时序逻辑。时序逻辑里作状态的转移，组合逻辑里作输入条件判断和输出。但是组合逻辑输出容易出现毛刺问题。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> pro(</span><br><span class="line">	<span class="keyword">input</span>	clk,</span><br><span class="line">	<span class="keyword">input</span>	rst_n,</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">input</span>	data,</span><br><span class="line">	<span class="keyword">output</span>	cntout</span><br><span class="line">);</span><br><span class="line">	<span class="keyword">parameter</span>	INITIALSTATE = <span class="number">5'b00_001</span>,</span><br><span class="line">						STATE_0 = <span class="number">5'b00_010</span>,</span><br><span class="line">						STATE_1 = <span class="number">5'b00_100</span>,</span><br><span class="line">						STATE_2 = <span class="number">5'b01_000</span>,</span><br><span class="line">						STATE_3 = <span class="number">5'b10_000</span>;</span><br><span class="line">					</span><br><span class="line">	<span class="keyword">reg</span>[<span class="number">4</span>:<span class="number">0</span>]	state_ce;</span><br><span class="line">	<span class="keyword">reg</span>[<span class="number">4</span>:<span class="number">0</span>]	state_nt;</span><br><span class="line">	<span class="keyword">reg</span>	cnt;</span><br><span class="line">	<span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)	<span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">if</span>(!rst_n)</span><br><span class="line">			state_ce &lt;= INITIALSTATE;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			state_ce &lt;= state_nt;</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">always</span> @ (state_ce <span class="keyword">or</span> data)	<span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">case</span>(state_ce)</span><br><span class="line">			INITIALSTATE:	<span class="keyword">begin</span></span><br><span class="line">										cnt = <span class="number">1'b0</span>;</span><br><span class="line">										<span class="keyword">if</span>(data == <span class="number">1'b1</span>)</span><br><span class="line">											state_nt = STATE_0;</span><br><span class="line">										<span class="keyword">else</span></span><br><span class="line">											state_nt = INITIALSTATE;</span><br><span class="line">										<span class="keyword">end</span></span><br><span class="line">			STATE_0:			<span class="keyword">begin</span></span><br><span class="line">										cnt = <span class="number">1'b0</span>;</span><br><span class="line">										<span class="keyword">if</span>(data == <span class="number">1'b0</span>)</span><br><span class="line">											state_nt = STATE_1;</span><br><span class="line">										<span class="keyword">else</span></span><br><span class="line">											state_nt = STATE_0;</span><br><span class="line">										<span class="keyword">end</span></span><br><span class="line">			STATE_1:			<span class="keyword">begin</span></span><br><span class="line">										cnt = <span class="number">1'b0</span>;</span><br><span class="line">										<span class="keyword">if</span>(data == <span class="number">1'b1</span>)</span><br><span class="line">											state_nt = STATE_2;</span><br><span class="line">										<span class="keyword">else</span></span><br><span class="line">											state_nt = INITIALSTATE;</span><br><span class="line">										<span class="keyword">end</span></span><br><span class="line">			STATE_2:			<span class="keyword">begin</span></span><br><span class="line">										<span class="keyword">if</span>(data == <span class="number">1'b1</span>)</span><br><span class="line">											state_nt= STATE_3;</span><br><span class="line">										<span class="keyword">else</span></span><br><span class="line">											state_nt =STATE_1;</span><br><span class="line">										<span class="keyword">end</span></span><br><span class="line">			STATE_3:			<span class="keyword">begin</span></span><br><span class="line">										cnt = <span class="number">1'b1</span>;</span><br><span class="line">										state_nt = INITIALSTATE;</span><br><span class="line">										<span class="keyword">end</span>			</span><br><span class="line">		<span class="keyword">endcase</span></span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">assign</span>	cntout = cnt;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<p>三段式写法，又将输出写作时序逻辑输出，解决了二段式中毛刺的问题。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> pro(</span><br><span class="line">	<span class="keyword">input</span>	clk,</span><br><span class="line">	<span class="keyword">input</span>	rst_n,</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">input</span>	data,</span><br><span class="line">	<span class="keyword">output</span>	cntout</span><br><span class="line">);</span><br><span class="line">	<span class="keyword">parameter</span>	INITIALSTATE = <span class="number">5'b00_001</span>,</span><br><span class="line">						STATE_0 = <span class="number">5'b00_010</span>,</span><br><span class="line">						STATE_1 = <span class="number">5'b00_100</span>,</span><br><span class="line">						STATE_2 = <span class="number">5'b01_000</span>,</span><br><span class="line">						STATE_3 = <span class="number">5'b10_000</span>;</span><br><span class="line">						</span><br><span class="line">	<span class="keyword">reg</span>[<span class="number">4</span>:<span class="number">0</span>]	state_ce;</span><br><span class="line">	<span class="keyword">reg</span>[<span class="number">4</span>:<span class="number">0</span>]	state_nt;</span><br><span class="line">	<span class="keyword">reg</span>	cnt;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)	<span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">if</span>(!rst_n)</span><br><span class="line">			state_ce &lt;= INITIALSTATE;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			state_ce &lt;= state_nt;</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">			</span><br><span class="line">	<span class="keyword">always</span> @ (state_ce <span class="keyword">or</span> data)	<span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">case</span>(state_ce)</span><br><span class="line">			INITIALSTATE:	<span class="keyword">if</span>(data == <span class="number">1'b1</span>)</span><br><span class="line">										state_nt = STATE_0;</span><br><span class="line">									<span class="keyword">else</span></span><br><span class="line">										state_nt = INITIALSTATE;</span><br><span class="line">			STATE_0:			<span class="keyword">if</span>(data == <span class="number">1'b0</span>)</span><br><span class="line">										state_nt = STATE_1;</span><br><span class="line">									<span class="keyword">else</span></span><br><span class="line">										state_nt = STATE_0;</span><br><span class="line">			STATE_1:			<span class="keyword">if</span>(data == <span class="number">1'b1</span>)</span><br><span class="line">										state_nt = STATE_2;</span><br><span class="line">									<span class="keyword">else</span></span><br><span class="line">										state_nt = INITIALSTATE;</span><br><span class="line">			STATE_2:			<span class="keyword">if</span>(data == <span class="number">1'b1</span>)</span><br><span class="line">										state_nt = STATE_3;</span><br><span class="line">									<span class="keyword">else</span> </span><br><span class="line">										state_nt = STATE_2;</span><br><span class="line">			STATE_3:  		state_nt = INITIALSTATE;</span><br><span class="line">		<span class="keyword">endcase</span></span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)	<span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">if</span>(!rst_n)</span><br><span class="line">			cnt &lt;= <span class="number">'d0</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(state_nt == STATE_3)</span><br><span class="line">			cnt &lt;= <span class="number">1'b1</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			cnt &lt;= <span class="number">1'b0</span>;</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">		</span><br><span class="line">	<span class="keyword">assign</span>	cntout = cnt;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>FPGA</category>
      </categories>
      <tags>
        <tag>FPGA</tag>
        <tag>状态机</tag>
      </tags>
  </entry>
  <entry>
    <title>FPGA--inout的用法</title>
    <url>/2018/01/16/FPGA%E2%80%94%E2%80%94inout%E7%9A%84%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<p>﻿inout，顾名思义，也就是这个端口既可以输入数据也可以输出数据，但是他有一个规则：当他做输入端口时，一定要置为高阻态。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">reg</span>	out_data;</span><br><span class="line"><span class="keyword">reg</span>	test_cnt;<span class="comment">//test端口输入\输入方向控制位，1  输入  0  输出</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span>	test = test_cnt ? <span class="number">1'bz</span> : out_data;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>FPGA</category>
      </categories>
      <tags>
        <tag>FPGA</tag>
        <tag>inout</tag>
      </tags>
  </entry>
  <entry>
    <title>FPGA--for循环的些许思考</title>
    <url>/2018/01/16/FPGA%E2%80%94%E2%80%94for%E5%BE%AA%E7%8E%AF%E7%9A%84%E4%BA%9B%E8%AE%B8%E6%80%9D%E8%80%83/</url>
    <content><![CDATA[<p>​        以前的学习的时候，没有用过verilog中的for循环。在数字电路的课堂上，也经常会想循环电路到底是一个什么样的电路呢？在我的脑海中，感觉循环电路就像那种重复利用已知电路的电路，我是这样理解的：for循环语句块中的执行语句是一样的，其生成的电路也是一样的，这个电路我把 它交做执行电路。那么循环电路是不是就是根据条件判断运行执行电路呢，就是那种类似于负反馈电路。根据执行电路输出的一个结果来决定下次 是否要还要继续运行执行电路。</p>
<a id="more"></a>

<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> Pro(</span><br><span class="line">	<span class="keyword">input</span>	clk,</span><br><span class="line">	<span class="keyword">input</span>	rst_n,</span><br><span class="line">	<span class="keyword">input</span>[<span class="number">12</span>:<span class="number">0</span>]	data,</span><br><span class="line">	<span class="keyword">output</span>[<span class="number">3</span>:<span class="number">0</span>]	numout</span><br><span class="line">);</span><br><span class="line">	<span class="keyword">reg</span>[<span class="number">3</span>:<span class="number">0</span>]	i;</span><br><span class="line">	<span class="keyword">reg</span>[<span class="number">3</span>:<span class="number">0</span>]	num;</span><br><span class="line">	<span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)	<span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">if</span>(!rst_n)	<span class="keyword">begin</span></span><br><span class="line">			num = <span class="number">'d0</span>;</span><br><span class="line">			i = <span class="number">'d0</span>;</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">		<span class="keyword">else</span>	<span class="keyword">begin</span></span><br><span class="line">			num = <span class="number">'d0</span>;</span><br><span class="line">			<span class="keyword">for</span>(i = <span class="number">'d0</span>;i &lt;= <span class="number">12</span>;i = i + <span class="number">1</span>)	</span><br><span class="line">				<span class="keyword">if</span>(data[i])</span><br><span class="line">					num = num + <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">end</span>				</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span>	numout = num;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<p>for循环生成的RTL图如下：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTgwMTE2MjAyMTQyOTA5?x-oss-process=image/format,png" alt="这里写图片描述"><br>一个时钟周期检测一次的RTL图如下：<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTgwMTE2MjAyNjEwNTg4?x-oss-process=image/format,png" alt="这里写图片描述"><br>    事实结果和我想的相差太远，反而是一个时钟周期检测一次的电路和我想的一样。我们可以看到for循环电路虽然节省了时间，但是占用的资源也明显较多。<br>    在实际应用中，我们到底应该不应该大胆的使用for循环呢？<br>    我自己的观点：当你只考虑速度而不关心电路的话，是可以使用for循环的。</p>
]]></content>
      <categories>
        <category>FPGA</category>
      </categories>
      <tags>
        <tag>FPGA</tag>
        <tag>for循环</tag>
      </tags>
  </entry>
  <entry>
    <title>模拟登录知乎</title>
    <url>/2017/09/09/%E7%94%A8python%E5%81%9A%E6%9C%89%E8%B6%A3%E7%9A%84%E4%BA%8B%E5%84%BF%E2%80%94%E2%80%94%E6%A8%A1%E6%8B%9F%E7%99%BB%E9%99%86%E7%9F%A5%E4%B9%8E/</url>
    <content><![CDATA[<p><font face="宋体" size="4">  用Python做网络数据采集，是非常方便的。特别是使用第三方库requests。<br>    window下安装方法         pip install requests<br>    处理网页超文本信息，使用第三方库BeautifulSoup，也是很方便。<br>    window下安装方法         pip install beautifulsoup4<br>    通常会用到的是requests.get()和requests.post()。</font></p>
<a id="more"></a>

<p>其他的，当你需要的时候去官方文档是最好的捷径。<br>    我们处理的还是HTML，了解一些HTML是必须的，起码得知道标签，属性，属性值等等，只有这样我们才能在一堆信息里提取出我们想要得信息。<br>    最近在看《Python网络数据采集》，打算拿知乎当作练手的网站（心疼知乎-。-）。知乎毕竟是企业级的网站，在模拟登录的时候遇到了很多挫折，对，就是挫折，前几天因为一直登录不上还放弃过（呸，丢人的家伙）。今天不经意的在书中看到隐藏字段，恍然大悟。原来知乎的表单里有隐藏字段啊。<br>   通过BeautifulSoup过滤出隐藏字段，然后post，但是还是不能登录成功，很恼火。逼不得已上网看了别人的源码，竟然有验证码，我在知乎的网页端没看见啊，所以我把验证码的这快程序加上，结果，，，，登录成功。好吧，知乎你赢了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">Info</span><br><span class="line">- auther  : Cherish_x</span><br><span class="line">- qq      : 344799672</span><br><span class="line">- data    : 2017.9.8</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">import re</span><br><span class="line">import time</span><br><span class="line">import requests</span><br><span class="line">from io import BytesIO</span><br><span class="line">from PIL import Image</span><br><span class="line">from bs4 import BeautifulSoup</span><br><span class="line"></span><br><span class="line">loadpost_url = &apos;https://www.zhihu.com/login/phone_num&apos;</span><br><span class="line">load_url = &apos;https://www.zhihu.com/#signin&apos;</span><br><span class="line">agent = &apos;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.104 Safari/537.36&apos;</span><br><span class="line">headers = &#123;</span><br><span class="line">    &apos;User-Agent&apos;: agent,</span><br><span class="line">    &apos;Referer&apos;: &apos;https://www.zhihu.com/&apos;,</span><br><span class="line">    &apos;Host&apos;: &apos;www.zhihu.com&apos;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">FormData = &#123;</span><br><span class="line">    &apos;_xsrf&apos;: &apos;&apos;,</span><br><span class="line">    &apos;password&apos;: &apos;xu344799672&apos;,</span><br><span class="line">    &apos;phone_num&apos;: &apos;17853530696&apos;</span><br><span class="line">&#125;</span><br><span class="line">#———————————————————————————————————————————————————————————</span><br><span class="line">#       模拟登陆知乎</span><br><span class="line">def anaLoad(load_url, loadpost_url, headers, FormData):</span><br><span class="line">    #—————————————————————————————————————————————————————————</span><br><span class="line">    #   保持会话信息</span><br><span class="line">    session = requests.session()</span><br><span class="line">    #—————————————————————————————————————————————————————————</span><br><span class="line">    #   获取动态参数_xsrf</span><br><span class="line">    r = session.get(load_url, headers=headers)</span><br><span class="line">    _xsrf = r.cookies[&apos;_xsrf&apos;]</span><br><span class="line">    FormData[&apos;_xsrf&apos;] = _xsrf</span><br><span class="line">    #—————————————————————————————————————————————————————————</span><br><span class="line">    #   获取验证码，并以照片的形式打开，手动输入</span><br><span class="line">    randomtime = str(int(time.time() * 1000))</span><br><span class="line">    captchaurl = &apos;https://www.zhihu.com/captcha.gif?r=&apos; + \</span><br><span class="line">                 randomtime + &quot;&amp;type=login&quot;</span><br><span class="line">    captcharesponse = session.get(url=captchaurl, headers=headers)</span><br><span class="line">    tempIm = BytesIO(captcharesponse.content)  # 将数据流放入tempIm以字节的形式</span><br><span class="line">    im = Image.open(tempIm)  # 转换为图片的形式</span><br><span class="line">    im.show()  # 打开</span><br><span class="line">    captch = input(&apos;Please input coding:&apos;)</span><br><span class="line">    #—————————————————————————————————————————————————————————</span><br><span class="line">    #   登录</span><br><span class="line">    FormData[&apos;captcha&apos;] =captch</span><br><span class="line">    posthtml = session.post(loadpost_url, data=FormData, headers=headers)</span><br><span class="line">    #print(posthtml.cookies)</span><br><span class="line">    msg = eval(posthtml.text)#  转为字典格式</span><br><span class="line">    print(msg[&apos;msg&apos;])</span><br><span class="line">    return session  #返回会话信息，以备下次使用</span><br><span class="line"></span><br><span class="line">#———————————————————————————————————————————————————————————</span><br><span class="line">#   跳转知乎内链</span><br><span class="line">def throughUrl(session, headers):</span><br><span class="line">    urlList = []</span><br><span class="line">    r = session.get(&apos;https://www.zhihu.com/#signin&apos;, headers=headers)</span><br><span class="line">    bs0bj = BeautifulSoup(r.text, &apos;html.parser&apos;)</span><br><span class="line">    Text = bs0bj.findAll(&apos;meta&apos;, &#123;&apos;itemprop&apos;: &apos;url&apos;&#125;)</span><br><span class="line">    for i in Text:</span><br><span class="line">        i = i.attrs[&apos;content&apos;]</span><br><span class="line">        if i not in urlList and &apos;www.zhihu.com&apos; in i:#  去重、去外链（知乎专栏，不能跳转，待解决）</span><br><span class="line">            urlList.append(i)</span><br><span class="line">            accessUrl(session, i, headers, urlList)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#———————————————————————————————————————————————————————————</span><br><span class="line">#   访问链接</span><br><span class="line">def accessUrl(session, url, headers, urlList):</span><br><span class="line">    r = session.get(url, headers=headers)</span><br><span class="line">    bs0bj = BeautifulSoup(r.text, &apos;html.parser&apos;)</span><br><span class="line">    #text = bs0bj.findAll(&apos;span&apos;, &#123;&apos;itemprop&apos;: &apos;text&apos;&#125;)</span><br><span class="line">    text = bs0bj.findAll(&apos;meta&apos;, &#123;&apos;itemprop&apos;: &apos;name&apos;&#125;)</span><br><span class="line">    print(text)</span><br><span class="line">    print(&apos;——————————————————————————————————————————————————&apos;)</span><br><span class="line">    html = bs0bj.findAll(&apos;meta&apos;, &#123;&apos;itemprop&apos;: &apos;url&apos;&#125;)#  寻找链接所在</span><br><span class="line">    for i in html:</span><br><span class="line">        i = i.attrs[&apos;content&apos;]</span><br><span class="line">        if i not in urlList and &apos;www.zhihu.com&apos; in i:#  去重、去外链（知乎专栏，不能跳转，待解决）</span><br><span class="line">            urlList.append(i)</span><br><span class="line">            time.sleep(3)</span><br><span class="line">            accessUrl(session, i, headers, urlList)</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    session = anaLoad(load_url, loadpost_url, headers, FormData)</span><br><span class="line">    throughUrl(session, headers)</span><br></pre></td></tr></table></figure>

<p>&lt;font face = ‘宋体’， size = 4&gt;    目前实现了模拟登陆知乎，遍历采集的知乎内链（去重检查），值得注意的是，一定要有延时，应为知乎的防爬意识很严肃，在调试程序的时候，我就经常被知乎封ip，此时需要用网页登录一次输入验证码即可。    </p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>将.py文件打包为.exe</title>
    <url>/2017/08/30/%E7%94%A8Python%E5%81%9A%E6%9C%89%E8%B6%A3%E7%9A%84%E4%BA%8B%E5%84%BF%E2%80%94%E2%80%94%E6%89%93%E5%8C%85%E7%A8%8B%E5%BA%8F%E4%B8%BA.exe/</url>
    <content><![CDATA[<p>﻿<font face="宋体" size="4">     Python作为一种脚本语言，我们在学习的时候，会发现，用编辑器码完代码后，生成的不是.exe文件，这点和C语言不同，生成的是.py文件，想要运行就必须在有安装Python的环境下，执行.py。写好一个脚本想给别人用，就得把它打包为.exe文件。<br>    我选择使用pyinstaller第三方。</font></p>
<a id="more"></a>

<p>​    pip下载方法：pip install pyinstaller<br>​    使用方法：在cmd命令行下，打开待打包的.py文件目录，<br>​    执行命令，pyinstaller –F (yourPro).py，会生成单个可执行文件<br>​              pyinstaller – key (password)，加密你的代码，实测还需要一个第三方PyCryto，这个第三方又需要ＶＣ＋＋２０１５，挺麻烦的，也就没试过这条命令行。<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwODMwMTQ1OTE3MTIy?x-oss-process=image/format,png" alt="这里写图片描述"><br>​    上一张成品图，目前版本的脚本，实现了查询当前已抽中课程信息并打印，查询培养方案的课程信息，比较两个信息，寻找为抽中的课程，检查未抽中课程的课余量，如果课余量大于0，自动帮用户 选上。</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>模拟登录学校教务系统</title>
    <url>/2017/08/29/%E7%94%A8Python%E5%81%9A%E6%9C%89%E8%B6%A3%E7%9A%84%E4%BA%8B%E5%84%BF%E2%80%94%E2%80%94%E6%A8%A1%E6%8B%9F%E7%99%BB%E9%99%86%E5%AD%A6%E6%A0%A1%E6%95%99%E5%8A%A1%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p> HTTP，说白了就是用Post，Get获取信息。选课，咱们得先登录学校的教务系统啊，所以用<strong>谷歌浏览器</strong>观察当我们登录教务系统的时候，网页干了什么。在登录页面，按F12，打开开发者工具，假装登录一下。</p>
<a id="more"></a>

<p>   我们发现当我们登录的时候，网页带着数据Post了一下，我们只要模仿这个Post，就可以登录啦，是不是特别简单。<br>    但是我们发现，有验证码啊，这个就是用来鉴别登录的用户是人还是机器人。这个识别验证码，大家可以用python的图像处理的一些第三方处理试试，我是直接把图片提取出来，然后人工输入的。<br>   也就是说，我们获取了验证码后，再把账号，密码，验证码给Post上去。一来一去，我们就访问了两次服务器，但是我们得让服务器知道这两次访问都是来自同一个ip的，否则验证码就变了，我们也就不能成功Post了。这个时候，cookies就帮了大忙，她可以帮助我们使得两次访问是同一个会话，怎么保持cookies，Python的第三方库requerts可就十分强大了，session = requests.session()，就可以帮助我们建立一个会话，保持会话信息。<br>好了，废话不多说了，直接上。<br>   我用的Python3.5，一开始用的Python3.6，可是不能打包成exe文件，就退回了Pyhton3.5。编辑器用的Pycharm，个人观点这是一款非常棒的编辑器。<br>   首先，安装需要的第三方库。BeautifulSoup（和正则一起用，还不是爽歪歪）、requests（让HTTP服务于人类）和PIL（图像处理的一个第三方，我用它把扒取的验证码打开，然后人工输入）。如果你安装的Python3，也就自动安装了pip（用pip不是更简单吗？）<br>   三个第三方的pip下载方法：pip install beautifulsoup4<br>                            pip install requests<br>                            pip install Pillow<br>                              以我们学校的教务系统为例。打开开发者工具，点击Network，然后账号，密码，验证码瞎打点登录，就会在右边看见在登录的时候发生了什么。<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwODI5MjExNzM1ODAy?x-oss-process=image/format,png" alt="这里写图片描述">   找到一个跟登录有关的.do文件，选择headers，会看到她往一个网址(Request URL，这个url暂定义为post_url)post了一下，请求表头（Requests Headers）也在这里，里面就有咱需要的cookies，需要关注一点Referer，这里必须从Referer一栏的网址跳到这里才行。大家可以先试下不跳会怎么样，因为每个教务系统都是不一样的，不需要跳转的，就直接Post就好了。<img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwODI5MjEzMDI0Mzg0?x-oss-process=image/format,png" alt="这里写图片描述">    下拉会看到在Post的数据，分别是账号，密码，验证码，其他的可能会有别的参数，应该只有 这三个是变得。我只需要在Post的时候将数据也带上就行了。不得不说，Python3的第三方库requests实在强大，甚至暴力，又有点小清新<img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwODI5MjEzMzM5MjA0?x-oss-process=image/format,png" alt="这里写图片描述">。    点击Preview，然后挨个选择Name下的文件，找到出现验证码的一个。像下图。<img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwODI5MjEzNTM3NzUy?x-oss-process=image/format,png" alt="这里写图片描述">    再点回Headers可以看到登录的时候验证码是怎么来的，Requests URL就是我们要获取验证码而Get的url，只取红线的部分（暂定义为yzm_url）即可，后面就是唬人的。在表头那块我们可以看到Referer是loginAction.do的url。<img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwODI5MjE0MTA1Mjg5?x-oss-process=image/format,png" alt="这里写图片描述">    所以思路就来了，我们可以先访问post_url，拿到cookies后，利用session保持会话，访问yzm_url，获得验证码后，再将账号、密码和验证码Post到post_url。至此我们就可以模拟登陆教务系统了。<br>   下面直接贴核心代码了（支持开源）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">            session = requests.session()  <span class="comment"># 建立会话，保持会话信息，cookies</span></span><br><span class="line">            r = session.get(post_url)</span><br><span class="line">            cookies = r.headers[<span class="string">'Set-Cookie'</span>]  <span class="comment"># 获取cookies</span></span><br><span class="line">            cookies = cookies.strip(<span class="string">'; path=/'</span>)  </span><br><span class="line">            yam_headers = &#123;</span><br><span class="line">                <span class="string">'Accept'</span>: <span class="string">'image/webp,image/apng,image/*,*/*;q=0.8'</span>,</span><br><span class="line">                <span class="string">'Accept-Encoding'</span>: <span class="string">'gzip, deflate'</span>,</span><br><span class="line">                <span class="string">'Accept-Language'</span>: <span class="string">'zh-CN,zh;q=0.8'</span>,</span><br><span class="line">                <span class="string">'Connection'</span>: <span class="string">'keep-alive'</span>,</span><br><span class="line">                <span class="string">'Cookie'</span>: cookies,</span><br><span class="line">                <span class="string">'Host'</span>: <span class="string">'************'</span></span><br><span class="line">                <span class="string">'Referer'</span>:<span class="string">'*************'</span> </span><br><span class="line">                <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.104 Safari/537.36'</span></span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">#这是获取验证码的表头，这里的链接通google浏览器的开发者工具，按照前面说的去找。</span></span><br><span class="line">            yamdata = session.get(yzm_url, headers=yam_headers)  <span class="comment"># 获取验证码</span></span><br><span class="line">            tempIm = BytesIO(yamdata.content)  <span class="comment"># 将数据流放入tempIm以字节的形式</span></span><br><span class="line">            im = Image.open(tempIm)  <span class="comment"># 转换为图片的形式</span></span><br><span class="line">            im.show()  <span class="comment"># 展示验证码</span></span><br><span class="line">            Code = input(<span class="string">'Please Enter Code:'</span>)</span><br><span class="line">            logindata[<span class="string">'v_yzm'</span>] = Code</span><br><span class="line">            login_headers = &#123;</span><br><span class="line">                <span class="string">'Accept'</span>: <span class="string">'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8'</span>,</span><br><span class="line">                <span class="string">'Accept-Encoding'</span>: <span class="string">'gzip, deflate'</span>,</span><br><span class="line">                <span class="string">'Accept-Language'</span>: <span class="string">'zh-CN,zh;q=0.8'</span>,</span><br><span class="line">                <span class="string">'Cache-Control'</span>: <span class="string">'max-age=0'</span>,</span><br><span class="line">                <span class="string">'Connection'</span>: <span class="string">'keep-alive'</span>,</span><br><span class="line">                <span class="string">'Content-Length'</span>: <span class="string">'37'</span>,</span><br><span class="line">                <span class="string">'Content-Type'</span>: <span class="string">'application/x-www-form-urlencoded'</span>,</span><br><span class="line">                <span class="string">'Cookie'</span>: <span class="string">''</span>,</span><br><span class="line">                <span class="string">'Host'</span>: <span class="string">'***********'</span></span><br><span class="line">                <span class="string">'Origin'</span>: <span class="string">'*********'</span></span><br><span class="line">                <span class="string">'Referer'</span>: <span class="string">'***********'</span></span><br><span class="line">                <span class="string">'Upgrade-Insecure-Requests'</span>: <span class="string">'1'</span>,</span><br><span class="line">                <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.104 Safari/537.36'</span></span><br><span class="line">            &#125;</span><br><span class="line">            login_headers[<span class="string">'Cookie'</span>] = cookies</span><br><span class="line">            d = session.post(post_url, data=logindata, headers=login_headers)<span class="comment">#将账号，密码，验证码和表头Post上去，然后我们可以用过BeautifulSoup或者正则表达式，抓取d.text有用的信息，判断是否登录成功。</span></span><br></pre></td></tr></table></figure>

<pre><code>&lt;font face = &quot;宋体&quot; size = 4&gt; 我们成功模拟登陆教务系统后，就可以做一些我我们想做的事情了，例如抢课。模拟登陆搞明白了，抢课也就很简单了，就是Get或者Post的而已，我浪费了很多时间和代码在处理文本信息上。因为每个学校的教务系统不一样，所以就不贴代码了。</code></pre><p>​    </p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>简易频谱分析仪和频率特性测试仪的原理</title>
    <url>/2017/08/04/%E7%AE%80%E6%98%93%E9%A2%91%E8%B0%B1%E5%88%86%E6%9E%90%E4%BB%AA%E5%92%8C%E9%A2%91%E7%8E%87%E7%89%B9%E6%80%A7%E6%B5%8B%E8%AF%95%E4%BB%AA%E7%9A%84%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>﻿<font face="楷体" size="5">   17年电赛的元器件清单下来了,基本仪器有频率特性测试仪，且13年国赛出现过，15年国赛也出现过频谱分析仪，知乎上有人猜测今年依然会出频域测量的题，这几天我就找了不少资料。了解了频谱分析仪和频率特性测试仪的原理。 </font><br>—————————————————————————————————————————————————————</p>
<a id="more"></a>

<p><font face="宋体" size="5"><strong>频谱分析仪</strong> </font><br><font face="宋体" size="4">     频谱分析仪主要用来分析信号中各频率成分。主要有多滤波器并行分析式、扫频外差分析式和FFT分析式。但是电赛做简易频谱分析仪我们常用扫频法。多滤波器并行分析太依赖硬件，在做测量仪器中，硬件的难度已经很大了。FFT分析式太依赖AD采样速率，像15年的赛题，做80M~100M，如果想用FFT做就要求AD芯片的采样速率可以达到200M以上。如果想采用等效采样法需要产生待分析信号的同频率的方波，才能精准的产生等效采样的时钟信号（至少我们现在掌握的技术，刚才请教了我们队的硬件，需要特定的芯片去转换）。<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwODA0MTAzNjQ5MDIx?x-oss-process=image/format,png" alt="这里写图片描述"></font><br><font face="宋体" size="4">    被测信号可能会有N个频谱分量，但利用一个<strong>频率连续扫动</strong>的扫频本地振荡器（扫频本振）产生的频率fL与被测信号混频，这样被测信号的第n个频谱分量总会有机会落入中频滤波器的通带中。通常令本地振荡的幅度保持不变，这时混频器的输出及经滤波后输出、显示都依次与被测信号的频谱分量的幅度成正比。检波后可在Y方向显示该频谱分量的大小。<br>    图中的扫频本振的输出频率是受扫描电压发生器控制的。若线性扫频，那扫描电压的幅度及扫频发生器的输出频率呈线性变化。我们可以直接把扫描电压用来驱动显示器光点在X方向移动，并把横轴直接用被测信号谱线的频率来刻度。<br> <strong>频谱分析仪的主要技术指标</strong><br>     <strong>1、有效频率范围</strong>是指在满足仪器性能指标的情况下，仪器能分析的最宽频率范围。在扫频外差式分析仪中，有效频率范围是指<strong>滤波器能选出的信号最低频率至最高频率。</strong><br>      <strong>2、频率相对误差</strong>是所有与频率相关仪器测量结果的基本保障，它对频谱仪是很重要的。<br>      <strong>3、灵敏度</strong> 用来表征在给定的其他指标条件下，频谱仪能测量最小信号的能力。<br>      <strong>4、分析时间或扫描时间</strong>，分析时间是指进行一次频谱分析所用的时间。对于扫频外差式分析仪分析时间实际上常指扫描或晨扫频时间，既显示器上扫描线从最左端扫到最右端所用的时间，应保证中频滤波器的动态特性不能因扫速过快而变坏。  </font><br> <font face="楷体" size="5"><strong>频率特性测试仪</strong> </font><br> <font face="宋体" size="4">   频率特性的测量有很多方法。其分类可以是正弦波点频测量，也可以是扫频测量；可以是直接法测量，也可以是比较法或称比值法测量；可以只反映幅值的增益或衰减，也可以既反映幅频特性又反映相频特性等。<br>     <strong>点频法</strong>既是将正弦信号被调至一个个频率点进行测量。<br>     <strong>扫频法</strong>是指采用一定方法使正弦信号的输出频率能随时间在一定范围内扫描。（个人理解和扫频外差式频谱分析仪差不多，一个是信号源经过系统，一个是和待测信号混频）<br>———————————————————————————————————————————————<br>    以上主要内容摘自《电子测量》第三版。侵删。  </font></p>
]]></content>
      <categories>
        <category>FPGA</category>
      </categories>
      <tags>
        <tag>电赛</tag>
      </tags>
  </entry>
  <entry>
    <title>FFT频率和实际物理频率的分析</title>
    <url>/2017/07/31/FFT%E9%A2%91%E7%8E%87%E5%92%8C%E5%AE%9E%E9%99%85%E7%89%A9%E7%90%86%E9%A2%91%E7%8E%87%E7%9A%84%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p><font face="楷体" size="5">之前有转载过一篇关于频谱分析的博客，今天想利用FPGA做FFT的有关计算，仔细查看了那篇博客发现原博主写的是一塌糊涂，被逼无奈拿起前几周考完期末考的《数字信号处理》，同时网上也有查资料，终于有一点思路了。</font><br>————————————————————————————————————————————</p>
<a id="more"></a>

<p><font face="宋体" size="4">FFT是快速傅里叶变换，是离散傅里叶变换的快速算法。我们想要利用FFT计算频率或者观察频谱特性，离不开DFT的定义和性质。先简单介绍三个名词。</font></p>
<p>[外链图片转存中…(img-Y1SwIZJR-1571226079885)]</p>
<p><font face="宋体" size="4">f 是实际物理频率，表示<strong>AD采集物理模拟信号的频率</strong>，Fs就是<strong>采样频率</strong>，根据<strong>奈奎斯特采样定理</strong>可以知道，Fs必须≥信号最高频率的2倍才能避免产生<strong>频谱混叠</strong>，也就是说用Fs做采样频率，信号的最高频率为Fs/2。<br>Ω称为模拟频率。ω称为数字频率。二者的关系<strong>ω = Ω/Fs</strong>。<br>假设x(n)的N点离散傅立叶变换为X(k),由定义式可以推出X(k)为x(n)的傅里叶变换X(e^jw)在区间[0,2π]上的N点等间隔采样，这也是DFT的物理意义。DFT的变换区间长度N不同，表示对傅里叶变换X(e^jw)在区间[0,2π]上的采样间隔和采样点数不同。N点DFT的结果还是N点。<br>我们通常只关心0<del>π的频谱，这是由于只有f = Fs/2范围内才是被采样到的有效信号。也既在ω的范围内得到的频谱是对称。</del></font><br><font face="宋体" size="4">举一个简单的例子，如果做16点DFT，假设模拟信号的最高频率为f = 64KHz,采样频率是Fs = 128KHz，根据模拟频率和数字频率的关系可以知道128KHz的模拟采样频率被分成16份，每一份是8KHz，这就是<strong>频率分辨率</strong>（频率分辨率可以理解为在使用DFT时，在频率轴上的所能得到的最小频率间隔f0 = fs/N =1/T ，其中N为采样点数，  fs为采样频率,T为采样前模拟信号的时间长度。所以信号长度越长，频率分辨率越好。摘自百度百科）。如果想要提高频率分辨率，在做FFT的时候可以适当增加采样点数。那么DFT得到的频谱的横坐标，n = 0时对应的f = 0，n = 1时对应的f = 8KHz，依次类推n = 7时对应f = 56KHz，因为模拟信号的最高频率为64KHz,而且频谱是关于n = 8对称，所以我们只需要关心n取07以内的频谱就足够了。<br>如果我们想求第k个点的实际频率，我们必须知道原信号的采样频率和采样点数。公式为f(k)=k<em>(fs/n)。</em></font><br><font face="宋体" size="5">*用DFT对连续信号进行谱分析<strong></strong></font><br><font face="宋体" size="4">在对连续信号进行谱分析时，主要关心两个问题，就是谱分析范围和频率分辨率。谱分析范围为[0，Fs/2]，直接受采样频率Fs的限制，为了不产生频谱混叠失真，通常要求信号的最高频率f &lt; Fs/2。频率分辨率用频率采样间隔F来描述，F = Fs/N；F表示谱分析中能够分辨的两个频率分量的最小间隔。F较小时，频率分辨率较高。如果维持采样频率Fs不变，为提高频率分辨率可以增加采样点数N，只要增加对信号的观察时间Tp，才能增加采样点数N。</font><br><font face="宋体" size="5">用DFT进行谱分析的误差问题**</font><br><font face="宋体" size="4">        DFT可用来对连续信号和数字信号进行谱分析，在实际分析过程中，要对连续信号采样和截断，就会引发误差，下面介可能产生误差的三种现象。<br>（1）混叠现象。对连续信号进行谱分析是，首先要对其采样，变成时域离散信号后才能用DFT(FFT)进行谱分析。采样速率Fs必须满足奈奎斯特采样定理，否则会在Fs/2附近发生频谱混叠现象。<br>（2）栅栏效应。N点DFT是在频率区间[0，2π]上对时域离散信号的频谱进行N点等间隔采样，而采样点之间的频谱是看不到的。就像上文中举的例子，原来信号可能会在5KHz出有频谱的分量，但我们的频率分辨率只有8KHz，这就导致我们无法观察在5KHz的分量。要想观察，我们就必须提高频率分辨率。对于有限长序列，可以在原序列尾部补零；对于无限长序列，可以增大截取长度及DFT变换区间长度，从而使频域采样间隔变小，增加频域采样点数和采样点位置，使原来漏掉的某些频谱分量被检测出来。对于连续信号的谱分析，只要采样速率Fs足够高，且采样点数满足频率分辨率要求，就可以认为DFT后所得离散谱的包络近似代表原信号的频谱。<br>（3）截断效应。实际中遇到的序列x(n)可能无限长的，用DFT进行谱分析时，必须将其截断，形成有限长序列。而截断后序列的频谱必将发生变化。主要有两个方面：<br>    ①泄露 ：原来的序列的频谱是离散谱线，经截断后，使原来的离散谱线向附近展宽。通常称这种展宽为泄露。泄露使频谱变模糊，频率分辨率降低。<br>    ②谱间干扰。</font></p>
]]></content>
      <categories>
        <category>FPGA</category>
      </categories>
      <tags>
        <tag>FFT</tag>
      </tags>
  </entry>
  <entry>
    <title>FPGA利用FIFO做数据缓冲</title>
    <url>/2017/07/30/FPGA%E5%88%A9%E7%94%A8FIFO%E5%81%9A%E6%95%B0%E6%8D%AE%E7%BC%93%E5%86%B2/</url>
    <content><![CDATA[<p>﻿今天尝试使用了Quartus Ⅱ 15.1 的FIFO的IP核。<br>———————————————————————————————————————<br>简单介绍一下FIFO。FIFO（First Input First Output），很容易理解，就是先进先出，和数据结构里的队列一样。举一个通俗的例子，在超市买东西，结账的时候，大家都在排队，先排队的人先结账走人，不在这里逗留（这点和RAM不同）。所以FIFO通常是作为数据缓冲结构，一般用于不同时钟域之间的数据传输，比如FIFO一端是采样速率比较慢的接口，另一端是采样速率比较块的接口。也可以用于输入数据和输出数据位宽不同的情况。</p>
<a id="more"></a>

<p>Ip核的参数配置网上有很多，大家也可以看下《HELLO FPGA》里的详细介绍。<br>FIFO IP核主要用于同步或异步时钟域先入先出数据流的缓存。<br>FIFO是没有读写地址的，根据读写使能和上升沿触发的时钟进行写入和读出。而且数据不再FIFO里逗留，读出既从“结完账走人了”。所以它有写满和读空的标志位，我们可以利用两个标志位写读写逻辑使能，这一点比利用双口RAM做缓冲会简单方便很多。<br>简单的贴下代码，使用SignalTap仿真。 </p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span>	fifo(</span><br><span class="line">		clk,rst_n,</span><br><span class="line">		RomAddr,rddata,RomData,rden,full,empty,clk_10M</span><br><span class="line">						</span><br><span class="line">);</span><br><span class="line"><span class="keyword">input</span>						clk;</span><br><span class="line"><span class="keyword">input</span>						rst_n;</span><br><span class="line"><span class="keyword">output</span>				[<span class="number">7</span>:<span class="number">0</span>]		RomData;</span><br><span class="line"><span class="keyword">output</span>		<span class="keyword">reg</span>		[<span class="number">4</span>:<span class="number">0</span>]		RomAddr;</span><br><span class="line"><span class="keyword">output</span>				[<span class="number">7</span>:<span class="number">0</span>]		rddata;</span><br><span class="line"><span class="keyword">output</span>		<span class="keyword">reg</span>				rden;</span><br><span class="line"><span class="keyword">output</span>						full;</span><br><span class="line"><span class="keyword">output</span>						empty;</span><br><span class="line"><span class="keyword">output</span>						clk_10M;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line">	<span class="keyword">if</span>(!rst_n)</span><br><span class="line">		rden &lt;= <span class="number">'d0</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(full)</span><br><span class="line">		rden &lt;= <span class="number">1'b1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(empty)</span><br><span class="line">		rden &lt;= <span class="number">1'b0</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		rden &lt;= rden;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">Dif_Fifo Dif_Fifo_inst (</span><br><span class="line">	<span class="variable">.data</span>(RomData),</span><br><span class="line">	<span class="variable">.rdclk</span>(clk),</span><br><span class="line">	<span class="variable">.rdreq</span>(rden),</span><br><span class="line">	<span class="variable">.wrclk</span>(clk_10M),</span><br><span class="line">	<span class="variable">.wrreq</span>(~rden),</span><br><span class="line">	<span class="variable">.q</span>(rddata),</span><br><span class="line">	<span class="variable">.rdempty</span>(empty),</span><br><span class="line">	<span class="variable">.wrfull</span>(full)</span><br><span class="line">	);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">FIFO FIFO_inst (</span></span><br><span class="line"><span class="comment">	.clock(clk),</span></span><br><span class="line"><span class="comment">	.data(RomData),</span></span><br><span class="line"><span class="comment">	.rdreq(rden),</span></span><br><span class="line"><span class="comment">	.wrreq(wren),</span></span><br><span class="line"><span class="comment">	.empty(empty),</span></span><br><span class="line"><span class="comment">	.full(full),</span></span><br><span class="line"><span class="comment">	.q(rddata),</span></span><br><span class="line"><span class="comment">	.usedw(usedw)</span></span><br><span class="line"><span class="comment">);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*****************10M去读rom*****************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//reg		[4:0]		RomAddr;</span></span><br><span class="line"><span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk_10M <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line">	<span class="keyword">if</span>(!rst_n)</span><br><span class="line">		RomAddr &lt;= <span class="number">'d0</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(RomAddr &gt;= <span class="number">5'd31</span>)</span><br><span class="line">		RomAddr &lt;= <span class="number">'d0</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		RomAddr &lt;= RomAddr  + <span class="number">1'b1</span>;</span><br><span class="line">		</span><br><span class="line"></span><br><span class="line"><span class="comment">//wire		[7:0]		RomData;</span></span><br><span class="line">Rom_Test Rom_Test_inst (</span><br><span class="line">	<span class="variable">.address</span>(RomAddr),</span><br><span class="line">	<span class="variable">.clock</span>(clk_10M),</span><br><span class="line">	<span class="variable">.q</span>(RomData)</span><br><span class="line">	);</span><br><span class="line">	</span><br><span class="line"><span class="comment">/*****PLL分频产生10M的时钟*****/</span></span><br><span class="line"><span class="comment">//wire						clk_10M;</span></span><br><span class="line">Ip_Core_PLL Ip_Core_PLL_inst (</span><br><span class="line">		 <span class="variable">.refclk</span>(clk),   <span class="comment">//  refclk.clk</span></span><br><span class="line">		 <span class="variable">.rst</span>(!rst_n),      <span class="comment">//   reset.reset</span></span><br><span class="line">		 <span class="variable">.outclk_0</span>(clk_10M), <span class="comment">// outclk0.clk</span></span><br><span class="line">		 <span class="variable">.locked</span>()    <span class="comment">//  locked.export</span></span><br><span class="line">	);</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<p>仿真：<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNzMwMjAwMTMyNjQ3?x-oss-process=image/format,png" alt="这里写图片描述"></p>
]]></content>
      <categories>
        <category>FPGA</category>
      </categories>
      <tags>
        <tag>FPGA</tag>
        <tag>FIFO</tag>
        <tag>数据缓冲</tag>
      </tags>
  </entry>
  <entry>
    <title>等精度测频的原理和基于FPGA的实现</title>
    <url>/2017/07/29/%E7%AD%89%E7%B2%BE%E5%BA%A6%E6%B5%8B%E9%A2%91%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E5%9F%BA%E4%BA%8EFPGA%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>﻿我们通过FPGA测量信号频率，一般来说有两种方案。传统测频法和等精度测频法。<br>方案一：<br>传统测频是在一段闸门时间内直接对输入信号的周期进行计数，也被叫做直接测频法。设闸门信号为gate，检测待测信号上升沿，然后判断gate是否为高电平，若为高电平便开始计数。这就存在gate的时间和待测信号周期数可能不成整数倍，导致产生+1hz或-1hz的误差。</p>
<a id="more"></a>

<p>方案二：<br>等精度测频可以弥补传统测频的缺点，它保证了闸门时间永远是被测信号周期的整数倍。设预设闸门信号为base，实际闸门信号为gate，检测待测信号上升沿，当base为高电平时，实际闸门打开，gate为高电平，此时两个计数器同时对标准信号和待测信号的周期进行计数。当base为低电平，实际闸门关闭，gate为低电平计数器停止计数。下面的时序图（从别人博客摘过来的，但是他博客里说时从百度摘过来的，原博客看水印）可以很好的说明。<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNzI5MjA1NDU0OTM0?x-oss-process=image/format,png" alt="这里写图片描述"><br> 最终由公式：<br>待测信号频率/待测信号实际闸门周期数 = 标准信号频率/标准信号实际闸门周期数<br>       可以得到待测信号的频率。<br>结论：<br>       由等精度测量公式可以知道等精度测频的误差来源于标准信号，而标准信号的频率为50Mhz，可以认为误差足够小，所以可以消除+1hz或-1hz的误差。并且因为等精度测频能够在整个时域保持恒定的误差，所以非常适合用来测量可调位同步时钟信号的频率。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span>	FreMeasure(</span><br><span class="line">	<span class="keyword">input</span>							clk,</span><br><span class="line">	<span class="keyword">input</span>							rst_n,</span><br><span class="line">	<span class="keyword">input</span>							Sig_in,</span><br><span class="line">	<span class="keyword">output</span>	<span class="keyword">reg</span>	[<span class="number">31</span>:<span class="number">0</span>]	           	Fre</span><br><span class="line">);</span><br><span class="line"><span class="keyword">parameter</span> T_1s = <span class="number">28'd49_999_999</span>;</span><br><span class="line"><span class="comment">//————————————————————————</span></span><br><span class="line"><span class="comment">//			预置闸门</span></span><br><span class="line"><span class="keyword">reg</span>	[<span class="number">27</span>:<span class="number">0</span>]	TCount;</span><br><span class="line"><span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line">	<span class="keyword">if</span>(!rst_n)</span><br><span class="line">		TCount &lt;= <span class="number">28'd0</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(TCount &gt;= T_1s)</span><br><span class="line">		TCount &lt;= <span class="number">'d0</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		TCount &lt;= TCount + <span class="number">1'b1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span>	TCountCnt;</span><br><span class="line"><span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line">	<span class="keyword">if</span>(!rst_n)</span><br><span class="line">		TCountCnt &lt;= <span class="number">1'b0</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(TCount &gt;= T_1s)</span><br><span class="line">		TCountCnt &lt;= ~TCountCnt;</span><br><span class="line">		</span><br><span class="line"><span class="comment">//————————————————————————</span></span><br><span class="line"><span class="comment">//			实际闸门</span></span><br><span class="line"><span class="keyword">reg</span>	startCnt;</span><br><span class="line"><span class="keyword">always</span> @ (<span class="keyword">posedge</span> Sig_in)</span><br><span class="line">	<span class="keyword">if</span>(TCountCnt == <span class="number">1'b1</span>)</span><br><span class="line">		startCnt &lt;= <span class="number">1'b1</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		startCnt &lt;= <span class="number">1'b0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//————————————————————————</span></span><br><span class="line"><span class="comment">//			在实际闸门中计数</span></span><br><span class="line"><span class="keyword">reg</span>	[<span class="number">31</span>:<span class="number">0</span>]	SigTemp;</span><br><span class="line"><span class="keyword">always</span> @ (<span class="keyword">negedge</span> Sig_in)</span><br><span class="line">	<span class="keyword">if</span>(startCnt == <span class="number">1'b1</span>)</span><br><span class="line">		SigTemp &lt;= SigTemp + <span class="number">1'b1</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		SigTemp &lt;= <span class="number">'d0</span>;</span><br><span class="line"><span class="comment">//————————————————————————</span></span><br><span class="line"><span class="comment">//			锁存输出</span></span><br><span class="line"><span class="keyword">always</span> @ (<span class="keyword">negedge</span> startCnt)</span><br><span class="line">	Fre &lt;= SigTemp;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>FPGA</category>
      </categories>
      <tags>
        <tag>等精度测评</tag>
      </tags>
  </entry>
</search>
